var o5 = Object.defineProperty;
var l5 = (t, n, i) => n in t ? o5(t, n, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[n] = i;
var cR = (t, n, i) => (l5(t, typeof n != "symbol" ? n + "" : n, i), i);
import "./style.css";
import { resolveComponent as v4, openBlock as y4, createElementBlock as g4, createVNode as b4 } from "vue";
function s5(t, n) {
  for (var i = 0; i < n.length; i++) {
    const o = n[i];
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const u in o)
        if (u !== "default" && !(u in t)) {
          const f = Object.getOwnPropertyDescriptor(o, u);
          f && Object.defineProperty(t, u, f.get ? f : {
            enumerable: !0,
            get: () => o[u]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
var fR = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function jE(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var K_ = { exports: {} }, Cv = {}, J_ = { exports: {} }, nn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dR;
function u5() {
  if (dR)
    return nn;
  dR = 1;
  var t = Symbol.for("react.element"), n = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), p = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), S = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), w = Symbol.iterator;
  function R(O) {
    return O === null || typeof O != "object" ? null : (O = w && O[w] || O["@@iterator"], typeof O == "function" ? O : null);
  }
  var k = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, N = Object.assign, z = {};
  function I(O, ce, De) {
    this.props = O, this.context = ce, this.refs = z, this.updater = De || k;
  }
  I.prototype.isReactComponent = {}, I.prototype.setState = function(O, ce) {
    if (typeof O != "object" && typeof O != "function" && O != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, O, ce, "setState");
  }, I.prototype.forceUpdate = function(O) {
    this.updater.enqueueForceUpdate(this, O, "forceUpdate");
  };
  function H() {
  }
  H.prototype = I.prototype;
  function q(O, ce, De) {
    this.props = O, this.context = ce, this.refs = z, this.updater = De || k;
  }
  var G = q.prototype = new H();
  G.constructor = q, N(G, I.prototype), G.isPureReactComponent = !0;
  var te = Array.isArray, ee = Object.prototype.hasOwnProperty, V = { current: null }, ue = { key: !0, ref: !0, __self: !0, __source: !0 };
  function we(O, ce, De) {
    var j, rt = {}, Mt = null, lt = null;
    if (ce != null)
      for (j in ce.ref !== void 0 && (lt = ce.ref), ce.key !== void 0 && (Mt = "" + ce.key), ce)
        ee.call(ce, j) && !ue.hasOwnProperty(j) && (rt[j] = ce[j]);
    var Nt = arguments.length - 2;
    if (Nt === 1)
      rt.children = De;
    else if (1 < Nt) {
      for (var xt = Array(Nt), Zt = 0; Zt < Nt; Zt++)
        xt[Zt] = arguments[Zt + 2];
      rt.children = xt;
    }
    if (O && O.defaultProps)
      for (j in Nt = O.defaultProps, Nt)
        rt[j] === void 0 && (rt[j] = Nt[j]);
    return { $$typeof: t, type: O, key: Mt, ref: lt, props: rt, _owner: V.current };
  }
  function me(O, ce) {
    return { $$typeof: t, type: O.type, key: ce, ref: O.ref, props: O.props, _owner: O._owner };
  }
  function Le(O) {
    return typeof O == "object" && O !== null && O.$$typeof === t;
  }
  function xe(O) {
    var ce = { "=": "=0", ":": "=2" };
    return "$" + O.replace(/[=:]/g, function(De) {
      return ce[De];
    });
  }
  var ve = /\/+/g;
  function Pe(O, ce) {
    return typeof O == "object" && O !== null && O.key != null ? xe("" + O.key) : ce.toString(36);
  }
  function Ue(O, ce, De, j, rt) {
    var Mt = typeof O;
    (Mt === "undefined" || Mt === "boolean") && (O = null);
    var lt = !1;
    if (O === null)
      lt = !0;
    else
      switch (Mt) {
        case "string":
        case "number":
          lt = !0;
          break;
        case "object":
          switch (O.$$typeof) {
            case t:
            case n:
              lt = !0;
          }
      }
    if (lt)
      return lt = O, rt = rt(lt), O = j === "" ? "." + Pe(lt, 0) : j, te(rt) ? (De = "", O != null && (De = O.replace(ve, "$&/") + "/"), Ue(rt, ce, De, "", function(Zt) {
        return Zt;
      })) : rt != null && (Le(rt) && (rt = me(rt, De + (!rt.key || lt && lt.key === rt.key ? "" : ("" + rt.key).replace(ve, "$&/") + "/") + O)), ce.push(rt)), 1;
    if (lt = 0, j = j === "" ? "." : j + ":", te(O))
      for (var Nt = 0; Nt < O.length; Nt++) {
        Mt = O[Nt];
        var xt = j + Pe(Mt, Nt);
        lt += Ue(Mt, ce, De, xt, rt);
      }
    else if (xt = R(O), typeof xt == "function")
      for (O = xt.call(O), Nt = 0; !(Mt = O.next()).done; )
        Mt = Mt.value, xt = j + Pe(Mt, Nt++), lt += Ue(Mt, ce, De, xt, rt);
    else if (Mt === "object")
      throw ce = String(O), Error("Objects are not valid as a React child (found: " + (ce === "[object Object]" ? "object with keys {" + Object.keys(O).join(", ") + "}" : ce) + "). If you meant to render a collection of children, use an array instead.");
    return lt;
  }
  function We(O, ce, De) {
    if (O == null)
      return O;
    var j = [], rt = 0;
    return Ue(O, j, "", "", function(Mt) {
      return ce.call(De, Mt, rt++);
    }), j;
  }
  function at(O) {
    if (O._status === -1) {
      var ce = O._result;
      ce = ce(), ce.then(function(De) {
        (O._status === 0 || O._status === -1) && (O._status = 1, O._result = De);
      }, function(De) {
        (O._status === 0 || O._status === -1) && (O._status = 2, O._result = De);
      }), O._status === -1 && (O._status = 0, O._result = ce);
    }
    if (O._status === 1)
      return O._result.default;
    throw O._result;
  }
  var Te = { current: null }, ye = { transition: null }, Fe = { ReactCurrentDispatcher: Te, ReactCurrentBatchConfig: ye, ReactCurrentOwner: V };
  return nn.Children = { map: We, forEach: function(O, ce, De) {
    We(O, function() {
      ce.apply(this, arguments);
    }, De);
  }, count: function(O) {
    var ce = 0;
    return We(O, function() {
      ce++;
    }), ce;
  }, toArray: function(O) {
    return We(O, function(ce) {
      return ce;
    }) || [];
  }, only: function(O) {
    if (!Le(O))
      throw Error("React.Children.only expected to receive a single React element child.");
    return O;
  } }, nn.Component = I, nn.Fragment = i, nn.Profiler = u, nn.PureComponent = q, nn.StrictMode = o, nn.Suspense = b, nn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Fe, nn.cloneElement = function(O, ce, De) {
    if (O == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + O + ".");
    var j = N({}, O.props), rt = O.key, Mt = O.ref, lt = O._owner;
    if (ce != null) {
      if (ce.ref !== void 0 && (Mt = ce.ref, lt = V.current), ce.key !== void 0 && (rt = "" + ce.key), O.type && O.type.defaultProps)
        var Nt = O.type.defaultProps;
      for (xt in ce)
        ee.call(ce, xt) && !ue.hasOwnProperty(xt) && (j[xt] = ce[xt] === void 0 && Nt !== void 0 ? Nt[xt] : ce[xt]);
    }
    var xt = arguments.length - 2;
    if (xt === 1)
      j.children = De;
    else if (1 < xt) {
      Nt = Array(xt);
      for (var Zt = 0; Zt < xt; Zt++)
        Nt[Zt] = arguments[Zt + 2];
      j.children = Nt;
    }
    return { $$typeof: t, type: O.type, key: rt, ref: Mt, props: j, _owner: lt };
  }, nn.createContext = function(O) {
    return O = { $$typeof: p, _currentValue: O, _currentValue2: O, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, O.Provider = { $$typeof: f, _context: O }, O.Consumer = O;
  }, nn.createElement = we, nn.createFactory = function(O) {
    var ce = we.bind(null, O);
    return ce.type = O, ce;
  }, nn.createRef = function() {
    return { current: null };
  }, nn.forwardRef = function(O) {
    return { $$typeof: v, render: O };
  }, nn.isValidElement = Le, nn.lazy = function(O) {
    return { $$typeof: E, _payload: { _status: -1, _result: O }, _init: at };
  }, nn.memo = function(O, ce) {
    return { $$typeof: S, type: O, compare: ce === void 0 ? null : ce };
  }, nn.startTransition = function(O) {
    var ce = ye.transition;
    ye.transition = {};
    try {
      O();
    } finally {
      ye.transition = ce;
    }
  }, nn.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, nn.useCallback = function(O, ce) {
    return Te.current.useCallback(O, ce);
  }, nn.useContext = function(O) {
    return Te.current.useContext(O);
  }, nn.useDebugValue = function() {
  }, nn.useDeferredValue = function(O) {
    return Te.current.useDeferredValue(O);
  }, nn.useEffect = function(O, ce) {
    return Te.current.useEffect(O, ce);
  }, nn.useId = function() {
    return Te.current.useId();
  }, nn.useImperativeHandle = function(O, ce, De) {
    return Te.current.useImperativeHandle(O, ce, De);
  }, nn.useInsertionEffect = function(O, ce) {
    return Te.current.useInsertionEffect(O, ce);
  }, nn.useLayoutEffect = function(O, ce) {
    return Te.current.useLayoutEffect(O, ce);
  }, nn.useMemo = function(O, ce) {
    return Te.current.useMemo(O, ce);
  }, nn.useReducer = function(O, ce, De) {
    return Te.current.useReducer(O, ce, De);
  }, nn.useRef = function(O) {
    return Te.current.useRef(O);
  }, nn.useState = function(O) {
    return Te.current.useState(O);
  }, nn.useSyncExternalStore = function(O, ce, De) {
    return Te.current.useSyncExternalStore(O, ce, De);
  }, nn.useTransition = function() {
    return Te.current.useTransition();
  }, nn.version = "18.2.0", nn;
}
var Lv = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Lv.exports;
var pR;
function c5() {
  return pR || (pR = 1, function(t, n) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var i = "18.2.0", o = Symbol.for("react.element"), u = Symbol.for("react.portal"), f = Symbol.for("react.fragment"), p = Symbol.for("react.strict_mode"), v = Symbol.for("react.profiler"), b = Symbol.for("react.provider"), S = Symbol.for("react.context"), E = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), k = Symbol.for("react.memo"), N = Symbol.for("react.lazy"), z = Symbol.for("react.offscreen"), I = Symbol.iterator, H = "@@iterator";
      function q(A) {
        if (A === null || typeof A != "object")
          return null;
        var F = I && A[I] || A[H];
        return typeof F == "function" ? F : null;
      }
      var G = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, te = {
        transition: null
      }, ee = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, V = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ue = {}, we = null;
      function me(A) {
        we = A;
      }
      ue.setExtraStackFrame = function(A) {
        we = A;
      }, ue.getCurrentStack = null, ue.getStackAddendum = function() {
        var A = "";
        we && (A += we);
        var F = ue.getCurrentStack;
        return F && (A += F() || ""), A;
      };
      var Le = !1, xe = !1, ve = !1, Pe = !1, Ue = !1, We = {
        ReactCurrentDispatcher: G,
        ReactCurrentBatchConfig: te,
        ReactCurrentOwner: V
      };
      We.ReactDebugCurrentFrame = ue, We.ReactCurrentActQueue = ee;
      function at(A) {
        {
          for (var F = arguments.length, re = new Array(F > 1 ? F - 1 : 0), se = 1; se < F; se++)
            re[se - 1] = arguments[se];
          ye("warn", A, re);
        }
      }
      function Te(A) {
        {
          for (var F = arguments.length, re = new Array(F > 1 ? F - 1 : 0), se = 1; se < F; se++)
            re[se - 1] = arguments[se];
          ye("error", A, re);
        }
      }
      function ye(A, F, re) {
        {
          var se = We.ReactDebugCurrentFrame, ke = se.getStackAddendum();
          ke !== "" && (F += "%s", re = re.concat([ke]));
          var mt = re.map(function(Ie) {
            return String(Ie);
          });
          mt.unshift("Warning: " + F), Function.prototype.apply.call(console[A], console, mt);
        }
      }
      var Fe = {};
      function O(A, F) {
        {
          var re = A.constructor, se = re && (re.displayName || re.name) || "ReactClass", ke = se + "." + F;
          if (Fe[ke])
            return;
          Te("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", F, se), Fe[ke] = !0;
        }
      }
      var ce = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(A) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(A, F, re) {
          O(A, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(A, F, re, se) {
          O(A, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(A, F, re, se) {
          O(A, "setState");
        }
      }, De = Object.assign, j = {};
      Object.freeze(j);
      function rt(A, F, re) {
        this.props = A, this.context = F, this.refs = j, this.updater = re || ce;
      }
      rt.prototype.isReactComponent = {}, rt.prototype.setState = function(A, F) {
        if (typeof A != "object" && typeof A != "function" && A != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, A, F, "setState");
      }, rt.prototype.forceUpdate = function(A) {
        this.updater.enqueueForceUpdate(this, A, "forceUpdate");
      };
      {
        var Mt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, lt = function(A, F) {
          Object.defineProperty(rt.prototype, A, {
            get: function() {
              at("%s(...) is deprecated in plain JavaScript React classes. %s", F[0], F[1]);
            }
          });
        };
        for (var Nt in Mt)
          Mt.hasOwnProperty(Nt) && lt(Nt, Mt[Nt]);
      }
      function xt() {
      }
      xt.prototype = rt.prototype;
      function Zt(A, F, re) {
        this.props = A, this.context = F, this.refs = j, this.updater = re || ce;
      }
      var er = Zt.prototype = new xt();
      er.constructor = Zt, De(er, rt.prototype), er.isPureReactComponent = !0;
      function hr() {
        var A = {
          current: null
        };
        return Object.seal(A), A;
      }
      var Jr = Array.isArray;
      function zn(A) {
        return Jr(A);
      }
      function sr(A) {
        {
          var F = typeof Symbol == "function" && Symbol.toStringTag, re = F && A[Symbol.toStringTag] || A.constructor.name || "Object";
          return re;
        }
      }
      function tr(A) {
        try {
          return nr(A), !1;
        } catch {
          return !0;
        }
      }
      function nr(A) {
        return "" + A;
      }
      function Zn(A) {
        if (tr(A))
          return Te("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", sr(A)), nr(A);
      }
      function jr(A, F, re) {
        var se = A.displayName;
        if (se)
          return se;
        var ke = F.displayName || F.name || "";
        return ke !== "" ? re + "(" + ke + ")" : re;
      }
      function Ir(A) {
        return A.displayName || "Context";
      }
      function mr(A) {
        if (A == null)
          return null;
        if (typeof A.tag == "number" && Te("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof A == "function")
          return A.displayName || A.name || null;
        if (typeof A == "string")
          return A;
        switch (A) {
          case f:
            return "Fragment";
          case u:
            return "Portal";
          case v:
            return "Profiler";
          case p:
            return "StrictMode";
          case w:
            return "Suspense";
          case R:
            return "SuspenseList";
        }
        if (typeof A == "object")
          switch (A.$$typeof) {
            case S:
              var F = A;
              return Ir(F) + ".Consumer";
            case b:
              var re = A;
              return Ir(re._context) + ".Provider";
            case E:
              return jr(A, A.render, "ForwardRef");
            case k:
              var se = A.displayName || null;
              return se !== null ? se : mr(A.type) || "Memo";
            case N: {
              var ke = A, mt = ke._payload, Ie = ke._init;
              try {
                return mr(Ie(mt));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Tr = Object.prototype.hasOwnProperty, ei = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Rr, ci, le;
      le = {};
      function Ce(A) {
        if (Tr.call(A, "ref")) {
          var F = Object.getOwnPropertyDescriptor(A, "ref").get;
          if (F && F.isReactWarning)
            return !1;
        }
        return A.ref !== void 0;
      }
      function Ge(A) {
        if (Tr.call(A, "key")) {
          var F = Object.getOwnPropertyDescriptor(A, "key").get;
          if (F && F.isReactWarning)
            return !1;
        }
        return A.key !== void 0;
      }
      function gt(A, F) {
        var re = function() {
          Rr || (Rr = !0, Te("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", F));
        };
        re.isReactWarning = !0, Object.defineProperty(A, "key", {
          get: re,
          configurable: !0
        });
      }
      function It(A, F) {
        var re = function() {
          ci || (ci = !0, Te("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", F));
        };
        re.isReactWarning = !0, Object.defineProperty(A, "ref", {
          get: re,
          configurable: !0
        });
      }
      function $n(A) {
        if (typeof A.ref == "string" && V.current && A.__self && V.current.stateNode !== A.__self) {
          var F = mr(V.current.type);
          le[F] || (Te('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', F, A.ref), le[F] = !0);
        }
      }
      var Re = function(A, F, re, se, ke, mt, Ie) {
        var pt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: o,
          // Built-in properties that belong on the element
          type: A,
          key: F,
          ref: re,
          props: Ie,
          // Record the component responsible for creating this element.
          _owner: mt
        };
        return pt._store = {}, Object.defineProperty(pt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(pt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: se
        }), Object.defineProperty(pt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ke
        }), Object.freeze && (Object.freeze(pt.props), Object.freeze(pt)), pt;
      };
      function Xe(A, F, re) {
        var se, ke = {}, mt = null, Ie = null, pt = null, Ut = null;
        if (F != null) {
          Ce(F) && (Ie = F.ref, $n(F)), Ge(F) && (Zn(F.key), mt = "" + F.key), pt = F.__self === void 0 ? null : F.__self, Ut = F.__source === void 0 ? null : F.__source;
          for (se in F)
            Tr.call(F, se) && !ei.hasOwnProperty(se) && (ke[se] = F[se]);
        }
        var ln = arguments.length - 2;
        if (ln === 1)
          ke.children = re;
        else if (ln > 1) {
          for (var Rn = Array(ln), _n = 0; _n < ln; _n++)
            Rn[_n] = arguments[_n + 2];
          Object.freeze && Object.freeze(Rn), ke.children = Rn;
        }
        if (A && A.defaultProps) {
          var On = A.defaultProps;
          for (se in On)
            ke[se] === void 0 && (ke[se] = On[se]);
        }
        if (mt || Ie) {
          var Ln = typeof A == "function" ? A.displayName || A.name || "Unknown" : A;
          mt && gt(ke, Ln), Ie && It(ke, Ln);
        }
        return Re(A, mt, Ie, pt, Ut, V.current, ke);
      }
      function Ct(A, F) {
        var re = Re(A.type, F, A.ref, A._self, A._source, A._owner, A.props);
        return re;
      }
      function qt(A, F, re) {
        if (A == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + A + ".");
        var se, ke = De({}, A.props), mt = A.key, Ie = A.ref, pt = A._self, Ut = A._source, ln = A._owner;
        if (F != null) {
          Ce(F) && (Ie = F.ref, ln = V.current), Ge(F) && (Zn(F.key), mt = "" + F.key);
          var Rn;
          A.type && A.type.defaultProps && (Rn = A.type.defaultProps);
          for (se in F)
            Tr.call(F, se) && !ei.hasOwnProperty(se) && (F[se] === void 0 && Rn !== void 0 ? ke[se] = Rn[se] : ke[se] = F[se]);
        }
        var _n = arguments.length - 2;
        if (_n === 1)
          ke.children = re;
        else if (_n > 1) {
          for (var On = Array(_n), Ln = 0; Ln < _n; Ln++)
            On[Ln] = arguments[Ln + 2];
          ke.children = On;
        }
        return Re(A.type, mt, Ie, pt, Ut, ln, ke);
      }
      function At(A) {
        return typeof A == "object" && A !== null && A.$$typeof === o;
      }
      var Cn = ".", sn = ":";
      function ti(A) {
        var F = /[=:]/g, re = {
          "=": "=0",
          ":": "=2"
        }, se = A.replace(F, function(ke) {
          return re[ke];
        });
        return "$" + se;
      }
      var wn = !1, fi = /\/+/g;
      function mn(A) {
        return A.replace(fi, "$&/");
      }
      function vn(A, F) {
        return typeof A == "object" && A !== null && A.key != null ? (Zn(A.key), ti("" + A.key)) : F.toString(36);
      }
      function ja(A, F, re, se, ke) {
        var mt = typeof A;
        (mt === "undefined" || mt === "boolean") && (A = null);
        var Ie = !1;
        if (A === null)
          Ie = !0;
        else
          switch (mt) {
            case "string":
            case "number":
              Ie = !0;
              break;
            case "object":
              switch (A.$$typeof) {
                case o:
                case u:
                  Ie = !0;
              }
          }
        if (Ie) {
          var pt = A, Ut = ke(pt), ln = se === "" ? Cn + vn(pt, 0) : se;
          if (zn(Ut)) {
            var Rn = "";
            ln != null && (Rn = mn(ln) + "/"), ja(Ut, F, Rn, "", function(bh) {
              return bh;
            });
          } else
            Ut != null && (At(Ut) && (Ut.key && (!pt || pt.key !== Ut.key) && Zn(Ut.key), Ut = Ct(
              Ut,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              re + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Ut.key && (!pt || pt.key !== Ut.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                mn("" + Ut.key) + "/"
              ) : "") + ln
            )), F.push(Ut));
          return 1;
        }
        var _n, On, Ln = 0, Qt = se === "" ? Cn : se + sn;
        if (zn(A))
          for (var Mo = 0; Mo < A.length; Mo++)
            _n = A[Mo], On = Qt + vn(_n, Mo), Ln += ja(_n, F, re, On, ke);
        else {
          var Tu = q(A);
          if (typeof Tu == "function") {
            var jc = A;
            Tu === jc.entries && (wn || at("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), wn = !0);
            for (var gh = Tu.call(jc), Ba, Ic = 0; !(Ba = gh.next()).done; )
              _n = Ba.value, On = Qt + vn(_n, Ic++), Ln += ja(_n, F, re, On, ke);
          } else if (mt === "object") {
            var Fc = String(A);
            throw new Error("Objects are not valid as a React child (found: " + (Fc === "[object Object]" ? "object with keys {" + Object.keys(A).join(", ") + "}" : Fc) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Ln;
      }
      function pa(A, F, re) {
        if (A == null)
          return A;
        var se = [], ke = 0;
        return ja(A, se, "", "", function(mt) {
          return F.call(re, mt, ke++);
        }), se;
      }
      function hl(A) {
        var F = 0;
        return pa(A, function() {
          F++;
        }), F;
      }
      function hs(A, F, re) {
        pa(A, function() {
          F.apply(this, arguments);
        }, re);
      }
      function mu(A) {
        return pa(A, function(F) {
          return F;
        }) || [];
      }
      function Oo(A) {
        if (!At(A))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return A;
      }
      function ml(A) {
        var F = {
          $$typeof: S,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: A,
          _currentValue2: A,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        F.Provider = {
          $$typeof: b,
          _context: F
        };
        var re = !1, se = !1, ke = !1;
        {
          var mt = {
            $$typeof: S,
            _context: F
          };
          Object.defineProperties(mt, {
            Provider: {
              get: function() {
                return se || (se = !0, Te("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), F.Provider;
              },
              set: function(Ie) {
                F.Provider = Ie;
              }
            },
            _currentValue: {
              get: function() {
                return F._currentValue;
              },
              set: function(Ie) {
                F._currentValue = Ie;
              }
            },
            _currentValue2: {
              get: function() {
                return F._currentValue2;
              },
              set: function(Ie) {
                F._currentValue2 = Ie;
              }
            },
            _threadCount: {
              get: function() {
                return F._threadCount;
              },
              set: function(Ie) {
                F._threadCount = Ie;
              }
            },
            Consumer: {
              get: function() {
                return re || (re = !0, Te("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), F.Consumer;
              }
            },
            displayName: {
              get: function() {
                return F.displayName;
              },
              set: function(Ie) {
                ke || (at("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Ie), ke = !0);
              }
            }
          }), F.Consumer = mt;
        }
        return F._currentRenderer = null, F._currentRenderer2 = null, F;
      }
      var Xi = -1, ro = 0, Qi = 1, io = 2;
      function di(A) {
        if (A._status === Xi) {
          var F = A._result, re = F();
          if (re.then(function(mt) {
            if (A._status === ro || A._status === Xi) {
              var Ie = A;
              Ie._status = Qi, Ie._result = mt;
            }
          }, function(mt) {
            if (A._status === ro || A._status === Xi) {
              var Ie = A;
              Ie._status = io, Ie._result = mt;
            }
          }), A._status === Xi) {
            var se = A;
            se._status = ro, se._result = re;
          }
        }
        if (A._status === Qi) {
          var ke = A._result;
          return ke === void 0 && Te(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ke), "default" in ke || Te(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ke), ke.default;
        } else
          throw A._result;
      }
      function Ki(A) {
        var F = {
          // We use these fields to store the result.
          _status: Xi,
          _result: A
        }, re = {
          $$typeof: N,
          _payload: F,
          _init: di
        };
        {
          var se, ke;
          Object.defineProperties(re, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return se;
              },
              set: function(mt) {
                Te("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), se = mt, Object.defineProperty(re, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return ke;
              },
              set: function(mt) {
                Te("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), ke = mt, Object.defineProperty(re, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return re;
      }
      function ao(A) {
        A != null && A.$$typeof === k ? Te("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof A != "function" ? Te("forwardRef requires a render function but was given %s.", A === null ? "null" : typeof A) : A.length !== 0 && A.length !== 2 && Te("forwardRef render functions accept exactly two parameters: props and ref. %s", A.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), A != null && (A.defaultProps != null || A.propTypes != null) && Te("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var F = {
          $$typeof: E,
          render: A
        };
        {
          var re;
          Object.defineProperty(F, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return re;
            },
            set: function(se) {
              re = se, !A.name && !A.displayName && (A.displayName = se);
            }
          });
        }
        return F;
      }
      var U;
      U = Symbol.for("react.module.reference");
      function ge(A) {
        return !!(typeof A == "string" || typeof A == "function" || A === f || A === v || Ue || A === p || A === w || A === R || Pe || A === z || Le || xe || ve || typeof A == "object" && A !== null && (A.$$typeof === N || A.$$typeof === k || A.$$typeof === b || A.$$typeof === S || A.$$typeof === E || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        A.$$typeof === U || A.getModuleId !== void 0));
      }
      function ze(A, F) {
        ge(A) || Te("memo: The first argument must be a component. Instead received: %s", A === null ? "null" : typeof A);
        var re = {
          $$typeof: k,
          type: A,
          compare: F === void 0 ? null : F
        };
        {
          var se;
          Object.defineProperty(re, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return se;
            },
            set: function(ke) {
              se = ke, !A.name && !A.displayName && (A.displayName = ke);
            }
          });
        }
        return re;
      }
      function Ye() {
        var A = G.current;
        return A === null && Te(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), A;
      }
      function Dt(A) {
        var F = Ye();
        if (A._context !== void 0) {
          var re = A._context;
          re.Consumer === A ? Te("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : re.Provider === A && Te("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return F.useContext(A);
      }
      function Kt(A) {
        var F = Ye();
        return F.useState(A);
      }
      function Lt(A, F, re) {
        var se = Ye();
        return se.useReducer(A, F, re);
      }
      function ft(A) {
        var F = Ye();
        return F.useRef(A);
      }
      function vr(A, F) {
        var re = Ye();
        return re.useEffect(A, F);
      }
      function Mn(A, F) {
        var re = Ye();
        return re.useInsertionEffect(A, F);
      }
      function Nn(A, F) {
        var re = Ye();
        return re.useLayoutEffect(A, F);
      }
      function Fr(A, F) {
        var re = Ye();
        return re.useCallback(A, F);
      }
      function oo(A, F) {
        var re = Ye();
        return re.useMemo(A, F);
      }
      function vu(A, F, re) {
        var se = Ye();
        return se.useImperativeHandle(A, F, re);
      }
      function an(A, F) {
        {
          var re = Ye();
          return re.useDebugValue(A, F);
        }
      }
      function vh() {
        var A = Ye();
        return A.useTransition();
      }
      function Ia(A) {
        var F = Ye();
        return F.useDeferredValue(A);
      }
      function Ft() {
        var A = Ye();
        return A.useId();
      }
      function lo(A, F, re) {
        var se = Ye();
        return se.useSyncExternalStore(A, F, re);
      }
      var vl = 0, yu, yl, Ri, Lc, pi, Pc, zc;
      function Jf() {
      }
      Jf.__reactDisabledLog = !0;
      function gu() {
        {
          if (vl === 0) {
            yu = console.log, yl = console.info, Ri = console.warn, Lc = console.error, pi = console.group, Pc = console.groupCollapsed, zc = console.groupEnd;
            var A = {
              configurable: !0,
              enumerable: !0,
              value: Jf,
              writable: !0
            };
            Object.defineProperties(console, {
              info: A,
              log: A,
              warn: A,
              error: A,
              group: A,
              groupCollapsed: A,
              groupEnd: A
            });
          }
          vl++;
        }
      }
      function gl() {
        {
          if (vl--, vl === 0) {
            var A = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: De({}, A, {
                value: yu
              }),
              info: De({}, A, {
                value: yl
              }),
              warn: De({}, A, {
                value: Ri
              }),
              error: De({}, A, {
                value: Lc
              }),
              group: De({}, A, {
                value: pi
              }),
              groupCollapsed: De({}, A, {
                value: Pc
              }),
              groupEnd: De({}, A, {
                value: zc
              })
            });
          }
          vl < 0 && Te("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Fa = We.ReactCurrentDispatcher, hi;
      function bl(A, F, re) {
        {
          if (hi === void 0)
            try {
              throw Error();
            } catch (ke) {
              var se = ke.stack.trim().match(/\n( *(at )?)/);
              hi = se && se[1] || "";
            }
          return `
` + hi + A;
        }
      }
      var Sl = !1, xl;
      {
        var bu = typeof WeakMap == "function" ? WeakMap : Map;
        xl = new bu();
      }
      function Su(A, F) {
        if (!A || Sl)
          return "";
        {
          var re = xl.get(A);
          if (re !== void 0)
            return re;
        }
        var se;
        Sl = !0;
        var ke = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var mt;
        mt = Fa.current, Fa.current = null, gu();
        try {
          if (F) {
            var Ie = function() {
              throw Error();
            };
            if (Object.defineProperty(Ie.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Ie, []);
              } catch (Qt) {
                se = Qt;
              }
              Reflect.construct(A, [], Ie);
            } else {
              try {
                Ie.call();
              } catch (Qt) {
                se = Qt;
              }
              A.call(Ie.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Qt) {
              se = Qt;
            }
            A();
          }
        } catch (Qt) {
          if (Qt && se && typeof Qt.stack == "string") {
            for (var pt = Qt.stack.split(`
`), Ut = se.stack.split(`
`), ln = pt.length - 1, Rn = Ut.length - 1; ln >= 1 && Rn >= 0 && pt[ln] !== Ut[Rn]; )
              Rn--;
            for (; ln >= 1 && Rn >= 0; ln--, Rn--)
              if (pt[ln] !== Ut[Rn]) {
                if (ln !== 1 || Rn !== 1)
                  do
                    if (ln--, Rn--, Rn < 0 || pt[ln] !== Ut[Rn]) {
                      var _n = `
` + pt[ln].replace(" at new ", " at ");
                      return A.displayName && _n.includes("<anonymous>") && (_n = _n.replace("<anonymous>", A.displayName)), typeof A == "function" && xl.set(A, _n), _n;
                    }
                  while (ln >= 1 && Rn >= 0);
                break;
              }
          }
        } finally {
          Sl = !1, Fa.current = mt, gl(), Error.prepareStackTrace = ke;
        }
        var On = A ? A.displayName || A.name : "", Ln = On ? bl(On) : "";
        return typeof A == "function" && xl.set(A, Ln), Ln;
      }
      function Ao(A, F, re) {
        return Su(A, !1);
      }
      function yh(A) {
        var F = A.prototype;
        return !!(F && F.isReactComponent);
      }
      function so(A, F, re) {
        if (A == null)
          return "";
        if (typeof A == "function")
          return Su(A, yh(A));
        if (typeof A == "string")
          return bl(A);
        switch (A) {
          case w:
            return bl("Suspense");
          case R:
            return bl("SuspenseList");
        }
        if (typeof A == "object")
          switch (A.$$typeof) {
            case E:
              return Ao(A.render);
            case k:
              return so(A.type, F, re);
            case N: {
              var se = A, ke = se._payload, mt = se._init;
              try {
                return so(mt(ke), F, re);
              } catch {
              }
            }
          }
        return "";
      }
      var cn = {}, xu = We.ReactDebugCurrentFrame;
      function ms(A) {
        if (A) {
          var F = A._owner, re = so(A.type, A._source, F ? F.type : null);
          xu.setExtraStackFrame(re);
        } else
          xu.setExtraStackFrame(null);
      }
      function wu(A, F, re, se, ke) {
        {
          var mt = Function.call.bind(Tr);
          for (var Ie in A)
            if (mt(A, Ie)) {
              var pt = void 0;
              try {
                if (typeof A[Ie] != "function") {
                  var Ut = Error((se || "React class") + ": " + re + " type `" + Ie + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof A[Ie] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ut.name = "Invariant Violation", Ut;
                }
                pt = A[Ie](F, Ie, se, re, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ln) {
                pt = ln;
              }
              pt && !(pt instanceof Error) && (ms(ke), Te("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", se || "React class", re, Ie, typeof pt), ms(null)), pt instanceof Error && !(pt.message in cn) && (cn[pt.message] = !0, ms(ke), Te("Failed %s type: %s", re, pt.message), ms(null));
            }
        }
      }
      function on(A) {
        if (A) {
          var F = A._owner, re = so(A.type, A._source, F ? F.type : null);
          me(re);
        } else
          me(null);
      }
      var _u;
      _u = !1;
      function Eu() {
        if (V.current) {
          var A = mr(V.current.type);
          if (A)
            return `

Check the render method of \`` + A + "`.";
        }
        return "";
      }
      function kt(A) {
        if (A !== void 0) {
          var F = A.fileName.replace(/^.*[\\\/]/, ""), re = A.lineNumber;
          return `

Check your code at ` + F + ":" + re + ".";
        }
        return "";
      }
      function vs(A) {
        return A != null ? kt(A.__source) : "";
      }
      var qn = {};
      function Oi(A) {
        var F = Eu();
        if (!F) {
          var re = typeof A == "string" ? A : A.displayName || A.name;
          re && (F = `

Check the top-level render call using <` + re + ">.");
        }
        return F;
      }
      function mi(A, F) {
        if (!(!A._store || A._store.validated || A.key != null)) {
          A._store.validated = !0;
          var re = Oi(F);
          if (!qn[re]) {
            qn[re] = !0;
            var se = "";
            A && A._owner && A._owner !== V.current && (se = " It was passed a child from " + mr(A._owner.type) + "."), on(A), Te('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', re, se), on(null);
          }
        }
      }
      function wl(A, F) {
        if (typeof A == "object") {
          if (zn(A))
            for (var re = 0; re < A.length; re++) {
              var se = A[re];
              At(se) && mi(se, F);
            }
          else if (At(A))
            A._store && (A._store.validated = !0);
          else if (A) {
            var ke = q(A);
            if (typeof ke == "function" && ke !== A.entries)
              for (var mt = ke.call(A), Ie; !(Ie = mt.next()).done; )
                At(Ie.value) && mi(Ie.value, F);
          }
        }
      }
      function rr(A) {
        {
          var F = A.type;
          if (F == null || typeof F == "string")
            return;
          var re;
          if (typeof F == "function")
            re = F.propTypes;
          else if (typeof F == "object" && (F.$$typeof === E || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          F.$$typeof === k))
            re = F.propTypes;
          else
            return;
          if (re) {
            var se = mr(F);
            wu(re, A.props, "prop", se, A);
          } else if (F.PropTypes !== void 0 && !_u) {
            _u = !0;
            var ke = mr(F);
            Te("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ke || "Unknown");
          }
          typeof F.getDefaultProps == "function" && !F.getDefaultProps.isReactClassApproved && Te("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function yn(A) {
        {
          for (var F = Object.keys(A.props), re = 0; re < F.length; re++) {
            var se = F[re];
            if (se !== "children" && se !== "key") {
              on(A), Te("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", se), on(null);
              break;
            }
          }
          A.ref !== null && (on(A), Te("Invalid attribute `ref` supplied to `React.Fragment`."), on(null));
        }
      }
      function ed(A, F, re) {
        var se = ge(A);
        if (!se) {
          var ke = "";
          (A === void 0 || typeof A == "object" && A !== null && Object.keys(A).length === 0) && (ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var mt = vs(F);
          mt ? ke += mt : ke += Eu();
          var Ie;
          A === null ? Ie = "null" : zn(A) ? Ie = "array" : A !== void 0 && A.$$typeof === o ? (Ie = "<" + (mr(A.type) || "Unknown") + " />", ke = " Did you accidentally export a JSX literal instead of a component?") : Ie = typeof A, Te("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ie, ke);
        }
        var pt = Xe.apply(this, arguments);
        if (pt == null)
          return pt;
        if (se)
          for (var Ut = 2; Ut < arguments.length; Ut++)
            wl(arguments[Ut], A);
        return A === f ? yn(pt) : rr(pt), pt;
      }
      var Ai = !1;
      function Or(A) {
        var F = ed.bind(null, A);
        return F.type = A, Ai || (Ai = !0, at("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(F, "type", {
          enumerable: !1,
          get: function() {
            return at("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: A
            }), A;
          }
        }), F;
      }
      function uo(A, F, re) {
        for (var se = qt.apply(this, arguments), ke = 2; ke < arguments.length; ke++)
          wl(arguments[ke], se.type);
        return rr(se), se;
      }
      function td(A, F) {
        var re = te.transition;
        te.transition = {};
        var se = te.transition;
        te.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          A();
        } finally {
          if (te.transition = re, re === null && se._updatedFibers) {
            var ke = se._updatedFibers.size;
            ke > 10 && at("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), se._updatedFibers.clear();
          }
        }
      }
      var Do = !1, _l = null;
      function nd(A) {
        if (_l === null)
          try {
            var F = ("require" + Math.random()).slice(0, 7), re = t && t[F];
            _l = re.call(t, "timers").setImmediate;
          } catch {
            _l = function(ke) {
              Do === !1 && (Do = !0, typeof MessageChannel > "u" && Te("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var mt = new MessageChannel();
              mt.port1.onmessage = ke, mt.port2.postMessage(void 0);
            };
          }
        return _l(A);
      }
      var ha = 0, El = !1;
      function Cl(A) {
        {
          var F = ha;
          ha++, ee.current === null && (ee.current = []);
          var re = ee.isBatchingLegacy, se;
          try {
            if (ee.isBatchingLegacy = !0, se = A(), !re && ee.didScheduleLegacyUpdate) {
              var ke = ee.current;
              ke !== null && (ee.didScheduleLegacyUpdate = !1, Tl(ke));
            }
          } catch (On) {
            throw ma(F), On;
          } finally {
            ee.isBatchingLegacy = re;
          }
          if (se !== null && typeof se == "object" && typeof se.then == "function") {
            var mt = se, Ie = !1, pt = {
              then: function(On, Ln) {
                Ie = !0, mt.then(function(Qt) {
                  ma(F), ha === 0 ? Cu(Qt, On, Ln) : On(Qt);
                }, function(Qt) {
                  ma(F), Ln(Qt);
                });
              }
            };
            return !El && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Ie || (El = !0, Te("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), pt;
          } else {
            var Ut = se;
            if (ma(F), ha === 0) {
              var ln = ee.current;
              ln !== null && (Tl(ln), ee.current = null);
              var Rn = {
                then: function(On, Ln) {
                  ee.current === null ? (ee.current = [], Cu(Ut, On, Ln)) : On(Ut);
                }
              };
              return Rn;
            } else {
              var _n = {
                then: function(On, Ln) {
                  On(Ut);
                }
              };
              return _n;
            }
          }
        }
      }
      function ma(A) {
        A !== ha - 1 && Te("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), ha = A;
      }
      function Cu(A, F, re) {
        {
          var se = ee.current;
          if (se !== null)
            try {
              Tl(se), nd(function() {
                se.length === 0 ? (ee.current = null, F(A)) : Cu(A, F, re);
              });
            } catch (ke) {
              re(ke);
            }
          else
            F(A);
        }
      }
      var kl = !1;
      function Tl(A) {
        if (!kl) {
          kl = !0;
          var F = 0;
          try {
            for (; F < A.length; F++) {
              var re = A[F];
              do
                re = re(!0);
              while (re !== null);
            }
            A.length = 0;
          } catch (se) {
            throw A = A.slice(F + 1), se;
          } finally {
            kl = !1;
          }
        }
      }
      var ys = ed, ku = uo, $c = Or, Ua = {
        map: pa,
        forEach: hs,
        count: hl,
        toArray: mu,
        only: Oo
      };
      n.Children = Ua, n.Component = rt, n.Fragment = f, n.Profiler = v, n.PureComponent = Zt, n.StrictMode = p, n.Suspense = w, n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = We, n.cloneElement = ku, n.createContext = ml, n.createElement = ys, n.createFactory = $c, n.createRef = hr, n.forwardRef = ao, n.isValidElement = At, n.lazy = Ki, n.memo = ze, n.startTransition = td, n.unstable_act = Cl, n.useCallback = Fr, n.useContext = Dt, n.useDebugValue = an, n.useDeferredValue = Ia, n.useEffect = vr, n.useId = Ft, n.useImperativeHandle = vu, n.useInsertionEffect = Mn, n.useLayoutEffect = Nn, n.useMemo = oo, n.useReducer = Lt, n.useRef = ft, n.useState = Kt, n.useSyncExternalStore = lo, n.useTransition = vh, n.version = i, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Lv, Lv.exports)), Lv.exports;
}
process.env.NODE_ENV === "production" ? J_.exports = u5() : J_.exports = c5();
var L = J_.exports;
const f5 = /* @__PURE__ */ jE(L), d5 = /* @__PURE__ */ s5({
  __proto__: null,
  default: f5
}, [L]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hR;
function p5() {
  if (hR)
    return Cv;
  hR = 1;
  var t = L, n = Symbol.for("react.element"), i = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, u = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 };
  function p(v, b, S) {
    var E, w = {}, R = null, k = null;
    S !== void 0 && (R = "" + S), b.key !== void 0 && (R = "" + b.key), b.ref !== void 0 && (k = b.ref);
    for (E in b)
      o.call(b, E) && !f.hasOwnProperty(E) && (w[E] = b[E]);
    if (v && v.defaultProps)
      for (E in b = v.defaultProps, b)
        w[E] === void 0 && (w[E] = b[E]);
    return { $$typeof: n, type: v, key: R, ref: k, props: w, _owner: u.current };
  }
  return Cv.Fragment = i, Cv.jsx = p, Cv.jsxs = p, Cv;
}
var kv = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mR;
function h5() {
  return mR || (mR = 1, process.env.NODE_ENV !== "production" && function() {
    var t = L, n = Symbol.for("react.element"), i = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), p = Symbol.for("react.provider"), v = Symbol.for("react.context"), b = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), E = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), R = Symbol.for("react.lazy"), k = Symbol.for("react.offscreen"), N = Symbol.iterator, z = "@@iterator";
    function I(U) {
      if (U === null || typeof U != "object")
        return null;
      var ge = N && U[N] || U[z];
      return typeof ge == "function" ? ge : null;
    }
    var H = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function q(U) {
      {
        for (var ge = arguments.length, ze = new Array(ge > 1 ? ge - 1 : 0), Ye = 1; Ye < ge; Ye++)
          ze[Ye - 1] = arguments[Ye];
        G("error", U, ze);
      }
    }
    function G(U, ge, ze) {
      {
        var Ye = H.ReactDebugCurrentFrame, Dt = Ye.getStackAddendum();
        Dt !== "" && (ge += "%s", ze = ze.concat([Dt]));
        var Kt = ze.map(function(Lt) {
          return String(Lt);
        });
        Kt.unshift("Warning: " + ge), Function.prototype.apply.call(console[U], console, Kt);
      }
    }
    var te = !1, ee = !1, V = !1, ue = !1, we = !1, me;
    me = Symbol.for("react.module.reference");
    function Le(U) {
      return !!(typeof U == "string" || typeof U == "function" || U === o || U === f || we || U === u || U === S || U === E || ue || U === k || te || ee || V || typeof U == "object" && U !== null && (U.$$typeof === R || U.$$typeof === w || U.$$typeof === p || U.$$typeof === v || U.$$typeof === b || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      U.$$typeof === me || U.getModuleId !== void 0));
    }
    function xe(U, ge, ze) {
      var Ye = U.displayName;
      if (Ye)
        return Ye;
      var Dt = ge.displayName || ge.name || "";
      return Dt !== "" ? ze + "(" + Dt + ")" : ze;
    }
    function ve(U) {
      return U.displayName || "Context";
    }
    function Pe(U) {
      if (U == null)
        return null;
      if (typeof U.tag == "number" && q("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
        return U.displayName || U.name || null;
      if (typeof U == "string")
        return U;
      switch (U) {
        case o:
          return "Fragment";
        case i:
          return "Portal";
        case f:
          return "Profiler";
        case u:
          return "StrictMode";
        case S:
          return "Suspense";
        case E:
          return "SuspenseList";
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case v:
            var ge = U;
            return ve(ge) + ".Consumer";
          case p:
            var ze = U;
            return ve(ze._context) + ".Provider";
          case b:
            return xe(U, U.render, "ForwardRef");
          case w:
            var Ye = U.displayName || null;
            return Ye !== null ? Ye : Pe(U.type) || "Memo";
          case R: {
            var Dt = U, Kt = Dt._payload, Lt = Dt._init;
            try {
              return Pe(Lt(Kt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ue = Object.assign, We = 0, at, Te, ye, Fe, O, ce, De;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function rt() {
      {
        if (We === 0) {
          at = console.log, Te = console.info, ye = console.warn, Fe = console.error, O = console.group, ce = console.groupCollapsed, De = console.groupEnd;
          var U = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: U,
            log: U,
            warn: U,
            error: U,
            group: U,
            groupCollapsed: U,
            groupEnd: U
          });
        }
        We++;
      }
    }
    function Mt() {
      {
        if (We--, We === 0) {
          var U = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ue({}, U, {
              value: at
            }),
            info: Ue({}, U, {
              value: Te
            }),
            warn: Ue({}, U, {
              value: ye
            }),
            error: Ue({}, U, {
              value: Fe
            }),
            group: Ue({}, U, {
              value: O
            }),
            groupCollapsed: Ue({}, U, {
              value: ce
            }),
            groupEnd: Ue({}, U, {
              value: De
            })
          });
        }
        We < 0 && q("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var lt = H.ReactCurrentDispatcher, Nt;
    function xt(U, ge, ze) {
      {
        if (Nt === void 0)
          try {
            throw Error();
          } catch (Dt) {
            var Ye = Dt.stack.trim().match(/\n( *(at )?)/);
            Nt = Ye && Ye[1] || "";
          }
        return `
` + Nt + U;
      }
    }
    var Zt = !1, er;
    {
      var hr = typeof WeakMap == "function" ? WeakMap : Map;
      er = new hr();
    }
    function Jr(U, ge) {
      if (!U || Zt)
        return "";
      {
        var ze = er.get(U);
        if (ze !== void 0)
          return ze;
      }
      var Ye;
      Zt = !0;
      var Dt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Kt;
      Kt = lt.current, lt.current = null, rt();
      try {
        if (ge) {
          var Lt = function() {
            throw Error();
          };
          if (Object.defineProperty(Lt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Lt, []);
            } catch (an) {
              Ye = an;
            }
            Reflect.construct(U, [], Lt);
          } else {
            try {
              Lt.call();
            } catch (an) {
              Ye = an;
            }
            U.call(Lt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (an) {
            Ye = an;
          }
          U();
        }
      } catch (an) {
        if (an && Ye && typeof an.stack == "string") {
          for (var ft = an.stack.split(`
`), vr = Ye.stack.split(`
`), Mn = ft.length - 1, Nn = vr.length - 1; Mn >= 1 && Nn >= 0 && ft[Mn] !== vr[Nn]; )
            Nn--;
          for (; Mn >= 1 && Nn >= 0; Mn--, Nn--)
            if (ft[Mn] !== vr[Nn]) {
              if (Mn !== 1 || Nn !== 1)
                do
                  if (Mn--, Nn--, Nn < 0 || ft[Mn] !== vr[Nn]) {
                    var Fr = `
` + ft[Mn].replace(" at new ", " at ");
                    return U.displayName && Fr.includes("<anonymous>") && (Fr = Fr.replace("<anonymous>", U.displayName)), typeof U == "function" && er.set(U, Fr), Fr;
                  }
                while (Mn >= 1 && Nn >= 0);
              break;
            }
        }
      } finally {
        Zt = !1, lt.current = Kt, Mt(), Error.prepareStackTrace = Dt;
      }
      var oo = U ? U.displayName || U.name : "", vu = oo ? xt(oo) : "";
      return typeof U == "function" && er.set(U, vu), vu;
    }
    function zn(U, ge, ze) {
      return Jr(U, !1);
    }
    function sr(U) {
      var ge = U.prototype;
      return !!(ge && ge.isReactComponent);
    }
    function tr(U, ge, ze) {
      if (U == null)
        return "";
      if (typeof U == "function")
        return Jr(U, sr(U));
      if (typeof U == "string")
        return xt(U);
      switch (U) {
        case S:
          return xt("Suspense");
        case E:
          return xt("SuspenseList");
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case b:
            return zn(U.render);
          case w:
            return tr(U.type, ge, ze);
          case R: {
            var Ye = U, Dt = Ye._payload, Kt = Ye._init;
            try {
              return tr(Kt(Dt), ge, ze);
            } catch {
            }
          }
        }
      return "";
    }
    var nr = Object.prototype.hasOwnProperty, Zn = {}, jr = H.ReactDebugCurrentFrame;
    function Ir(U) {
      if (U) {
        var ge = U._owner, ze = tr(U.type, U._source, ge ? ge.type : null);
        jr.setExtraStackFrame(ze);
      } else
        jr.setExtraStackFrame(null);
    }
    function mr(U, ge, ze, Ye, Dt) {
      {
        var Kt = Function.call.bind(nr);
        for (var Lt in U)
          if (Kt(U, Lt)) {
            var ft = void 0;
            try {
              if (typeof U[Lt] != "function") {
                var vr = Error((Ye || "React class") + ": " + ze + " type `" + Lt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[Lt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw vr.name = "Invariant Violation", vr;
              }
              ft = U[Lt](ge, Lt, Ye, ze, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Mn) {
              ft = Mn;
            }
            ft && !(ft instanceof Error) && (Ir(Dt), q("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ye || "React class", ze, Lt, typeof ft), Ir(null)), ft instanceof Error && !(ft.message in Zn) && (Zn[ft.message] = !0, Ir(Dt), q("Failed %s type: %s", ze, ft.message), Ir(null));
          }
      }
    }
    var Tr = Array.isArray;
    function ei(U) {
      return Tr(U);
    }
    function Rr(U) {
      {
        var ge = typeof Symbol == "function" && Symbol.toStringTag, ze = ge && U[Symbol.toStringTag] || U.constructor.name || "Object";
        return ze;
      }
    }
    function ci(U) {
      try {
        return le(U), !1;
      } catch {
        return !0;
      }
    }
    function le(U) {
      return "" + U;
    }
    function Ce(U) {
      if (ci(U))
        return q("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Rr(U)), le(U);
    }
    var Ge = H.ReactCurrentOwner, gt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, It, $n, Re;
    Re = {};
    function Xe(U) {
      if (nr.call(U, "ref")) {
        var ge = Object.getOwnPropertyDescriptor(U, "ref").get;
        if (ge && ge.isReactWarning)
          return !1;
      }
      return U.ref !== void 0;
    }
    function Ct(U) {
      if (nr.call(U, "key")) {
        var ge = Object.getOwnPropertyDescriptor(U, "key").get;
        if (ge && ge.isReactWarning)
          return !1;
      }
      return U.key !== void 0;
    }
    function qt(U, ge) {
      if (typeof U.ref == "string" && Ge.current && ge && Ge.current.stateNode !== ge) {
        var ze = Pe(Ge.current.type);
        Re[ze] || (q('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Pe(Ge.current.type), U.ref), Re[ze] = !0);
      }
    }
    function At(U, ge) {
      {
        var ze = function() {
          It || (It = !0, q("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ge));
        };
        ze.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: ze,
          configurable: !0
        });
      }
    }
    function Cn(U, ge) {
      {
        var ze = function() {
          $n || ($n = !0, q("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ge));
        };
        ze.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: ze,
          configurable: !0
        });
      }
    }
    var sn = function(U, ge, ze, Ye, Dt, Kt, Lt) {
      var ft = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: U,
        key: ge,
        ref: ze,
        props: Lt,
        // Record the component responsible for creating this element.
        _owner: Kt
      };
      return ft._store = {}, Object.defineProperty(ft._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ft, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ye
      }), Object.defineProperty(ft, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Dt
      }), Object.freeze && (Object.freeze(ft.props), Object.freeze(ft)), ft;
    };
    function ti(U, ge, ze, Ye, Dt) {
      {
        var Kt, Lt = {}, ft = null, vr = null;
        ze !== void 0 && (Ce(ze), ft = "" + ze), Ct(ge) && (Ce(ge.key), ft = "" + ge.key), Xe(ge) && (vr = ge.ref, qt(ge, Dt));
        for (Kt in ge)
          nr.call(ge, Kt) && !gt.hasOwnProperty(Kt) && (Lt[Kt] = ge[Kt]);
        if (U && U.defaultProps) {
          var Mn = U.defaultProps;
          for (Kt in Mn)
            Lt[Kt] === void 0 && (Lt[Kt] = Mn[Kt]);
        }
        if (ft || vr) {
          var Nn = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          ft && At(Lt, Nn), vr && Cn(Lt, Nn);
        }
        return sn(U, ft, vr, Dt, Ye, Ge.current, Lt);
      }
    }
    var wn = H.ReactCurrentOwner, fi = H.ReactDebugCurrentFrame;
    function mn(U) {
      if (U) {
        var ge = U._owner, ze = tr(U.type, U._source, ge ? ge.type : null);
        fi.setExtraStackFrame(ze);
      } else
        fi.setExtraStackFrame(null);
    }
    var vn;
    vn = !1;
    function ja(U) {
      return typeof U == "object" && U !== null && U.$$typeof === n;
    }
    function pa() {
      {
        if (wn.current) {
          var U = Pe(wn.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
    }
    function hl(U) {
      {
        if (U !== void 0) {
          var ge = U.fileName.replace(/^.*[\\\/]/, ""), ze = U.lineNumber;
          return `

Check your code at ` + ge + ":" + ze + ".";
        }
        return "";
      }
    }
    var hs = {};
    function mu(U) {
      {
        var ge = pa();
        if (!ge) {
          var ze = typeof U == "string" ? U : U.displayName || U.name;
          ze && (ge = `

Check the top-level render call using <` + ze + ">.");
        }
        return ge;
      }
    }
    function Oo(U, ge) {
      {
        if (!U._store || U._store.validated || U.key != null)
          return;
        U._store.validated = !0;
        var ze = mu(ge);
        if (hs[ze])
          return;
        hs[ze] = !0;
        var Ye = "";
        U && U._owner && U._owner !== wn.current && (Ye = " It was passed a child from " + Pe(U._owner.type) + "."), mn(U), q('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ze, Ye), mn(null);
      }
    }
    function ml(U, ge) {
      {
        if (typeof U != "object")
          return;
        if (ei(U))
          for (var ze = 0; ze < U.length; ze++) {
            var Ye = U[ze];
            ja(Ye) && Oo(Ye, ge);
          }
        else if (ja(U))
          U._store && (U._store.validated = !0);
        else if (U) {
          var Dt = I(U);
          if (typeof Dt == "function" && Dt !== U.entries)
            for (var Kt = Dt.call(U), Lt; !(Lt = Kt.next()).done; )
              ja(Lt.value) && Oo(Lt.value, ge);
        }
      }
    }
    function Xi(U) {
      {
        var ge = U.type;
        if (ge == null || typeof ge == "string")
          return;
        var ze;
        if (typeof ge == "function")
          ze = ge.propTypes;
        else if (typeof ge == "object" && (ge.$$typeof === b || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ge.$$typeof === w))
          ze = ge.propTypes;
        else
          return;
        if (ze) {
          var Ye = Pe(ge);
          mr(ze, U.props, "prop", Ye, U);
        } else if (ge.PropTypes !== void 0 && !vn) {
          vn = !0;
          var Dt = Pe(ge);
          q("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Dt || "Unknown");
        }
        typeof ge.getDefaultProps == "function" && !ge.getDefaultProps.isReactClassApproved && q("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ro(U) {
      {
        for (var ge = Object.keys(U.props), ze = 0; ze < ge.length; ze++) {
          var Ye = ge[ze];
          if (Ye !== "children" && Ye !== "key") {
            mn(U), q("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ye), mn(null);
            break;
          }
        }
        U.ref !== null && (mn(U), q("Invalid attribute `ref` supplied to `React.Fragment`."), mn(null));
      }
    }
    function Qi(U, ge, ze, Ye, Dt, Kt) {
      {
        var Lt = Le(U);
        if (!Lt) {
          var ft = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (ft += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var vr = hl(Dt);
          vr ? ft += vr : ft += pa();
          var Mn;
          U === null ? Mn = "null" : ei(U) ? Mn = "array" : U !== void 0 && U.$$typeof === n ? (Mn = "<" + (Pe(U.type) || "Unknown") + " />", ft = " Did you accidentally export a JSX literal instead of a component?") : Mn = typeof U, q("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Mn, ft);
        }
        var Nn = ti(U, ge, ze, Dt, Kt);
        if (Nn == null)
          return Nn;
        if (Lt) {
          var Fr = ge.children;
          if (Fr !== void 0)
            if (Ye)
              if (ei(Fr)) {
                for (var oo = 0; oo < Fr.length; oo++)
                  ml(Fr[oo], U);
                Object.freeze && Object.freeze(Fr);
              } else
                q("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ml(Fr, U);
        }
        return U === o ? ro(Nn) : Xi(Nn), Nn;
      }
    }
    function io(U, ge, ze) {
      return Qi(U, ge, ze, !0);
    }
    function di(U, ge, ze) {
      return Qi(U, ge, ze, !1);
    }
    var Ki = di, ao = io;
    kv.Fragment = o, kv.jsx = Ki, kv.jsxs = ao;
  }()), kv;
}
process.env.NODE_ENV === "production" ? K_.exports = p5() : K_.exports = h5();
var oe = K_.exports;
function Wt() {
  return Wt = Object.assign ? Object.assign.bind() : function(t) {
    for (var n = 1; n < arguments.length; n++) {
      var i = arguments[n];
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
    }
    return t;
  }, Wt.apply(this, arguments);
}
var eE = { exports: {} }, Na = {}, ib = { exports: {} }, y_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vR;
function m5() {
  return vR || (vR = 1, function(t) {
    function n(ye, Fe) {
      var O = ye.length;
      ye.push(Fe);
      e:
        for (; 0 < O; ) {
          var ce = O - 1 >>> 1, De = ye[ce];
          if (0 < u(De, Fe))
            ye[ce] = Fe, ye[O] = De, O = ce;
          else
            break e;
        }
    }
    function i(ye) {
      return ye.length === 0 ? null : ye[0];
    }
    function o(ye) {
      if (ye.length === 0)
        return null;
      var Fe = ye[0], O = ye.pop();
      if (O !== Fe) {
        ye[0] = O;
        e:
          for (var ce = 0, De = ye.length, j = De >>> 1; ce < j; ) {
            var rt = 2 * (ce + 1) - 1, Mt = ye[rt], lt = rt + 1, Nt = ye[lt];
            if (0 > u(Mt, O))
              lt < De && 0 > u(Nt, Mt) ? (ye[ce] = Nt, ye[lt] = O, ce = lt) : (ye[ce] = Mt, ye[rt] = O, ce = rt);
            else if (lt < De && 0 > u(Nt, O))
              ye[ce] = Nt, ye[lt] = O, ce = lt;
            else
              break e;
          }
      }
      return Fe;
    }
    function u(ye, Fe) {
      var O = ye.sortIndex - Fe.sortIndex;
      return O !== 0 ? O : ye.id - Fe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var f = performance;
      t.unstable_now = function() {
        return f.now();
      };
    } else {
      var p = Date, v = p.now();
      t.unstable_now = function() {
        return p.now() - v;
      };
    }
    var b = [], S = [], E = 1, w = null, R = 3, k = !1, N = !1, z = !1, I = typeof setTimeout == "function" ? setTimeout : null, H = typeof clearTimeout == "function" ? clearTimeout : null, q = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(ye) {
      for (var Fe = i(S); Fe !== null; ) {
        if (Fe.callback === null)
          o(S);
        else if (Fe.startTime <= ye)
          o(S), Fe.sortIndex = Fe.expirationTime, n(b, Fe);
        else
          break;
        Fe = i(S);
      }
    }
    function te(ye) {
      if (z = !1, G(ye), !N)
        if (i(b) !== null)
          N = !0, at(ee);
        else {
          var Fe = i(S);
          Fe !== null && Te(te, Fe.startTime - ye);
        }
    }
    function ee(ye, Fe) {
      N = !1, z && (z = !1, H(we), we = -1), k = !0;
      var O = R;
      try {
        for (G(Fe), w = i(b); w !== null && (!(w.expirationTime > Fe) || ye && !xe()); ) {
          var ce = w.callback;
          if (typeof ce == "function") {
            w.callback = null, R = w.priorityLevel;
            var De = ce(w.expirationTime <= Fe);
            Fe = t.unstable_now(), typeof De == "function" ? w.callback = De : w === i(b) && o(b), G(Fe);
          } else
            o(b);
          w = i(b);
        }
        if (w !== null)
          var j = !0;
        else {
          var rt = i(S);
          rt !== null && Te(te, rt.startTime - Fe), j = !1;
        }
        return j;
      } finally {
        w = null, R = O, k = !1;
      }
    }
    var V = !1, ue = null, we = -1, me = 5, Le = -1;
    function xe() {
      return !(t.unstable_now() - Le < me);
    }
    function ve() {
      if (ue !== null) {
        var ye = t.unstable_now();
        Le = ye;
        var Fe = !0;
        try {
          Fe = ue(!0, ye);
        } finally {
          Fe ? Pe() : (V = !1, ue = null);
        }
      } else
        V = !1;
    }
    var Pe;
    if (typeof q == "function")
      Pe = function() {
        q(ve);
      };
    else if (typeof MessageChannel < "u") {
      var Ue = new MessageChannel(), We = Ue.port2;
      Ue.port1.onmessage = ve, Pe = function() {
        We.postMessage(null);
      };
    } else
      Pe = function() {
        I(ve, 0);
      };
    function at(ye) {
      ue = ye, V || (V = !0, Pe());
    }
    function Te(ye, Fe) {
      we = I(function() {
        ye(t.unstable_now());
      }, Fe);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(ye) {
      ye.callback = null;
    }, t.unstable_continueExecution = function() {
      N || k || (N = !0, at(ee));
    }, t.unstable_forceFrameRate = function(ye) {
      0 > ye || 125 < ye ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : me = 0 < ye ? Math.floor(1e3 / ye) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return R;
    }, t.unstable_getFirstCallbackNode = function() {
      return i(b);
    }, t.unstable_next = function(ye) {
      switch (R) {
        case 1:
        case 2:
        case 3:
          var Fe = 3;
          break;
        default:
          Fe = R;
      }
      var O = R;
      R = Fe;
      try {
        return ye();
      } finally {
        R = O;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(ye, Fe) {
      switch (ye) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ye = 3;
      }
      var O = R;
      R = ye;
      try {
        return Fe();
      } finally {
        R = O;
      }
    }, t.unstable_scheduleCallback = function(ye, Fe, O) {
      var ce = t.unstable_now();
      switch (typeof O == "object" && O !== null ? (O = O.delay, O = typeof O == "number" && 0 < O ? ce + O : ce) : O = ce, ye) {
        case 1:
          var De = -1;
          break;
        case 2:
          De = 250;
          break;
        case 5:
          De = 1073741823;
          break;
        case 4:
          De = 1e4;
          break;
        default:
          De = 5e3;
      }
      return De = O + De, ye = { id: E++, callback: Fe, priorityLevel: ye, startTime: O, expirationTime: De, sortIndex: -1 }, O > ce ? (ye.sortIndex = O, n(S, ye), i(b) === null && ye === i(S) && (z ? (H(we), we = -1) : z = !0, Te(te, O - ce))) : (ye.sortIndex = De, n(b, ye), N || k || (N = !0, at(ee))), ye;
    }, t.unstable_shouldYield = xe, t.unstable_wrapCallback = function(ye) {
      var Fe = R;
      return function() {
        var O = R;
        R = Fe;
        try {
          return ye.apply(this, arguments);
        } finally {
          R = O;
        }
      };
    };
  }(y_)), y_;
}
var g_ = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yR;
function v5() {
  return yR || (yR = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = !1, i = !1, o = 5;
      function u(Re, Xe) {
        var Ct = Re.length;
        Re.push(Xe), v(Re, Xe, Ct);
      }
      function f(Re) {
        return Re.length === 0 ? null : Re[0];
      }
      function p(Re) {
        if (Re.length === 0)
          return null;
        var Xe = Re[0], Ct = Re.pop();
        return Ct !== Xe && (Re[0] = Ct, b(Re, Ct, 0)), Xe;
      }
      function v(Re, Xe, Ct) {
        for (var qt = Ct; qt > 0; ) {
          var At = qt - 1 >>> 1, Cn = Re[At];
          if (S(Cn, Xe) > 0)
            Re[At] = Xe, Re[qt] = Cn, qt = At;
          else
            return;
        }
      }
      function b(Re, Xe, Ct) {
        for (var qt = Ct, At = Re.length, Cn = At >>> 1; qt < Cn; ) {
          var sn = (qt + 1) * 2 - 1, ti = Re[sn], wn = sn + 1, fi = Re[wn];
          if (S(ti, Xe) < 0)
            wn < At && S(fi, ti) < 0 ? (Re[qt] = fi, Re[wn] = Xe, qt = wn) : (Re[qt] = ti, Re[sn] = Xe, qt = sn);
          else if (wn < At && S(fi, Xe) < 0)
            Re[qt] = fi, Re[wn] = Xe, qt = wn;
          else
            return;
        }
      }
      function S(Re, Xe) {
        var Ct = Re.sortIndex - Xe.sortIndex;
        return Ct !== 0 ? Ct : Re.id - Xe.id;
      }
      var E = 1, w = 2, R = 3, k = 4, N = 5;
      function z(Re, Xe) {
      }
      var I = typeof performance == "object" && typeof performance.now == "function";
      if (I) {
        var H = performance;
        t.unstable_now = function() {
          return H.now();
        };
      } else {
        var q = Date, G = q.now();
        t.unstable_now = function() {
          return q.now() - G;
        };
      }
      var te = 1073741823, ee = -1, V = 250, ue = 5e3, we = 1e4, me = te, Le = [], xe = [], ve = 1, Pe = null, Ue = R, We = !1, at = !1, Te = !1, ye = typeof setTimeout == "function" ? setTimeout : null, Fe = typeof clearTimeout == "function" ? clearTimeout : null, O = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ce(Re) {
        for (var Xe = f(xe); Xe !== null; ) {
          if (Xe.callback === null)
            p(xe);
          else if (Xe.startTime <= Re)
            p(xe), Xe.sortIndex = Xe.expirationTime, u(Le, Xe);
          else
            return;
          Xe = f(xe);
        }
      }
      function De(Re) {
        if (Te = !1, ce(Re), !at)
          if (f(Le) !== null)
            at = !0, Ce(j);
          else {
            var Xe = f(xe);
            Xe !== null && Ge(De, Xe.startTime - Re);
          }
      }
      function j(Re, Xe) {
        at = !1, Te && (Te = !1, gt()), We = !0;
        var Ct = Ue;
        try {
          var qt;
          if (!i)
            return rt(Re, Xe);
        } finally {
          Pe = null, Ue = Ct, We = !1;
        }
      }
      function rt(Re, Xe) {
        var Ct = Xe;
        for (ce(Ct), Pe = f(Le); Pe !== null && !n && !(Pe.expirationTime > Ct && (!Re || Ir())); ) {
          var qt = Pe.callback;
          if (typeof qt == "function") {
            Pe.callback = null, Ue = Pe.priorityLevel;
            var At = Pe.expirationTime <= Ct, Cn = qt(At);
            Ct = t.unstable_now(), typeof Cn == "function" ? Pe.callback = Cn : Pe === f(Le) && p(Le), ce(Ct);
          } else
            p(Le);
          Pe = f(Le);
        }
        if (Pe !== null)
          return !0;
        var sn = f(xe);
        return sn !== null && Ge(De, sn.startTime - Ct), !1;
      }
      function Mt(Re, Xe) {
        switch (Re) {
          case E:
          case w:
          case R:
          case k:
          case N:
            break;
          default:
            Re = R;
        }
        var Ct = Ue;
        Ue = Re;
        try {
          return Xe();
        } finally {
          Ue = Ct;
        }
      }
      function lt(Re) {
        var Xe;
        switch (Ue) {
          case E:
          case w:
          case R:
            Xe = R;
            break;
          default:
            Xe = Ue;
            break;
        }
        var Ct = Ue;
        Ue = Xe;
        try {
          return Re();
        } finally {
          Ue = Ct;
        }
      }
      function Nt(Re) {
        var Xe = Ue;
        return function() {
          var Ct = Ue;
          Ue = Xe;
          try {
            return Re.apply(this, arguments);
          } finally {
            Ue = Ct;
          }
        };
      }
      function xt(Re, Xe, Ct) {
        var qt = t.unstable_now(), At;
        if (typeof Ct == "object" && Ct !== null) {
          var Cn = Ct.delay;
          typeof Cn == "number" && Cn > 0 ? At = qt + Cn : At = qt;
        } else
          At = qt;
        var sn;
        switch (Re) {
          case E:
            sn = ee;
            break;
          case w:
            sn = V;
            break;
          case N:
            sn = me;
            break;
          case k:
            sn = we;
            break;
          case R:
          default:
            sn = ue;
            break;
        }
        var ti = At + sn, wn = {
          id: ve++,
          callback: Xe,
          priorityLevel: Re,
          startTime: At,
          expirationTime: ti,
          sortIndex: -1
        };
        return At > qt ? (wn.sortIndex = At, u(xe, wn), f(Le) === null && wn === f(xe) && (Te ? gt() : Te = !0, Ge(De, At - qt))) : (wn.sortIndex = ti, u(Le, wn), !at && !We && (at = !0, Ce(j))), wn;
      }
      function Zt() {
      }
      function er() {
        !at && !We && (at = !0, Ce(j));
      }
      function hr() {
        return f(Le);
      }
      function Jr(Re) {
        Re.callback = null;
      }
      function zn() {
        return Ue;
      }
      var sr = !1, tr = null, nr = -1, Zn = o, jr = -1;
      function Ir() {
        var Re = t.unstable_now() - jr;
        return !(Re < Zn);
      }
      function mr() {
      }
      function Tr(Re) {
        if (Re < 0 || Re > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Re > 0 ? Zn = Math.floor(1e3 / Re) : Zn = o;
      }
      var ei = function() {
        if (tr !== null) {
          var Re = t.unstable_now();
          jr = Re;
          var Xe = !0, Ct = !0;
          try {
            Ct = tr(Xe, Re);
          } finally {
            Ct ? Rr() : (sr = !1, tr = null);
          }
        } else
          sr = !1;
      }, Rr;
      if (typeof O == "function")
        Rr = function() {
          O(ei);
        };
      else if (typeof MessageChannel < "u") {
        var ci = new MessageChannel(), le = ci.port2;
        ci.port1.onmessage = ei, Rr = function() {
          le.postMessage(null);
        };
      } else
        Rr = function() {
          ye(ei, 0);
        };
      function Ce(Re) {
        tr = Re, sr || (sr = !0, Rr());
      }
      function Ge(Re, Xe) {
        nr = ye(function() {
          Re(t.unstable_now());
        }, Xe);
      }
      function gt() {
        Fe(nr), nr = -1;
      }
      var It = mr, $n = null;
      t.unstable_IdlePriority = N, t.unstable_ImmediatePriority = E, t.unstable_LowPriority = k, t.unstable_NormalPriority = R, t.unstable_Profiling = $n, t.unstable_UserBlockingPriority = w, t.unstable_cancelCallback = Jr, t.unstable_continueExecution = er, t.unstable_forceFrameRate = Tr, t.unstable_getCurrentPriorityLevel = zn, t.unstable_getFirstCallbackNode = hr, t.unstable_next = lt, t.unstable_pauseExecution = Zt, t.unstable_requestPaint = It, t.unstable_runWithPriority = Mt, t.unstable_scheduleCallback = xt, t.unstable_shouldYield = Ir, t.unstable_wrapCallback = Nt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(g_)), g_;
}
var gR;
function S4() {
  return gR || (gR = 1, process.env.NODE_ENV === "production" ? ib.exports = m5() : ib.exports = v5()), ib.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bR;
function y5() {
  if (bR)
    return Na;
  bR = 1;
  var t = L, n = S4();
  function i(a) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 1; d < arguments.length; d++)
      l += "&args[]=" + encodeURIComponent(arguments[d]);
    return "Minified React error #" + a + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var o = /* @__PURE__ */ new Set(), u = {};
  function f(a, l) {
    p(a, l), p(a + "Capture", l);
  }
  function p(a, l) {
    for (u[a] = l, a = 0; a < l.length; a++)
      o.add(l[a]);
  }
  var v = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), b = Object.prototype.hasOwnProperty, S = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, E = {}, w = {};
  function R(a) {
    return b.call(w, a) ? !0 : b.call(E, a) ? !1 : S.test(a) ? w[a] = !0 : (E[a] = !0, !1);
  }
  function k(a, l, d, m) {
    if (d !== null && d.type === 0)
      return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return m ? !1 : d !== null ? !d.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function N(a, l, d, m) {
    if (l === null || typeof l > "u" || k(a, l, d, m))
      return !0;
    if (m)
      return !1;
    if (d !== null)
      switch (d.type) {
        case 3:
          return !l;
        case 4:
          return l === !1;
        case 5:
          return isNaN(l);
        case 6:
          return isNaN(l) || 1 > l;
      }
    return !1;
  }
  function z(a, l, d, m, g, _, D) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = m, this.attributeNamespace = g, this.mustUseProperty = d, this.propertyName = a, this.type = l, this.sanitizeURL = _, this.removeEmptyString = D;
  }
  var I = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    I[a] = new z(a, 0, !1, a, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var l = a[0];
    I[l] = new z(l, 1, !1, a[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    I[a] = new z(a, 2, !1, a.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    I[a] = new z(a, 2, !1, a, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    I[a] = new z(a, 3, !1, a.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    I[a] = new z(a, 3, !0, a, null, !1, !1);
  }), ["capture", "download"].forEach(function(a) {
    I[a] = new z(a, 4, !1, a, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(a) {
    I[a] = new z(a, 6, !1, a, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(a) {
    I[a] = new z(a, 5, !1, a.toLowerCase(), null, !1, !1);
  });
  var H = /[\-:]([a-z])/g;
  function q(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var l = a.replace(
      H,
      q
    );
    I[l] = new z(l, 1, !1, a, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var l = a.replace(H, q);
    I[l] = new z(l, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var l = a.replace(H, q);
    I[l] = new z(l, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(a) {
    I[a] = new z(a, 1, !1, a.toLowerCase(), null, !1, !1);
  }), I.xlinkHref = new z("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(a) {
    I[a] = new z(a, 1, !1, a.toLowerCase(), null, !0, !0);
  });
  function G(a, l, d, m) {
    var g = I.hasOwnProperty(l) ? I[l] : null;
    (g !== null ? g.type !== 0 : m || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (N(l, d, g, m) && (d = null), m || g === null ? R(l) && (d === null ? a.removeAttribute(l) : a.setAttribute(l, "" + d)) : g.mustUseProperty ? a[g.propertyName] = d === null ? g.type === 3 ? !1 : "" : d : (l = g.attributeName, m = g.attributeNamespace, d === null ? a.removeAttribute(l) : (g = g.type, d = g === 3 || g === 4 && d === !0 ? "" : "" + d, m ? a.setAttributeNS(m, l, d) : a.setAttribute(l, d))));
  }
  var te = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ee = Symbol.for("react.element"), V = Symbol.for("react.portal"), ue = Symbol.for("react.fragment"), we = Symbol.for("react.strict_mode"), me = Symbol.for("react.profiler"), Le = Symbol.for("react.provider"), xe = Symbol.for("react.context"), ve = Symbol.for("react.forward_ref"), Pe = Symbol.for("react.suspense"), Ue = Symbol.for("react.suspense_list"), We = Symbol.for("react.memo"), at = Symbol.for("react.lazy"), Te = Symbol.for("react.offscreen"), ye = Symbol.iterator;
  function Fe(a) {
    return a === null || typeof a != "object" ? null : (a = ye && a[ye] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var O = Object.assign, ce;
  function De(a) {
    if (ce === void 0)
      try {
        throw Error();
      } catch (d) {
        var l = d.stack.trim().match(/\n( *(at )?)/);
        ce = l && l[1] || "";
      }
    return `
` + ce + a;
  }
  var j = !1;
  function rt(a, l) {
    if (!a || j)
      return "";
    j = !0;
    var d = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l)
        if (l = function() {
          throw Error();
        }, Object.defineProperty(l.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(l, []);
          } catch (ae) {
            var m = ae;
          }
          Reflect.construct(a, [], l);
        } else {
          try {
            l.call();
          } catch (ae) {
            m = ae;
          }
          a.call(l.prototype);
        }
      else {
        try {
          throw Error();
        } catch (ae) {
          m = ae;
        }
        a();
      }
    } catch (ae) {
      if (ae && m && typeof ae.stack == "string") {
        for (var g = ae.stack.split(`
`), _ = m.stack.split(`
`), D = g.length - 1, $ = _.length - 1; 1 <= D && 0 <= $ && g[D] !== _[$]; )
          $--;
        for (; 1 <= D && 0 <= $; D--, $--)
          if (g[D] !== _[$]) {
            if (D !== 1 || $ !== 1)
              do
                if (D--, $--, 0 > $ || g[D] !== _[$]) {
                  var B = `
` + g[D].replace(" at new ", " at ");
                  return a.displayName && B.includes("<anonymous>") && (B = B.replace("<anonymous>", a.displayName)), B;
                }
              while (1 <= D && 0 <= $);
            break;
          }
      }
    } finally {
      j = !1, Error.prepareStackTrace = d;
    }
    return (a = a ? a.displayName || a.name : "") ? De(a) : "";
  }
  function Mt(a) {
    switch (a.tag) {
      case 5:
        return De(a.type);
      case 16:
        return De("Lazy");
      case 13:
        return De("Suspense");
      case 19:
        return De("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = rt(a.type, !1), a;
      case 11:
        return a = rt(a.type.render, !1), a;
      case 1:
        return a = rt(a.type, !0), a;
      default:
        return "";
    }
  }
  function lt(a) {
    if (a == null)
      return null;
    if (typeof a == "function")
      return a.displayName || a.name || null;
    if (typeof a == "string")
      return a;
    switch (a) {
      case ue:
        return "Fragment";
      case V:
        return "Portal";
      case me:
        return "Profiler";
      case we:
        return "StrictMode";
      case Pe:
        return "Suspense";
      case Ue:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case xe:
          return (a.displayName || "Context") + ".Consumer";
        case Le:
          return (a._context.displayName || "Context") + ".Provider";
        case ve:
          var l = a.render;
          return a = a.displayName, a || (a = l.displayName || l.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case We:
          return l = a.displayName || null, l !== null ? l : lt(a.type) || "Memo";
        case at:
          l = a._payload, a = a._init;
          try {
            return lt(a(l));
          } catch {
          }
      }
    return null;
  }
  function Nt(a) {
    var l = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = l.render, a = a.displayName || a.name || "", l.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return lt(l);
      case 8:
        return l === we ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function")
          return l.displayName || l.name || null;
        if (typeof l == "string")
          return l;
    }
    return null;
  }
  function xt(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Zt(a) {
    var l = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function er(a) {
    var l = Zt(a) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(a.constructor.prototype, l), m = "" + a[l];
    if (!a.hasOwnProperty(l) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
      var g = d.get, _ = d.set;
      return Object.defineProperty(a, l, { configurable: !0, get: function() {
        return g.call(this);
      }, set: function(D) {
        m = "" + D, _.call(this, D);
      } }), Object.defineProperty(a, l, { enumerable: d.enumerable }), { getValue: function() {
        return m;
      }, setValue: function(D) {
        m = "" + D;
      }, stopTracking: function() {
        a._valueTracker = null, delete a[l];
      } };
    }
  }
  function hr(a) {
    a._valueTracker || (a._valueTracker = er(a));
  }
  function Jr(a) {
    if (!a)
      return !1;
    var l = a._valueTracker;
    if (!l)
      return !0;
    var d = l.getValue(), m = "";
    return a && (m = Zt(a) ? a.checked ? "true" : "false" : a.value), a = m, a !== d ? (l.setValue(a), !0) : !1;
  }
  function zn(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function sr(a, l) {
    var d = l.checked;
    return O({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: d ?? a._wrapperState.initialChecked });
  }
  function tr(a, l) {
    var d = l.defaultValue == null ? "" : l.defaultValue, m = l.checked != null ? l.checked : l.defaultChecked;
    d = xt(l.value != null ? l.value : d), a._wrapperState = { initialChecked: m, initialValue: d, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function nr(a, l) {
    l = l.checked, l != null && G(a, "checked", l, !1);
  }
  function Zn(a, l) {
    nr(a, l);
    var d = xt(l.value), m = l.type;
    if (d != null)
      m === "number" ? (d === 0 && a.value === "" || a.value != d) && (a.value = "" + d) : a.value !== "" + d && (a.value = "" + d);
    else if (m === "submit" || m === "reset") {
      a.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? Ir(a, l.type, d) : l.hasOwnProperty("defaultValue") && Ir(a, l.type, xt(l.defaultValue)), l.checked == null && l.defaultChecked != null && (a.defaultChecked = !!l.defaultChecked);
  }
  function jr(a, l, d) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var m = l.type;
      if (!(m !== "submit" && m !== "reset" || l.value !== void 0 && l.value !== null))
        return;
      l = "" + a._wrapperState.initialValue, d || l === a.value || (a.value = l), a.defaultValue = l;
    }
    d = a.name, d !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, d !== "" && (a.name = d);
  }
  function Ir(a, l, d) {
    (l !== "number" || zn(a.ownerDocument) !== a) && (d == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + d && (a.defaultValue = "" + d));
  }
  var mr = Array.isArray;
  function Tr(a, l, d, m) {
    if (a = a.options, l) {
      l = {};
      for (var g = 0; g < d.length; g++)
        l["$" + d[g]] = !0;
      for (d = 0; d < a.length; d++)
        g = l.hasOwnProperty("$" + a[d].value), a[d].selected !== g && (a[d].selected = g), g && m && (a[d].defaultSelected = !0);
    } else {
      for (d = "" + xt(d), l = null, g = 0; g < a.length; g++) {
        if (a[g].value === d) {
          a[g].selected = !0, m && (a[g].defaultSelected = !0);
          return;
        }
        l !== null || a[g].disabled || (l = a[g]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function ei(a, l) {
    if (l.dangerouslySetInnerHTML != null)
      throw Error(i(91));
    return O({}, l, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function Rr(a, l) {
    var d = l.value;
    if (d == null) {
      if (d = l.children, l = l.defaultValue, d != null) {
        if (l != null)
          throw Error(i(92));
        if (mr(d)) {
          if (1 < d.length)
            throw Error(i(93));
          d = d[0];
        }
        l = d;
      }
      l == null && (l = ""), d = l;
    }
    a._wrapperState = { initialValue: xt(d) };
  }
  function ci(a, l) {
    var d = xt(l.value), m = xt(l.defaultValue);
    d != null && (d = "" + d, d !== a.value && (a.value = d), l.defaultValue == null && a.defaultValue !== d && (a.defaultValue = d)), m != null && (a.defaultValue = "" + m);
  }
  function le(a) {
    var l = a.textContent;
    l === a._wrapperState.initialValue && l !== "" && l !== null && (a.value = l);
  }
  function Ce(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ge(a, l) {
    return a == null || a === "http://www.w3.org/1999/xhtml" ? Ce(l) : a === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
  }
  var gt, It = function(a) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, d, m, g) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(l, d, m, g);
      });
    } : a;
  }(function(a, l) {
    if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
      a.innerHTML = l;
    else {
      for (gt = gt || document.createElement("div"), gt.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = gt.firstChild; a.firstChild; )
        a.removeChild(a.firstChild);
      for (; l.firstChild; )
        a.appendChild(l.firstChild);
    }
  });
  function $n(a, l) {
    if (l) {
      var d = a.firstChild;
      if (d && d === a.lastChild && d.nodeType === 3) {
        d.nodeValue = l;
        return;
      }
    }
    a.textContent = l;
  }
  var Re = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Xe = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Re).forEach(function(a) {
    Xe.forEach(function(l) {
      l = l + a.charAt(0).toUpperCase() + a.substring(1), Re[l] = Re[a];
    });
  });
  function Ct(a, l, d) {
    return l == null || typeof l == "boolean" || l === "" ? "" : d || typeof l != "number" || l === 0 || Re.hasOwnProperty(a) && Re[a] ? ("" + l).trim() : l + "px";
  }
  function qt(a, l) {
    a = a.style;
    for (var d in l)
      if (l.hasOwnProperty(d)) {
        var m = d.indexOf("--") === 0, g = Ct(d, l[d], m);
        d === "float" && (d = "cssFloat"), m ? a.setProperty(d, g) : a[d] = g;
      }
  }
  var At = O({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Cn(a, l) {
    if (l) {
      if (At[a] && (l.children != null || l.dangerouslySetInnerHTML != null))
        throw Error(i(137, a));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null)
          throw Error(i(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML))
          throw Error(i(61));
      }
      if (l.style != null && typeof l.style != "object")
        throw Error(i(62));
    }
  }
  function sn(a, l) {
    if (a.indexOf("-") === -1)
      return typeof l.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ti = null;
  function wn(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var fi = null, mn = null, vn = null;
  function ja(a) {
    if (a = Qc(a)) {
      if (typeof fi != "function")
        throw Error(i(280));
      var l = a.stateNode;
      l && (l = ct(l), fi(a.stateNode, a.type, l));
    }
  }
  function pa(a) {
    mn ? vn ? vn.push(a) : vn = [a] : mn = a;
  }
  function hl() {
    if (mn) {
      var a = mn, l = vn;
      if (vn = mn = null, ja(a), l)
        for (a = 0; a < l.length; a++)
          ja(l[a]);
    }
  }
  function hs(a, l) {
    return a(l);
  }
  function mu() {
  }
  var Oo = !1;
  function ml(a, l, d) {
    if (Oo)
      return a(l, d);
    Oo = !0;
    try {
      return hs(a, l, d);
    } finally {
      Oo = !1, (mn !== null || vn !== null) && (mu(), hl());
    }
  }
  function Xi(a, l) {
    var d = a.stateNode;
    if (d === null)
      return null;
    var m = ct(d);
    if (m === null)
      return null;
    d = m[l];
    e:
      switch (l) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (m = !m.disabled) || (a = a.type, m = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !m;
          break e;
        default:
          a = !1;
      }
    if (a)
      return null;
    if (d && typeof d != "function")
      throw Error(i(231, l, typeof d));
    return d;
  }
  var ro = !1;
  if (v)
    try {
      var Qi = {};
      Object.defineProperty(Qi, "passive", { get: function() {
        ro = !0;
      } }), window.addEventListener("test", Qi, Qi), window.removeEventListener("test", Qi, Qi);
    } catch {
      ro = !1;
    }
  function io(a, l, d, m, g, _, D, $, B) {
    var ae = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(d, ae);
    } catch (Se) {
      this.onError(Se);
    }
  }
  var di = !1, Ki = null, ao = !1, U = null, ge = { onError: function(a) {
    di = !0, Ki = a;
  } };
  function ze(a, l, d, m, g, _, D, $, B) {
    di = !1, Ki = null, io.apply(ge, arguments);
  }
  function Ye(a, l, d, m, g, _, D, $, B) {
    if (ze.apply(this, arguments), di) {
      if (di) {
        var ae = Ki;
        di = !1, Ki = null;
      } else
        throw Error(i(198));
      ao || (ao = !0, U = ae);
    }
  }
  function Dt(a) {
    var l = a, d = a;
    if (a.alternate)
      for (; l.return; )
        l = l.return;
    else {
      a = l;
      do
        l = a, l.flags & 4098 && (d = l.return), a = l.return;
      while (a);
    }
    return l.tag === 3 ? d : null;
  }
  function Kt(a) {
    if (a.tag === 13) {
      var l = a.memoizedState;
      if (l === null && (a = a.alternate, a !== null && (l = a.memoizedState)), l !== null)
        return l.dehydrated;
    }
    return null;
  }
  function Lt(a) {
    if (Dt(a) !== a)
      throw Error(i(188));
  }
  function ft(a) {
    var l = a.alternate;
    if (!l) {
      if (l = Dt(a), l === null)
        throw Error(i(188));
      return l !== a ? null : a;
    }
    for (var d = a, m = l; ; ) {
      var g = d.return;
      if (g === null)
        break;
      var _ = g.alternate;
      if (_ === null) {
        if (m = g.return, m !== null) {
          d = m;
          continue;
        }
        break;
      }
      if (g.child === _.child) {
        for (_ = g.child; _; ) {
          if (_ === d)
            return Lt(g), a;
          if (_ === m)
            return Lt(g), l;
          _ = _.sibling;
        }
        throw Error(i(188));
      }
      if (d.return !== m.return)
        d = g, m = _;
      else {
        for (var D = !1, $ = g.child; $; ) {
          if ($ === d) {
            D = !0, d = g, m = _;
            break;
          }
          if ($ === m) {
            D = !0, m = g, d = _;
            break;
          }
          $ = $.sibling;
        }
        if (!D) {
          for ($ = _.child; $; ) {
            if ($ === d) {
              D = !0, d = _, m = g;
              break;
            }
            if ($ === m) {
              D = !0, m = _, d = g;
              break;
            }
            $ = $.sibling;
          }
          if (!D)
            throw Error(i(189));
        }
      }
      if (d.alternate !== m)
        throw Error(i(190));
    }
    if (d.tag !== 3)
      throw Error(i(188));
    return d.stateNode.current === d ? a : l;
  }
  function vr(a) {
    return a = ft(a), a !== null ? Mn(a) : null;
  }
  function Mn(a) {
    if (a.tag === 5 || a.tag === 6)
      return a;
    for (a = a.child; a !== null; ) {
      var l = Mn(a);
      if (l !== null)
        return l;
      a = a.sibling;
    }
    return null;
  }
  var Nn = n.unstable_scheduleCallback, Fr = n.unstable_cancelCallback, oo = n.unstable_shouldYield, vu = n.unstable_requestPaint, an = n.unstable_now, vh = n.unstable_getCurrentPriorityLevel, Ia = n.unstable_ImmediatePriority, Ft = n.unstable_UserBlockingPriority, lo = n.unstable_NormalPriority, vl = n.unstable_LowPriority, yu = n.unstable_IdlePriority, yl = null, Ri = null;
  function Lc(a) {
    if (Ri && typeof Ri.onCommitFiberRoot == "function")
      try {
        Ri.onCommitFiberRoot(yl, a, void 0, (a.current.flags & 128) === 128);
      } catch {
      }
  }
  var pi = Math.clz32 ? Math.clz32 : Jf, Pc = Math.log, zc = Math.LN2;
  function Jf(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (Pc(a) / zc | 0) | 0;
  }
  var gu = 64, gl = 4194304;
  function Fa(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function hi(a, l) {
    var d = a.pendingLanes;
    if (d === 0)
      return 0;
    var m = 0, g = a.suspendedLanes, _ = a.pingedLanes, D = d & 268435455;
    if (D !== 0) {
      var $ = D & ~g;
      $ !== 0 ? m = Fa($) : (_ &= D, _ !== 0 && (m = Fa(_)));
    } else
      D = d & ~g, D !== 0 ? m = Fa(D) : _ !== 0 && (m = Fa(_));
    if (m === 0)
      return 0;
    if (l !== 0 && l !== m && !(l & g) && (g = m & -m, _ = l & -l, g >= _ || g === 16 && (_ & 4194240) !== 0))
      return l;
    if (m & 4 && (m |= d & 16), l = a.entangledLanes, l !== 0)
      for (a = a.entanglements, l &= m; 0 < l; )
        d = 31 - pi(l), g = 1 << d, m |= a[d], l &= ~g;
    return m;
  }
  function bl(a, l) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Sl(a, l) {
    for (var d = a.suspendedLanes, m = a.pingedLanes, g = a.expirationTimes, _ = a.pendingLanes; 0 < _; ) {
      var D = 31 - pi(_), $ = 1 << D, B = g[D];
      B === -1 ? (!($ & d) || $ & m) && (g[D] = bl($, l)) : B <= l && (a.expiredLanes |= $), _ &= ~$;
    }
  }
  function xl(a) {
    return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function bu() {
    var a = gu;
    return gu <<= 1, !(gu & 4194240) && (gu = 64), a;
  }
  function Su(a) {
    for (var l = [], d = 0; 31 > d; d++)
      l.push(a);
    return l;
  }
  function Ao(a, l, d) {
    a.pendingLanes |= l, l !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, l = 31 - pi(l), a[l] = d;
  }
  function yh(a, l) {
    var d = a.pendingLanes & ~l;
    a.pendingLanes = l, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= l, a.mutableReadLanes &= l, a.entangledLanes &= l, l = a.entanglements;
    var m = a.eventTimes;
    for (a = a.expirationTimes; 0 < d; ) {
      var g = 31 - pi(d), _ = 1 << g;
      l[g] = 0, m[g] = -1, a[g] = -1, d &= ~_;
    }
  }
  function so(a, l) {
    var d = a.entangledLanes |= l;
    for (a = a.entanglements; d; ) {
      var m = 31 - pi(d), g = 1 << m;
      g & l | a[m] & l && (a[m] |= l), d &= ~g;
    }
  }
  var cn = 0;
  function xu(a) {
    return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var ms, wu, on, _u, Eu, kt = !1, vs = [], qn = null, Oi = null, mi = null, wl = /* @__PURE__ */ new Map(), rr = /* @__PURE__ */ new Map(), yn = [], ed = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ai(a, l) {
    switch (a) {
      case "focusin":
      case "focusout":
        qn = null;
        break;
      case "dragenter":
      case "dragleave":
        Oi = null;
        break;
      case "mouseover":
      case "mouseout":
        mi = null;
        break;
      case "pointerover":
      case "pointerout":
        wl.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        rr.delete(l.pointerId);
    }
  }
  function Or(a, l, d, m, g, _) {
    return a === null || a.nativeEvent !== _ ? (a = { blockedOn: l, domEventName: d, eventSystemFlags: m, nativeEvent: _, targetContainers: [g] }, l !== null && (l = Qc(l), l !== null && wu(l)), a) : (a.eventSystemFlags |= m, l = a.targetContainers, g !== null && l.indexOf(g) === -1 && l.push(g), a);
  }
  function uo(a, l, d, m, g) {
    switch (l) {
      case "focusin":
        return qn = Or(qn, a, l, d, m, g), !0;
      case "dragenter":
        return Oi = Or(Oi, a, l, d, m, g), !0;
      case "mouseover":
        return mi = Or(mi, a, l, d, m, g), !0;
      case "pointerover":
        var _ = g.pointerId;
        return wl.set(_, Or(wl.get(_) || null, a, l, d, m, g)), !0;
      case "gotpointercapture":
        return _ = g.pointerId, rr.set(_, Or(rr.get(_) || null, a, l, d, m, g)), !0;
    }
    return !1;
  }
  function td(a) {
    var l = ya(a.target);
    if (l !== null) {
      var d = Dt(l);
      if (d !== null) {
        if (l = d.tag, l === 13) {
          if (l = Kt(d), l !== null) {
            a.blockedOn = l, Eu(a.priority, function() {
              on(d);
            });
            return;
          }
        } else if (l === 3 && d.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Do(a) {
    if (a.blockedOn !== null)
      return !1;
    for (var l = a.targetContainers; 0 < l.length; ) {
      var d = ku(a.domEventName, a.eventSystemFlags, l[0], a.nativeEvent);
      if (d === null) {
        d = a.nativeEvent;
        var m = new d.constructor(d.type, d);
        ti = m, d.target.dispatchEvent(m), ti = null;
      } else
        return l = Qc(d), l !== null && wu(l), a.blockedOn = d, !1;
      l.shift();
    }
    return !0;
  }
  function _l(a, l, d) {
    Do(a) && d.delete(l);
  }
  function nd() {
    kt = !1, qn !== null && Do(qn) && (qn = null), Oi !== null && Do(Oi) && (Oi = null), mi !== null && Do(mi) && (mi = null), wl.forEach(_l), rr.forEach(_l);
  }
  function ha(a, l) {
    a.blockedOn === l && (a.blockedOn = null, kt || (kt = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, nd)));
  }
  function El(a) {
    function l(g) {
      return ha(g, a);
    }
    if (0 < vs.length) {
      ha(vs[0], a);
      for (var d = 1; d < vs.length; d++) {
        var m = vs[d];
        m.blockedOn === a && (m.blockedOn = null);
      }
    }
    for (qn !== null && ha(qn, a), Oi !== null && ha(Oi, a), mi !== null && ha(mi, a), wl.forEach(l), rr.forEach(l), d = 0; d < yn.length; d++)
      m = yn[d], m.blockedOn === a && (m.blockedOn = null);
    for (; 0 < yn.length && (d = yn[0], d.blockedOn === null); )
      td(d), d.blockedOn === null && yn.shift();
  }
  var Cl = te.ReactCurrentBatchConfig, ma = !0;
  function Cu(a, l, d, m) {
    var g = cn, _ = Cl.transition;
    Cl.transition = null;
    try {
      cn = 1, Tl(a, l, d, m);
    } finally {
      cn = g, Cl.transition = _;
    }
  }
  function kl(a, l, d, m) {
    var g = cn, _ = Cl.transition;
    Cl.transition = null;
    try {
      cn = 4, Tl(a, l, d, m);
    } finally {
      cn = g, Cl.transition = _;
    }
  }
  function Tl(a, l, d, m) {
    if (ma) {
      var g = ku(a, l, d, m);
      if (g === null)
        fd(a, l, m, ys, d), Ai(a, m);
      else if (uo(g, a, l, d, m))
        m.stopPropagation();
      else if (Ai(a, m), l & 4 && -1 < ed.indexOf(a)) {
        for (; g !== null; ) {
          var _ = Qc(g);
          if (_ !== null && ms(_), _ = ku(a, l, d, m), _ === null && fd(a, l, m, ys, d), _ === g)
            break;
          g = _;
        }
        g !== null && m.stopPropagation();
      } else
        fd(a, l, m, null, d);
    }
  }
  var ys = null;
  function ku(a, l, d, m) {
    if (ys = null, a = wn(m), a = ya(a), a !== null)
      if (l = Dt(a), l === null)
        a = null;
      else if (d = l.tag, d === 13) {
        if (a = Kt(l), a !== null)
          return a;
        a = null;
      } else if (d === 3) {
        if (l.stateNode.current.memoizedState.isDehydrated)
          return l.tag === 3 ? l.stateNode.containerInfo : null;
        a = null;
      } else
        l !== a && (a = null);
    return ys = a, null;
  }
  function $c(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (vh()) {
          case Ia:
            return 1;
          case Ft:
            return 4;
          case lo:
          case vl:
            return 16;
          case yu:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ua = null, A = null, F = null;
  function re() {
    if (F)
      return F;
    var a, l = A, d = l.length, m, g = "value" in Ua ? Ua.value : Ua.textContent, _ = g.length;
    for (a = 0; a < d && l[a] === g[a]; a++)
      ;
    var D = d - a;
    for (m = 1; m <= D && l[d - m] === g[_ - m]; m++)
      ;
    return F = g.slice(a, 1 < m ? 1 - m : void 0);
  }
  function se(a) {
    var l = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && l === 13 && (a = 13)) : a = l, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function ke() {
    return !0;
  }
  function mt() {
    return !1;
  }
  function Ie(a) {
    function l(d, m, g, _, D) {
      this._reactName = d, this._targetInst = g, this.type = m, this.nativeEvent = _, this.target = D, this.currentTarget = null;
      for (var $ in a)
        a.hasOwnProperty($) && (d = a[$], this[$] = d ? d(_) : _[$]);
      return this.isDefaultPrevented = (_.defaultPrevented != null ? _.defaultPrevented : _.returnValue === !1) ? ke : mt, this.isPropagationStopped = mt, this;
    }
    return O(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var d = this.nativeEvent;
      d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = ke);
    }, stopPropagation: function() {
      var d = this.nativeEvent;
      d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = ke);
    }, persist: function() {
    }, isPersistent: ke }), l;
  }
  var pt = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Ut = Ie(pt), ln = O({}, pt, { view: 0, detail: 0 }), Rn = Ie(ln), _n, On, Ln, Qt = O({}, ln, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: wh, button: 0, buttons: 0, relatedTarget: function(a) {
    return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    return "movementX" in a ? a.movementX : (a !== Ln && (Ln && a.type === "mousemove" ? (_n = a.screenX - Ln.screenX, On = a.screenY - Ln.screenY) : On = _n = 0, Ln = a), _n);
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : On;
  } }), Mo = Ie(Qt), Tu = O({}, Qt, { dataTransfer: 0 }), jc = Ie(Tu), gh = O({}, ln, { relatedTarget: 0 }), Ba = Ie(gh), Ic = O({}, pt, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Fc = Ie(Ic), bh = O({}, pt, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), YS = Ie(bh), ZS = O({}, pt, { data: 0 }), Sh = Ie(ZS), xh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, by = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Sy = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function xy(a) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(a) : (a = Sy[a]) ? !!l[a] : !1;
  }
  function wh() {
    return xy;
  }
  var No = O({}, ln, { key: function(a) {
    if (a.key) {
      var l = xh[a.key] || a.key;
      if (l !== "Unidentified")
        return l;
    }
    return a.type === "keypress" ? (a = se(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? by[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: wh, charCode: function(a) {
    return a.type === "keypress" ? se(a) : 0;
  }, keyCode: function(a) {
    return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  }, which: function(a) {
    return a.type === "keypress" ? se(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  } }), qS = Ie(No), _h = O({}, Qt, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), rd = Ie(_h), Eh = O({}, ln, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: wh }), GS = Ie(Eh), id = O({}, pt, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), wy = Ie(id), Di = O({}, Qt, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Lo = Ie(Di), yr = [9, 13, 27, 32], Ha = v && "CompositionEvent" in window, gs = null;
  v && "documentMode" in document && (gs = document.documentMode);
  var ad = v && "TextEvent" in window && !gs, _y = v && (!Ha || gs && 8 < gs && 11 >= gs), Ru = " ", Ey = !1;
  function Cy(a, l) {
    switch (a) {
      case "keyup":
        return yr.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function od(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var Ou = !1;
  function XS(a, l) {
    switch (a) {
      case "compositionend":
        return od(l);
      case "keypress":
        return l.which !== 32 ? null : (Ey = !0, Ru);
      case "textInput":
        return a = l.data, a === Ru && Ey ? null : a;
      default:
        return null;
    }
  }
  function QS(a, l) {
    if (Ou)
      return a === "compositionend" || !Ha && Cy(a, l) ? (a = re(), F = A = Ua = null, Ou = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which)
            return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return _y && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var ky = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Ty(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l === "input" ? !!ky[a.type] : l === "textarea";
  }
  function Ry(a, l, d, m) {
    pa(m), l = qc(l, "onChange"), 0 < l.length && (d = new Ut("onChange", "change", null, d, m), a.push({ event: d, listeners: l }));
  }
  var Uc = null, Au = null;
  function Du(a) {
    cd(a, 0);
  }
  function Mu(a) {
    var l = Lu(a);
    if (Jr(l))
      return a;
  }
  function Oy(a, l) {
    if (a === "change")
      return l;
  }
  var Ch = !1;
  if (v) {
    var kh;
    if (v) {
      var Th = "oninput" in document;
      if (!Th) {
        var Ay = document.createElement("div");
        Ay.setAttribute("oninput", "return;"), Th = typeof Ay.oninput == "function";
      }
      kh = Th;
    } else
      kh = !1;
    Ch = kh && (!document.documentMode || 9 < document.documentMode);
  }
  function Dy() {
    Uc && (Uc.detachEvent("onpropertychange", My), Au = Uc = null);
  }
  function My(a) {
    if (a.propertyName === "value" && Mu(Au)) {
      var l = [];
      Ry(l, Au, a, wn(a)), ml(Du, l);
    }
  }
  function KS(a, l, d) {
    a === "focusin" ? (Dy(), Uc = l, Au = d, Uc.attachEvent("onpropertychange", My)) : a === "focusout" && Dy();
  }
  function JS(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Mu(Au);
  }
  function e1(a, l) {
    if (a === "click")
      return Mu(l);
  }
  function Ny(a, l) {
    if (a === "input" || a === "change")
      return Mu(l);
  }
  function t1(a, l) {
    return a === l && (a !== 0 || 1 / a === 1 / l) || a !== a && l !== l;
  }
  var va = typeof Object.is == "function" ? Object.is : t1;
  function Bc(a, l) {
    if (va(a, l))
      return !0;
    if (typeof a != "object" || a === null || typeof l != "object" || l === null)
      return !1;
    var d = Object.keys(a), m = Object.keys(l);
    if (d.length !== m.length)
      return !1;
    for (m = 0; m < d.length; m++) {
      var g = d[m];
      if (!b.call(l, g) || !va(a[g], l[g]))
        return !1;
    }
    return !0;
  }
  function Ly(a) {
    for (; a && a.firstChild; )
      a = a.firstChild;
    return a;
  }
  function Py(a, l) {
    var d = Ly(a);
    a = 0;
    for (var m; d; ) {
      if (d.nodeType === 3) {
        if (m = a + d.textContent.length, a <= l && m >= l)
          return { node: d, offset: l - a };
        a = m;
      }
      e: {
        for (; d; ) {
          if (d.nextSibling) {
            d = d.nextSibling;
            break e;
          }
          d = d.parentNode;
        }
        d = void 0;
      }
      d = Ly(d);
    }
  }
  function zy(a, l) {
    return a && l ? a === l ? !0 : a && a.nodeType === 3 ? !1 : l && l.nodeType === 3 ? zy(a, l.parentNode) : "contains" in a ? a.contains(l) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function ld() {
    for (var a = window, l = zn(); l instanceof a.HTMLIFrameElement; ) {
      try {
        var d = typeof l.contentWindow.location.href == "string";
      } catch {
        d = !1;
      }
      if (d)
        a = l.contentWindow;
      else
        break;
      l = zn(a.document);
    }
    return l;
  }
  function Po(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l && (l === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || l === "textarea" || a.contentEditable === "true");
  }
  function sd(a) {
    var l = ld(), d = a.focusedElem, m = a.selectionRange;
    if (l !== d && d && d.ownerDocument && zy(d.ownerDocument.documentElement, d)) {
      if (m !== null && Po(d)) {
        if (l = m.start, a = m.end, a === void 0 && (a = l), "selectionStart" in d)
          d.selectionStart = l, d.selectionEnd = Math.min(a, d.value.length);
        else if (a = (l = d.ownerDocument || document) && l.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var g = d.textContent.length, _ = Math.min(m.start, g);
          m = m.end === void 0 ? _ : Math.min(m.end, g), !a.extend && _ > m && (g = m, m = _, _ = g), g = Py(d, _);
          var D = Py(
            d,
            m
          );
          g && D && (a.rangeCount !== 1 || a.anchorNode !== g.node || a.anchorOffset !== g.offset || a.focusNode !== D.node || a.focusOffset !== D.offset) && (l = l.createRange(), l.setStart(g.node, g.offset), a.removeAllRanges(), _ > m ? (a.addRange(l), a.extend(D.node, D.offset)) : (l.setEnd(D.node, D.offset), a.addRange(l)));
        }
      }
      for (l = [], a = d; a = a.parentNode; )
        a.nodeType === 1 && l.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof d.focus == "function" && d.focus(), d = 0; d < l.length; d++)
        a = l[d], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var $y = v && "documentMode" in document && 11 >= document.documentMode, Va = null, Rh = null, Hc = null, Oh = !1;
  function jy(a, l, d) {
    var m = d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
    Oh || Va == null || Va !== zn(m) || (m = Va, "selectionStart" in m && Po(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = { anchorNode: m.anchorNode, anchorOffset: m.anchorOffset, focusNode: m.focusNode, focusOffset: m.focusOffset }), Hc && Bc(Hc, m) || (Hc = m, m = qc(Rh, "onSelect"), 0 < m.length && (l = new Ut("onSelect", "select", null, l, d), a.push({ event: l, listeners: m }), l.target = Va)));
  }
  function ud(a, l) {
    var d = {};
    return d[a.toLowerCase()] = l.toLowerCase(), d["Webkit" + a] = "webkit" + l, d["Moz" + a] = "moz" + l, d;
  }
  var bs = { animationend: ud("Animation", "AnimationEnd"), animationiteration: ud("Animation", "AnimationIteration"), animationstart: ud("Animation", "AnimationStart"), transitionend: ud("Transition", "TransitionEnd") }, Ah = {}, Dh = {};
  v && (Dh = document.createElement("div").style, "AnimationEvent" in window || (delete bs.animationend.animation, delete bs.animationiteration.animation, delete bs.animationstart.animation), "TransitionEvent" in window || delete bs.transitionend.transition);
  function Ar(a) {
    if (Ah[a])
      return Ah[a];
    if (!bs[a])
      return a;
    var l = bs[a], d;
    for (d in l)
      if (l.hasOwnProperty(d) && d in Dh)
        return Ah[a] = l[d];
    return a;
  }
  var Mh = Ar("animationend"), Iy = Ar("animationiteration"), Fy = Ar("animationstart"), Uy = Ar("transitionend"), By = /* @__PURE__ */ new Map(), Hy = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function zo(a, l) {
    By.set(a, l), f(l, [a]);
  }
  for (var Vc = 0; Vc < Hy.length; Vc++) {
    var Ss = Hy[Vc], n1 = Ss.toLowerCase(), Wc = Ss[0].toUpperCase() + Ss.slice(1);
    zo(n1, "on" + Wc);
  }
  zo(Mh, "onAnimationEnd"), zo(Iy, "onAnimationIteration"), zo(Fy, "onAnimationStart"), zo("dblclick", "onDoubleClick"), zo("focusin", "onFocus"), zo("focusout", "onBlur"), zo(Uy, "onTransitionEnd"), p("onMouseEnter", ["mouseout", "mouseover"]), p("onMouseLeave", ["mouseout", "mouseover"]), p("onPointerEnter", ["pointerout", "pointerover"]), p("onPointerLeave", ["pointerout", "pointerover"]), f("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), f("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), f("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), f("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Yc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), r1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Yc));
  function Vy(a, l, d) {
    var m = a.type || "unknown-event";
    a.currentTarget = d, Ye(m, l, void 0, a), a.currentTarget = null;
  }
  function cd(a, l) {
    l = (l & 4) !== 0;
    for (var d = 0; d < a.length; d++) {
      var m = a[d], g = m.event;
      m = m.listeners;
      e: {
        var _ = void 0;
        if (l)
          for (var D = m.length - 1; 0 <= D; D--) {
            var $ = m[D], B = $.instance, ae = $.currentTarget;
            if ($ = $.listener, B !== _ && g.isPropagationStopped())
              break e;
            Vy(g, $, ae), _ = B;
          }
        else
          for (D = 0; D < m.length; D++) {
            if ($ = m[D], B = $.instance, ae = $.currentTarget, $ = $.listener, B !== _ && g.isPropagationStopped())
              break e;
            Vy(g, $, ae), _ = B;
          }
      }
    }
    if (ao)
      throw a = U, ao = !1, U = null, a;
  }
  function An(a, l) {
    var d = l[Ih];
    d === void 0 && (d = l[Ih] = /* @__PURE__ */ new Set());
    var m = a + "__bubble";
    d.has(m) || (Wy(l, a, 2, !1), d.add(m));
  }
  function Rl(a, l, d) {
    var m = 0;
    l && (m |= 4), Wy(d, a, m, l);
  }
  var $o = "_reactListening" + Math.random().toString(36).slice(2);
  function Nu(a) {
    if (!a[$o]) {
      a[$o] = !0, o.forEach(function(d) {
        d !== "selectionchange" && (r1.has(d) || Rl(d, !1, a), Rl(d, !0, a));
      });
      var l = a.nodeType === 9 ? a : a.ownerDocument;
      l === null || l[$o] || (l[$o] = !0, Rl("selectionchange", !1, l));
    }
  }
  function Wy(a, l, d, m) {
    switch ($c(l)) {
      case 1:
        var g = Cu;
        break;
      case 4:
        g = kl;
        break;
      default:
        g = Tl;
    }
    d = g.bind(null, l, d, a), g = void 0, !ro || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (g = !0), m ? g !== void 0 ? a.addEventListener(l, d, { capture: !0, passive: g }) : a.addEventListener(l, d, !0) : g !== void 0 ? a.addEventListener(l, d, { passive: g }) : a.addEventListener(l, d, !1);
  }
  function fd(a, l, d, m, g) {
    var _ = m;
    if (!(l & 1) && !(l & 2) && m !== null)
      e:
        for (; ; ) {
          if (m === null)
            return;
          var D = m.tag;
          if (D === 3 || D === 4) {
            var $ = m.stateNode.containerInfo;
            if ($ === g || $.nodeType === 8 && $.parentNode === g)
              break;
            if (D === 4)
              for (D = m.return; D !== null; ) {
                var B = D.tag;
                if ((B === 3 || B === 4) && (B = D.stateNode.containerInfo, B === g || B.nodeType === 8 && B.parentNode === g))
                  return;
                D = D.return;
              }
            for (; $ !== null; ) {
              if (D = ya($), D === null)
                return;
              if (B = D.tag, B === 5 || B === 6) {
                m = _ = D;
                continue e;
              }
              $ = $.parentNode;
            }
          }
          m = m.return;
        }
    ml(function() {
      var ae = _, Se = wn(d), _e = [];
      e: {
        var be = By.get(a);
        if (be !== void 0) {
          var He = Ut, et = a;
          switch (a) {
            case "keypress":
              if (se(d) === 0)
                break e;
            case "keydown":
            case "keyup":
              He = qS;
              break;
            case "focusin":
              et = "focus", He = Ba;
              break;
            case "focusout":
              et = "blur", He = Ba;
              break;
            case "beforeblur":
            case "afterblur":
              He = Ba;
              break;
            case "click":
              if (d.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              He = Mo;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              He = jc;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              He = GS;
              break;
            case Mh:
            case Iy:
            case Fy:
              He = Fc;
              break;
            case Uy:
              He = wy;
              break;
            case "scroll":
              He = Rn;
              break;
            case "wheel":
              He = Lo;
              break;
            case "copy":
            case "cut":
            case "paste":
              He = YS;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              He = rd;
          }
          var it = (l & 4) !== 0, cr = !it && a === "scroll", X = it ? be !== null ? be + "Capture" : null : be;
          it = [];
          for (var Y = ae, J; Y !== null; ) {
            J = Y;
            var Oe = J.stateNode;
            if (J.tag === 5 && Oe !== null && (J = Oe, X !== null && (Oe = Xi(Y, X), Oe != null && it.push(Zc(Y, Oe, J)))), cr)
              break;
            Y = Y.return;
          }
          0 < it.length && (be = new He(be, et, null, d, Se), _e.push({ event: be, listeners: it }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (be = a === "mouseover" || a === "pointerover", He = a === "mouseout" || a === "pointerout", be && d !== ti && (et = d.relatedTarget || d.fromElement) && (ya(et) || et[jo]))
            break e;
          if ((He || be) && (be = Se.window === Se ? Se : (be = Se.ownerDocument) ? be.defaultView || be.parentWindow : window, He ? (et = d.relatedTarget || d.toElement, He = ae, et = et ? ya(et) : null, et !== null && (cr = Dt(et), et !== cr || et.tag !== 5 && et.tag !== 6) && (et = null)) : (He = null, et = ae), He !== et)) {
            if (it = Mo, Oe = "onMouseLeave", X = "onMouseEnter", Y = "mouse", (a === "pointerout" || a === "pointerover") && (it = rd, Oe = "onPointerLeave", X = "onPointerEnter", Y = "pointer"), cr = He == null ? be : Lu(He), J = et == null ? be : Lu(et), be = new it(Oe, Y + "leave", He, d, Se), be.target = cr, be.relatedTarget = J, Oe = null, ya(Se) === ae && (it = new it(X, Y + "enter", et, d, Se), it.target = J, it.relatedTarget = cr, Oe = it), cr = Oe, He && et)
              t: {
                for (it = He, X = et, Y = 0, J = it; J; J = xs(J))
                  Y++;
                for (J = 0, Oe = X; Oe; Oe = xs(Oe))
                  J++;
                for (; 0 < Y - J; )
                  it = xs(it), Y--;
                for (; 0 < J - Y; )
                  X = xs(X), J--;
                for (; Y--; ) {
                  if (it === X || X !== null && it === X.alternate)
                    break t;
                  it = xs(it), X = xs(X);
                }
                it = null;
              }
            else
              it = null;
            He !== null && Nh(_e, be, He, it, !1), et !== null && cr !== null && Nh(_e, cr, et, it, !0);
          }
        }
        e: {
          if (be = ae ? Lu(ae) : window, He = be.nodeName && be.nodeName.toLowerCase(), He === "select" || He === "input" && be.type === "file")
            var ot = Oy;
          else if (Ty(be))
            if (Ch)
              ot = Ny;
            else {
              ot = JS;
              var tt = KS;
            }
          else
            (He = be.nodeName) && He.toLowerCase() === "input" && (be.type === "checkbox" || be.type === "radio") && (ot = e1);
          if (ot && (ot = ot(a, ae))) {
            Ry(_e, ot, d, Se);
            break e;
          }
          tt && tt(a, be, ae), a === "focusout" && (tt = be._wrapperState) && tt.controlled && be.type === "number" && Ir(be, "number", be.value);
        }
        switch (tt = ae ? Lu(ae) : window, a) {
          case "focusin":
            (Ty(tt) || tt.contentEditable === "true") && (Va = tt, Rh = ae, Hc = null);
            break;
          case "focusout":
            Hc = Rh = Va = null;
            break;
          case "mousedown":
            Oh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Oh = !1, jy(_e, d, Se);
            break;
          case "selectionchange":
            if ($y)
              break;
          case "keydown":
          case "keyup":
            jy(_e, d, Se);
        }
        var ut;
        if (Ha)
          e: {
            switch (a) {
              case "compositionstart":
                var Et = "onCompositionStart";
                break e;
              case "compositionend":
                Et = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Et = "onCompositionUpdate";
                break e;
            }
            Et = void 0;
          }
        else
          Ou ? Cy(a, d) && (Et = "onCompositionEnd") : a === "keydown" && d.keyCode === 229 && (Et = "onCompositionStart");
        Et && (_y && d.locale !== "ko" && (Ou || Et !== "onCompositionStart" ? Et === "onCompositionEnd" && Ou && (ut = re()) : (Ua = Se, A = "value" in Ua ? Ua.value : Ua.textContent, Ou = !0)), tt = qc(ae, Et), 0 < tt.length && (Et = new Sh(Et, a, null, d, Se), _e.push({ event: Et, listeners: tt }), ut ? Et.data = ut : (ut = od(d), ut !== null && (Et.data = ut)))), (ut = ad ? XS(a, d) : QS(a, d)) && (ae = qc(ae, "onBeforeInput"), 0 < ae.length && (Se = new Sh("onBeforeInput", "beforeinput", null, d, Se), _e.push({ event: Se, listeners: ae }), Se.data = ut));
      }
      cd(_e, l);
    });
  }
  function Zc(a, l, d) {
    return { instance: a, listener: l, currentTarget: d };
  }
  function qc(a, l) {
    for (var d = l + "Capture", m = []; a !== null; ) {
      var g = a, _ = g.stateNode;
      g.tag === 5 && _ !== null && (g = _, _ = Xi(a, d), _ != null && m.unshift(Zc(a, _, g)), _ = Xi(a, l), _ != null && m.push(Zc(a, _, g))), a = a.return;
    }
    return m;
  }
  function xs(a) {
    if (a === null)
      return null;
    do
      a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function Nh(a, l, d, m, g) {
    for (var _ = l._reactName, D = []; d !== null && d !== m; ) {
      var $ = d, B = $.alternate, ae = $.stateNode;
      if (B !== null && B === m)
        break;
      $.tag === 5 && ae !== null && ($ = ae, g ? (B = Xi(d, _), B != null && D.unshift(Zc(d, B, $))) : g || (B = Xi(d, _), B != null && D.push(Zc(d, B, $)))), d = d.return;
    }
    D.length !== 0 && a.push({ event: l, listeners: D });
  }
  var Lh = /\r\n?/g, i1 = /\u0000|\uFFFD/g;
  function Ph(a) {
    return (typeof a == "string" ? a : "" + a).replace(Lh, `
`).replace(i1, "");
  }
  function dd(a, l, d) {
    if (l = Ph(l), Ph(a) !== l && d)
      throw Error(i(425));
  }
  function pd() {
  }
  var zh = null, ws = null;
  function Gc(a, l) {
    return a === "textarea" || a === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var _s = typeof setTimeout == "function" ? setTimeout : void 0, Yy = typeof clearTimeout == "function" ? clearTimeout : void 0, $h = typeof Promise == "function" ? Promise : void 0, jh = typeof queueMicrotask == "function" ? queueMicrotask : typeof $h < "u" ? function(a) {
    return $h.resolve(null).then(a).catch(a1);
  } : _s;
  function a1(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Ol(a, l) {
    var d = l, m = 0;
    do {
      var g = d.nextSibling;
      if (a.removeChild(d), g && g.nodeType === 8)
        if (d = g.data, d === "/$") {
          if (m === 0) {
            a.removeChild(g), El(l);
            return;
          }
          m--;
        } else
          d !== "$" && d !== "$?" && d !== "$!" || m++;
      d = g;
    } while (d);
    El(l);
  }
  function Wa(a) {
    for (; a != null; a = a.nextSibling) {
      var l = a.nodeType;
      if (l === 1 || l === 3)
        break;
      if (l === 8) {
        if (l = a.data, l === "$" || l === "$!" || l === "$?")
          break;
        if (l === "/$")
          return null;
      }
    }
    return a;
  }
  function Xc(a) {
    a = a.previousSibling;
    for (var l = 0; a; ) {
      if (a.nodeType === 8) {
        var d = a.data;
        if (d === "$" || d === "$!" || d === "$?") {
          if (l === 0)
            return a;
          l--;
        } else
          d === "/$" && l++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Al = Math.random().toString(36).slice(2), co = "__reactFiber$" + Al, Es = "__reactProps$" + Al, jo = "__reactContainer$" + Al, Ih = "__reactEvents$" + Al, o1 = "__reactListeners$" + Al, Fh = "__reactHandles$" + Al;
  function ya(a) {
    var l = a[co];
    if (l)
      return l;
    for (var d = a.parentNode; d; ) {
      if (l = d[jo] || d[co]) {
        if (d = l.alternate, l.child !== null || d !== null && d.child !== null)
          for (a = Xc(a); a !== null; ) {
            if (d = a[co])
              return d;
            a = Xc(a);
          }
        return l;
      }
      a = d, d = a.parentNode;
    }
    return null;
  }
  function Qc(a) {
    return a = a[co] || a[jo], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
  }
  function Lu(a) {
    if (a.tag === 5 || a.tag === 6)
      return a.stateNode;
    throw Error(i(33));
  }
  function ct(a) {
    return a[Es] || null;
  }
  var Dl = [], jn = -1;
  function Pt(a) {
    return { current: a };
  }
  function hn(a) {
    0 > jn || (a.current = Dl[jn], Dl[jn] = null, jn--);
  }
  function gn(a, l) {
    jn++, Dl[jn] = a.current, a.current = l;
  }
  var fo = {}, _t = Pt(fo), ir = Pt(!1), Mi = fo;
  function ga(a, l) {
    var d = a.type.contextTypes;
    if (!d)
      return fo;
    var m = a.stateNode;
    if (m && m.__reactInternalMemoizedUnmaskedChildContext === l)
      return m.__reactInternalMemoizedMaskedChildContext;
    var g = {}, _;
    for (_ in d)
      g[_] = l[_];
    return m && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = l, a.__reactInternalMemoizedMaskedChildContext = g), g;
  }
  function Hn(a) {
    return a = a.childContextTypes, a != null;
  }
  function ba() {
    hn(ir), hn(_t);
  }
  function Ml(a, l, d) {
    if (_t.current !== fo)
      throw Error(i(168));
    gn(_t, l), gn(ir, d);
  }
  function Kc(a, l, d) {
    var m = a.stateNode;
    if (l = l.childContextTypes, typeof m.getChildContext != "function")
      return d;
    m = m.getChildContext();
    for (var g in m)
      if (!(g in l))
        throw Error(i(108, Nt(a) || "Unknown", g));
    return O({}, d, m);
  }
  function hd(a) {
    return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || fo, Mi = _t.current, gn(_t, a), gn(ir, ir.current), !0;
  }
  function Zy(a, l, d) {
    var m = a.stateNode;
    if (!m)
      throw Error(i(169));
    d ? (a = Kc(a, l, Mi), m.__reactInternalMemoizedMergedChildContext = a, hn(ir), hn(_t), gn(_t, a)) : hn(ir), gn(ir, d);
  }
  var Ji = null, Dr = !1, Jc = !1;
  function Uh(a) {
    Ji === null ? Ji = [a] : Ji.push(a);
  }
  function Bh(a) {
    Dr = !0, Uh(a);
  }
  function Ni() {
    if (!Jc && Ji !== null) {
      Jc = !0;
      var a = 0, l = cn;
      try {
        var d = Ji;
        for (cn = 1; a < d.length; a++) {
          var m = d[a];
          do
            m = m(!0);
          while (m !== null);
        }
        Ji = null, Dr = !1;
      } catch (g) {
        throw Ji !== null && (Ji = Ji.slice(a + 1)), Nn(Ia, Ni), g;
      } finally {
        cn = l, Jc = !1;
      }
    }
    return null;
  }
  var Nl = [], Li = 0, Cs = null, Pu = 0, Pi = [], ni = 0, Sa = null, Ur = 1, Io = "";
  function ea(a, l) {
    Nl[Li++] = Pu, Nl[Li++] = Cs, Cs = a, Pu = l;
  }
  function Hh(a, l, d) {
    Pi[ni++] = Ur, Pi[ni++] = Io, Pi[ni++] = Sa, Sa = a;
    var m = Ur;
    a = Io;
    var g = 32 - pi(m) - 1;
    m &= ~(1 << g), d += 1;
    var _ = 32 - pi(l) + g;
    if (30 < _) {
      var D = g - g % 5;
      _ = (m & (1 << D) - 1).toString(32), m >>= D, g -= D, Ur = 1 << 32 - pi(l) + g | d << g | m, Io = _ + a;
    } else
      Ur = 1 << _ | d << g | m, Io = a;
  }
  function md(a) {
    a.return !== null && (ea(a, 1), Hh(a, 1, 0));
  }
  function Vh(a) {
    for (; a === Cs; )
      Cs = Nl[--Li], Nl[Li] = null, Pu = Nl[--Li], Nl[Li] = null;
    for (; a === Sa; )
      Sa = Pi[--ni], Pi[ni] = null, Io = Pi[--ni], Pi[ni] = null, Ur = Pi[--ni], Pi[ni] = null;
  }
  var ta = null, zi = null, In = !1, xa = null;
  function Wh(a, l) {
    var d = Ta(5, null, null, 0);
    d.elementType = "DELETED", d.stateNode = l, d.return = a, l = a.deletions, l === null ? (a.deletions = [d], a.flags |= 16) : l.push(d);
  }
  function qy(a, l) {
    switch (a.tag) {
      case 5:
        var d = a.type;
        return l = l.nodeType !== 1 || d.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (a.stateNode = l, ta = a, zi = Wa(l.firstChild), !0) : !1;
      case 6:
        return l = a.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (a.stateNode = l, ta = a, zi = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (d = Sa !== null ? { id: Ur, overflow: Io } : null, a.memoizedState = { dehydrated: l, treeContext: d, retryLane: 1073741824 }, d = Ta(18, null, null, 0), d.stateNode = l, d.return = a, a.child = d, ta = a, zi = null, !0) : !1;
      default:
        return !1;
    }
  }
  function vd(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function yd(a) {
    if (In) {
      var l = zi;
      if (l) {
        var d = l;
        if (!qy(a, l)) {
          if (vd(a))
            throw Error(i(418));
          l = Wa(d.nextSibling);
          var m = ta;
          l && qy(a, l) ? Wh(m, d) : (a.flags = a.flags & -4097 | 2, In = !1, ta = a);
        }
      } else {
        if (vd(a))
          throw Error(i(418));
        a.flags = a.flags & -4097 | 2, In = !1, ta = a;
      }
    }
  }
  function Gy(a) {
    for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
      a = a.return;
    ta = a;
  }
  function gd(a) {
    if (a !== ta)
      return !1;
    if (!In)
      return Gy(a), In = !0, !1;
    var l;
    if ((l = a.tag !== 3) && !(l = a.tag !== 5) && (l = a.type, l = l !== "head" && l !== "body" && !Gc(a.type, a.memoizedProps)), l && (l = zi)) {
      if (vd(a))
        throw Xy(), Error(i(418));
      for (; l; )
        Wh(a, l), l = Wa(l.nextSibling);
    }
    if (Gy(a), a.tag === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
        throw Error(i(317));
      e: {
        for (a = a.nextSibling, l = 0; a; ) {
          if (a.nodeType === 8) {
            var d = a.data;
            if (d === "/$") {
              if (l === 0) {
                zi = Wa(a.nextSibling);
                break e;
              }
              l--;
            } else
              d !== "$" && d !== "$!" && d !== "$?" || l++;
          }
          a = a.nextSibling;
        }
        zi = null;
      }
    } else
      zi = ta ? Wa(a.stateNode.nextSibling) : null;
    return !0;
  }
  function Xy() {
    for (var a = zi; a; )
      a = Wa(a.nextSibling);
  }
  function Gn() {
    zi = ta = null, In = !1;
  }
  function Yh(a) {
    xa === null ? xa = [a] : xa.push(a);
  }
  var bd = te.ReactCurrentBatchConfig;
  function na(a, l) {
    if (a && a.defaultProps) {
      l = O({}, l), a = a.defaultProps;
      for (var d in a)
        l[d] === void 0 && (l[d] = a[d]);
      return l;
    }
    return l;
  }
  var po = Pt(null), Sd = null, Ll = null, Zh = null;
  function qh() {
    Zh = Ll = Sd = null;
  }
  function Pl(a) {
    var l = po.current;
    hn(po), a._currentValue = l;
  }
  function Mr(a, l, d) {
    for (; a !== null; ) {
      var m = a.alternate;
      if ((a.childLanes & l) !== l ? (a.childLanes |= l, m !== null && (m.childLanes |= l)) : m !== null && (m.childLanes & l) !== l && (m.childLanes |= l), a === d)
        break;
      a = a.return;
    }
  }
  function $e(a, l) {
    Sd = a, Zh = Ll = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & l && (gr = !0), a.firstContext = null);
  }
  function ur(a) {
    var l = a._currentValue;
    if (Zh !== a)
      if (a = { context: a, memoizedValue: l, next: null }, Ll === null) {
        if (Sd === null)
          throw Error(i(308));
        Ll = a, Sd.dependencies = { lanes: 0, firstContext: a };
      } else
        Ll = Ll.next = a;
    return l;
  }
  var Br = null;
  function Gh(a) {
    Br === null ? Br = [a] : Br.push(a);
  }
  function Qy(a, l, d, m) {
    var g = l.interleaved;
    return g === null ? (d.next = d, Gh(l)) : (d.next = g.next, g.next = d), l.interleaved = d, Fo(a, m);
  }
  function Fo(a, l) {
    a.lanes |= l;
    var d = a.alternate;
    for (d !== null && (d.lanes |= l), d = a, a = a.return; a !== null; )
      a.childLanes |= l, d = a.alternate, d !== null && (d.childLanes |= l), d = a, a = a.return;
    return d.tag === 3 ? d.stateNode : null;
  }
  var zl = !1;
  function Xh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function xr(a, l) {
    a = a.updateQueue, l.updateQueue === a && (l.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function Uo(a, l) {
    return { eventTime: a, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function $l(a, l, d) {
    var m = a.updateQueue;
    if (m === null)
      return null;
    if (m = m.shared, Gt & 2) {
      var g = m.pending;
      return g === null ? l.next = l : (l.next = g.next, g.next = l), m.pending = l, Fo(a, d);
    }
    return g = m.interleaved, g === null ? (l.next = l, Gh(m)) : (l.next = g.next, g.next = l), m.interleaved = l, Fo(a, d);
  }
  function xd(a, l, d) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (d & 4194240) !== 0)) {
      var m = l.lanes;
      m &= a.pendingLanes, d |= m, l.lanes = d, so(a, d);
    }
  }
  function Qh(a, l) {
    var d = a.updateQueue, m = a.alternate;
    if (m !== null && (m = m.updateQueue, d === m)) {
      var g = null, _ = null;
      if (d = d.firstBaseUpdate, d !== null) {
        do {
          var D = { eventTime: d.eventTime, lane: d.lane, tag: d.tag, payload: d.payload, callback: d.callback, next: null };
          _ === null ? g = _ = D : _ = _.next = D, d = d.next;
        } while (d !== null);
        _ === null ? g = _ = l : _ = _.next = l;
      } else
        g = _ = l;
      d = { baseState: m.baseState, firstBaseUpdate: g, lastBaseUpdate: _, shared: m.shared, effects: m.effects }, a.updateQueue = d;
      return;
    }
    a = d.lastBaseUpdate, a === null ? d.firstBaseUpdate = l : a.next = l, d.lastBaseUpdate = l;
  }
  function jl(a, l, d, m) {
    var g = a.updateQueue;
    zl = !1;
    var _ = g.firstBaseUpdate, D = g.lastBaseUpdate, $ = g.shared.pending;
    if ($ !== null) {
      g.shared.pending = null;
      var B = $, ae = B.next;
      B.next = null, D === null ? _ = ae : D.next = ae, D = B;
      var Se = a.alternate;
      Se !== null && (Se = Se.updateQueue, $ = Se.lastBaseUpdate, $ !== D && ($ === null ? Se.firstBaseUpdate = ae : $.next = ae, Se.lastBaseUpdate = B));
    }
    if (_ !== null) {
      var _e = g.baseState;
      D = 0, Se = ae = B = null, $ = _;
      do {
        var be = $.lane, He = $.eventTime;
        if ((m & be) === be) {
          Se !== null && (Se = Se.next = {
            eventTime: He,
            lane: 0,
            tag: $.tag,
            payload: $.payload,
            callback: $.callback,
            next: null
          });
          e: {
            var et = a, it = $;
            switch (be = l, He = d, it.tag) {
              case 1:
                if (et = it.payload, typeof et == "function") {
                  _e = et.call(He, _e, be);
                  break e;
                }
                _e = et;
                break e;
              case 3:
                et.flags = et.flags & -65537 | 128;
              case 0:
                if (et = it.payload, be = typeof et == "function" ? et.call(He, _e, be) : et, be == null)
                  break e;
                _e = O({}, _e, be);
                break e;
              case 2:
                zl = !0;
            }
          }
          $.callback !== null && $.lane !== 0 && (a.flags |= 64, be = g.effects, be === null ? g.effects = [$] : be.push($));
        } else
          He = { eventTime: He, lane: be, tag: $.tag, payload: $.payload, callback: $.callback, next: null }, Se === null ? (ae = Se = He, B = _e) : Se = Se.next = He, D |= be;
        if ($ = $.next, $ === null) {
          if ($ = g.shared.pending, $ === null)
            break;
          be = $, $ = be.next, be.next = null, g.lastBaseUpdate = be, g.shared.pending = null;
        }
      } while (!0);
      if (Se === null && (B = _e), g.baseState = B, g.firstBaseUpdate = ae, g.lastBaseUpdate = Se, l = g.shared.interleaved, l !== null) {
        g = l;
        do
          D |= g.lane, g = g.next;
        while (g !== l);
      } else
        _ === null && (g.shared.lanes = 0);
      Wo |= D, a.lanes = D, a.memoizedState = _e;
    }
  }
  function ks(a, l, d) {
    if (a = l.effects, l.effects = null, a !== null)
      for (l = 0; l < a.length; l++) {
        var m = a[l], g = m.callback;
        if (g !== null) {
          if (m.callback = null, m = d, typeof g != "function")
            throw Error(i(191, g));
          g.call(m);
        }
      }
  }
  var Ky = new t.Component().refs;
  function Kh(a, l, d, m) {
    l = a.memoizedState, d = d(m, l), d = d == null ? l : O({}, l, d), a.memoizedState = d, a.lanes === 0 && (a.updateQueue.baseState = d);
  }
  var wd = { isMounted: function(a) {
    return (a = a._reactInternals) ? Dt(a) === a : !1;
  }, enqueueSetState: function(a, l, d) {
    a = a._reactInternals;
    var m = oi(), g = br(a), _ = Uo(m, g);
    _.payload = l, d != null && (_.callback = d), l = $l(a, _, g), l !== null && (li(l, a, g, m), xd(l, a, g));
  }, enqueueReplaceState: function(a, l, d) {
    a = a._reactInternals;
    var m = oi(), g = br(a), _ = Uo(m, g);
    _.tag = 1, _.payload = l, d != null && (_.callback = d), l = $l(a, _, g), l !== null && (li(l, a, g, m), xd(l, a, g));
  }, enqueueForceUpdate: function(a, l) {
    a = a._reactInternals;
    var d = oi(), m = br(a), g = Uo(d, m);
    g.tag = 2, l != null && (g.callback = l), l = $l(a, g, m), l !== null && (li(l, a, m, d), xd(l, a, m));
  } };
  function Jy(a, l, d, m, g, _, D) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(m, _, D) : l.prototype && l.prototype.isPureReactComponent ? !Bc(d, m) || !Bc(g, _) : !0;
  }
  function eg(a, l, d) {
    var m = !1, g = fo, _ = l.contextType;
    return typeof _ == "object" && _ !== null ? _ = ur(_) : (g = Hn(l) ? Mi : _t.current, m = l.contextTypes, _ = (m = m != null) ? ga(a, g) : fo), l = new l(d, _), a.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = wd, a.stateNode = l, l._reactInternals = a, m && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = g, a.__reactInternalMemoizedMaskedChildContext = _), l;
  }
  function tg(a, l, d, m) {
    a = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(d, m), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(d, m), l.state !== a && wd.enqueueReplaceState(l, l.state, null);
  }
  function _d(a, l, d, m) {
    var g = a.stateNode;
    g.props = d, g.state = a.memoizedState, g.refs = Ky, Xh(a);
    var _ = l.contextType;
    typeof _ == "object" && _ !== null ? g.context = ur(_) : (_ = Hn(l) ? Mi : _t.current, g.context = ga(a, _)), g.state = a.memoizedState, _ = l.getDerivedStateFromProps, typeof _ == "function" && (Kh(a, l, _, d), g.state = a.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (l = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), l !== g.state && wd.enqueueReplaceState(g, g.state, null), jl(a, d, g, m), g.state = a.memoizedState), typeof g.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function zu(a, l, d) {
    if (a = d.ref, a !== null && typeof a != "function" && typeof a != "object") {
      if (d._owner) {
        if (d = d._owner, d) {
          if (d.tag !== 1)
            throw Error(i(309));
          var m = d.stateNode;
        }
        if (!m)
          throw Error(i(147, a));
        var g = m, _ = "" + a;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === _ ? l.ref : (l = function(D) {
          var $ = g.refs;
          $ === Ky && ($ = g.refs = {}), D === null ? delete $[_] : $[_] = D;
        }, l._stringRef = _, l);
      }
      if (typeof a != "string")
        throw Error(i(284));
      if (!d._owner)
        throw Error(i(290, a));
    }
    return a;
  }
  function Ed(a, l) {
    throw a = Object.prototype.toString.call(l), Error(i(31, a === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : a));
  }
  function ng(a) {
    var l = a._init;
    return l(a._payload);
  }
  function rg(a) {
    function l(X, Y) {
      if (a) {
        var J = X.deletions;
        J === null ? (X.deletions = [Y], X.flags |= 16) : J.push(Y);
      }
    }
    function d(X, Y) {
      if (!a)
        return null;
      for (; Y !== null; )
        l(X, Y), Y = Y.sibling;
      return null;
    }
    function m(X, Y) {
      for (X = /* @__PURE__ */ new Map(); Y !== null; )
        Y.key !== null ? X.set(Y.key, Y) : X.set(Y.index, Y), Y = Y.sibling;
      return X;
    }
    function g(X, Y) {
      return X = Yl(X, Y), X.index = 0, X.sibling = null, X;
    }
    function _(X, Y, J) {
      return X.index = J, a ? (J = X.alternate, J !== null ? (J = J.index, J < Y ? (X.flags |= 2, Y) : J) : (X.flags |= 2, Y)) : (X.flags |= 1048576, Y);
    }
    function D(X) {
      return a && X.alternate === null && (X.flags |= 2), X;
    }
    function $(X, Y, J, Oe) {
      return Y === null || Y.tag !== 6 ? (Y = bf(J, X.mode, Oe), Y.return = X, Y) : (Y = g(Y, J), Y.return = X, Y);
    }
    function B(X, Y, J, Oe) {
      var ot = J.type;
      return ot === ue ? Se(X, Y, J.props.children, Oe, J.key) : Y !== null && (Y.elementType === ot || typeof ot == "object" && ot !== null && ot.$$typeof === at && ng(ot) === Y.type) ? (Oe = g(Y, J.props), Oe.ref = zu(X, Y, J), Oe.return = X, Oe) : (Oe = np(J.type, J.key, J.props, null, X.mode, Oe), Oe.ref = zu(X, Y, J), Oe.return = X, Oe);
    }
    function ae(X, Y, J, Oe) {
      return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== J.containerInfo || Y.stateNode.implementation !== J.implementation ? (Y = Ws(J, X.mode, Oe), Y.return = X, Y) : (Y = g(Y, J.children || []), Y.return = X, Y);
    }
    function Se(X, Y, J, Oe, ot) {
      return Y === null || Y.tag !== 7 ? (Y = Vs(J, X.mode, Oe, ot), Y.return = X, Y) : (Y = g(Y, J), Y.return = X, Y);
    }
    function _e(X, Y, J) {
      if (typeof Y == "string" && Y !== "" || typeof Y == "number")
        return Y = bf("" + Y, X.mode, J), Y.return = X, Y;
      if (typeof Y == "object" && Y !== null) {
        switch (Y.$$typeof) {
          case ee:
            return J = np(Y.type, Y.key, Y.props, null, X.mode, J), J.ref = zu(X, null, Y), J.return = X, J;
          case V:
            return Y = Ws(Y, X.mode, J), Y.return = X, Y;
          case at:
            var Oe = Y._init;
            return _e(X, Oe(Y._payload), J);
        }
        if (mr(Y) || Fe(Y))
          return Y = Vs(Y, X.mode, J, null), Y.return = X, Y;
        Ed(X, Y);
      }
      return null;
    }
    function be(X, Y, J, Oe) {
      var ot = Y !== null ? Y.key : null;
      if (typeof J == "string" && J !== "" || typeof J == "number")
        return ot !== null ? null : $(X, Y, "" + J, Oe);
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case ee:
            return J.key === ot ? B(X, Y, J, Oe) : null;
          case V:
            return J.key === ot ? ae(X, Y, J, Oe) : null;
          case at:
            return ot = J._init, be(
              X,
              Y,
              ot(J._payload),
              Oe
            );
        }
        if (mr(J) || Fe(J))
          return ot !== null ? null : Se(X, Y, J, Oe, null);
        Ed(X, J);
      }
      return null;
    }
    function He(X, Y, J, Oe, ot) {
      if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number")
        return X = X.get(J) || null, $(Y, X, "" + Oe, ot);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case ee:
            return X = X.get(Oe.key === null ? J : Oe.key) || null, B(Y, X, Oe, ot);
          case V:
            return X = X.get(Oe.key === null ? J : Oe.key) || null, ae(Y, X, Oe, ot);
          case at:
            var tt = Oe._init;
            return He(X, Y, J, tt(Oe._payload), ot);
        }
        if (mr(Oe) || Fe(Oe))
          return X = X.get(J) || null, Se(Y, X, Oe, ot, null);
        Ed(Y, Oe);
      }
      return null;
    }
    function et(X, Y, J, Oe) {
      for (var ot = null, tt = null, ut = Y, Et = Y = 0, Pr = null; ut !== null && Et < J.length; Et++) {
        ut.index > Et ? (Pr = ut, ut = null) : Pr = ut.sibling;
        var un = be(X, ut, J[Et], Oe);
        if (un === null) {
          ut === null && (ut = Pr);
          break;
        }
        a && ut && un.alternate === null && l(X, ut), Y = _(un, Y, Et), tt === null ? ot = un : tt.sibling = un, tt = un, ut = Pr;
      }
      if (Et === J.length)
        return d(X, ut), In && ea(X, Et), ot;
      if (ut === null) {
        for (; Et < J.length; Et++)
          ut = _e(X, J[Et], Oe), ut !== null && (Y = _(ut, Y, Et), tt === null ? ot = ut : tt.sibling = ut, tt = ut);
        return In && ea(X, Et), ot;
      }
      for (ut = m(X, ut); Et < J.length; Et++)
        Pr = He(ut, X, Et, J[Et], Oe), Pr !== null && (a && Pr.alternate !== null && ut.delete(Pr.key === null ? Et : Pr.key), Y = _(Pr, Y, Et), tt === null ? ot = Pr : tt.sibling = Pr, tt = Pr);
      return a && ut.forEach(function(Zl) {
        return l(X, Zl);
      }), In && ea(X, Et), ot;
    }
    function it(X, Y, J, Oe) {
      var ot = Fe(J);
      if (typeof ot != "function")
        throw Error(i(150));
      if (J = ot.call(J), J == null)
        throw Error(i(151));
      for (var tt = ot = null, ut = Y, Et = Y = 0, Pr = null, un = J.next(); ut !== null && !un.done; Et++, un = J.next()) {
        ut.index > Et ? (Pr = ut, ut = null) : Pr = ut.sibling;
        var Zl = be(X, ut, un.value, Oe);
        if (Zl === null) {
          ut === null && (ut = Pr);
          break;
        }
        a && ut && Zl.alternate === null && l(X, ut), Y = _(Zl, Y, Et), tt === null ? ot = Zl : tt.sibling = Zl, tt = Zl, ut = Pr;
      }
      if (un.done)
        return d(
          X,
          ut
        ), In && ea(X, Et), ot;
      if (ut === null) {
        for (; !un.done; Et++, un = J.next())
          un = _e(X, un.value, Oe), un !== null && (Y = _(un, Y, Et), tt === null ? ot = un : tt.sibling = un, tt = un);
        return In && ea(X, Et), ot;
      }
      for (ut = m(X, ut); !un.done; Et++, un = J.next())
        un = He(ut, X, Et, un.value, Oe), un !== null && (a && un.alternate !== null && ut.delete(un.key === null ? Et : un.key), Y = _(un, Y, Et), tt === null ? ot = un : tt.sibling = un, tt = un);
      return a && ut.forEach(function(k1) {
        return l(X, k1);
      }), In && ea(X, Et), ot;
    }
    function cr(X, Y, J, Oe) {
      if (typeof J == "object" && J !== null && J.type === ue && J.key === null && (J = J.props.children), typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case ee:
            e: {
              for (var ot = J.key, tt = Y; tt !== null; ) {
                if (tt.key === ot) {
                  if (ot = J.type, ot === ue) {
                    if (tt.tag === 7) {
                      d(X, tt.sibling), Y = g(tt, J.props.children), Y.return = X, X = Y;
                      break e;
                    }
                  } else if (tt.elementType === ot || typeof ot == "object" && ot !== null && ot.$$typeof === at && ng(ot) === tt.type) {
                    d(X, tt.sibling), Y = g(tt, J.props), Y.ref = zu(X, tt, J), Y.return = X, X = Y;
                    break e;
                  }
                  d(X, tt);
                  break;
                } else
                  l(X, tt);
                tt = tt.sibling;
              }
              J.type === ue ? (Y = Vs(J.props.children, X.mode, Oe, J.key), Y.return = X, X = Y) : (Oe = np(J.type, J.key, J.props, null, X.mode, Oe), Oe.ref = zu(X, Y, J), Oe.return = X, X = Oe);
            }
            return D(X);
          case V:
            e: {
              for (tt = J.key; Y !== null; ) {
                if (Y.key === tt)
                  if (Y.tag === 4 && Y.stateNode.containerInfo === J.containerInfo && Y.stateNode.implementation === J.implementation) {
                    d(X, Y.sibling), Y = g(Y, J.children || []), Y.return = X, X = Y;
                    break e;
                  } else {
                    d(X, Y);
                    break;
                  }
                else
                  l(X, Y);
                Y = Y.sibling;
              }
              Y = Ws(J, X.mode, Oe), Y.return = X, X = Y;
            }
            return D(X);
          case at:
            return tt = J._init, cr(X, Y, tt(J._payload), Oe);
        }
        if (mr(J))
          return et(X, Y, J, Oe);
        if (Fe(J))
          return it(X, Y, J, Oe);
        Ed(X, J);
      }
      return typeof J == "string" && J !== "" || typeof J == "number" ? (J = "" + J, Y !== null && Y.tag === 6 ? (d(X, Y.sibling), Y = g(Y, J), Y.return = X, X = Y) : (d(X, Y), Y = bf(J, X.mode, Oe), Y.return = X, X = Y), D(X)) : d(X, Y);
    }
    return cr;
  }
  var $u = rg(!0), ig = rg(!1), ef = {}, Ya = Pt(ef), tf = Pt(ef), ju = Pt(ef);
  function Ts(a) {
    if (a === ef)
      throw Error(i(174));
    return a;
  }
  function Jh(a, l) {
    switch (gn(ju, l), gn(tf, a), gn(Ya, ef), a = l.nodeType, a) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : Ge(null, "");
        break;
      default:
        a = a === 8 ? l.parentNode : l, l = a.namespaceURI || null, a = a.tagName, l = Ge(l, a);
    }
    hn(Ya), gn(Ya, l);
  }
  function Il() {
    hn(Ya), hn(tf), hn(ju);
  }
  function ht(a) {
    Ts(ju.current);
    var l = Ts(Ya.current), d = Ge(l, a.type);
    l !== d && (gn(tf, a), gn(Ya, d));
  }
  function Bt(a) {
    tf.current === a && (hn(Ya), hn(tf));
  }
  var vt = Pt(0);
  function Xn(a) {
    for (var l = a; l !== null; ) {
      if (l.tag === 13) {
        var d = l.memoizedState;
        if (d !== null && (d = d.dehydrated, d === null || d.data === "$?" || d.data === "$!"))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128)
          return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === a)
        break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === a)
          return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var wa = [];
  function Cd() {
    for (var a = 0; a < wa.length; a++)
      wa[a]._workInProgressVersionPrimary = null;
    wa.length = 0;
  }
  var kd = te.ReactCurrentDispatcher, em = te.ReactCurrentBatchConfig, Rs = 0, Fn = null, pe = null, Jt = null, bt = !1, ho = !1, ra = 0, Os = 0;
  function Un() {
    throw Error(i(321));
  }
  function As(a, l) {
    if (l === null)
      return !1;
    for (var d = 0; d < l.length && d < a.length; d++)
      if (!va(a[d], l[d]))
        return !1;
    return !0;
  }
  function Fl(a, l, d, m, g, _) {
    if (Rs = _, Fn = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, kd.current = a === null || a.memoizedState === null ? s1 : u1, a = d(m, g), ho) {
      _ = 0;
      do {
        if (ho = !1, ra = 0, 25 <= _)
          throw Error(i(301));
        _ += 1, Jt = pe = null, l.updateQueue = null, kd.current = nm, a = d(m, g);
      } while (ho);
    }
    if (kd.current = Bd, l = pe !== null && pe.next !== null, Rs = 0, Jt = pe = Fn = null, bt = !1, l)
      throw Error(i(300));
    return a;
  }
  function Ds() {
    var a = ra !== 0;
    return ra = 0, a;
  }
  function _a() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Jt === null ? Fn.memoizedState = Jt = a : Jt = Jt.next = a, Jt;
  }
  function $i() {
    if (pe === null) {
      var a = Fn.alternate;
      a = a !== null ? a.memoizedState : null;
    } else
      a = pe.next;
    var l = Jt === null ? Fn.memoizedState : Jt.next;
    if (l !== null)
      Jt = l, pe = a;
    else {
      if (a === null)
        throw Error(i(310));
      pe = a, a = { memoizedState: pe.memoizedState, baseState: pe.baseState, baseQueue: pe.baseQueue, queue: pe.queue, next: null }, Jt === null ? Fn.memoizedState = Jt = a : Jt = Jt.next = a;
    }
    return Jt;
  }
  function Ms(a, l) {
    return typeof l == "function" ? l(a) : l;
  }
  function nf(a) {
    var l = $i(), d = l.queue;
    if (d === null)
      throw Error(i(311));
    d.lastRenderedReducer = a;
    var m = pe, g = m.baseQueue, _ = d.pending;
    if (_ !== null) {
      if (g !== null) {
        var D = g.next;
        g.next = _.next, _.next = D;
      }
      m.baseQueue = g = _, d.pending = null;
    }
    if (g !== null) {
      _ = g.next, m = m.baseState;
      var $ = D = null, B = null, ae = _;
      do {
        var Se = ae.lane;
        if ((Rs & Se) === Se)
          B !== null && (B = B.next = { lane: 0, action: ae.action, hasEagerState: ae.hasEagerState, eagerState: ae.eagerState, next: null }), m = ae.hasEagerState ? ae.eagerState : a(m, ae.action);
        else {
          var _e = {
            lane: Se,
            action: ae.action,
            hasEagerState: ae.hasEagerState,
            eagerState: ae.eagerState,
            next: null
          };
          B === null ? ($ = B = _e, D = m) : B = B.next = _e, Fn.lanes |= Se, Wo |= Se;
        }
        ae = ae.next;
      } while (ae !== null && ae !== _);
      B === null ? D = m : B.next = $, va(m, l.memoizedState) || (gr = !0), l.memoizedState = m, l.baseState = D, l.baseQueue = B, d.lastRenderedState = m;
    }
    if (a = d.interleaved, a !== null) {
      g = a;
      do
        _ = g.lane, Fn.lanes |= _, Wo |= _, g = g.next;
      while (g !== a);
    } else
      g === null && (d.lanes = 0);
    return [l.memoizedState, d.dispatch];
  }
  function rf(a) {
    var l = $i(), d = l.queue;
    if (d === null)
      throw Error(i(311));
    d.lastRenderedReducer = a;
    var m = d.dispatch, g = d.pending, _ = l.memoizedState;
    if (g !== null) {
      d.pending = null;
      var D = g = g.next;
      do
        _ = a(_, D.action), D = D.next;
      while (D !== g);
      va(_, l.memoizedState) || (gr = !0), l.memoizedState = _, l.baseQueue === null && (l.baseState = _), d.lastRenderedState = _;
    }
    return [_, m];
  }
  function Td() {
  }
  function Rd(a, l) {
    var d = Fn, m = $i(), g = l(), _ = !va(m.memoizedState, g);
    if (_ && (m.memoizedState = g, gr = !0), m = m.queue, af(Dd.bind(null, d, m, a), [a]), m.getSnapshot !== l || _ || Jt !== null && Jt.memoizedState.tag & 1) {
      if (d.flags |= 2048, Ns(9, Ad.bind(null, d, m, g, l), void 0, null), Qn === null)
        throw Error(i(349));
      Rs & 30 || Od(d, l, g);
    }
    return g;
  }
  function Od(a, l, d) {
    a.flags |= 16384, a = { getSnapshot: l, value: d }, l = Fn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Fn.updateQueue = l, l.stores = [a]) : (d = l.stores, d === null ? l.stores = [a] : d.push(a));
  }
  function Ad(a, l, d, m) {
    l.value = d, l.getSnapshot = m, Md(l) && Nd(a);
  }
  function Dd(a, l, d) {
    return d(function() {
      Md(l) && Nd(a);
    });
  }
  function Md(a) {
    var l = a.getSnapshot;
    a = a.value;
    try {
      var d = l();
      return !va(a, d);
    } catch {
      return !0;
    }
  }
  function Nd(a) {
    var l = Fo(a, 1);
    l !== null && li(l, a, 1, -1);
  }
  function Ld(a) {
    var l = _a();
    return typeof a == "function" && (a = a()), l.memoizedState = l.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ms, lastRenderedState: a }, l.queue = a, a = a.dispatch = Ud.bind(null, Fn, a), [l.memoizedState, a];
  }
  function Ns(a, l, d, m) {
    return a = { tag: a, create: l, destroy: d, deps: m, next: null }, l = Fn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Fn.updateQueue = l, l.lastEffect = a.next = a) : (d = l.lastEffect, d === null ? l.lastEffect = a.next = a : (m = d.next, d.next = a, a.next = m, l.lastEffect = a)), a;
  }
  function Pd() {
    return $i().memoizedState;
  }
  function Ls(a, l, d, m) {
    var g = _a();
    Fn.flags |= a, g.memoizedState = Ns(1 | l, d, void 0, m === void 0 ? null : m);
  }
  function Bo(a, l, d, m) {
    var g = $i();
    m = m === void 0 ? null : m;
    var _ = void 0;
    if (pe !== null) {
      var D = pe.memoizedState;
      if (_ = D.destroy, m !== null && As(m, D.deps)) {
        g.memoizedState = Ns(l, d, _, m);
        return;
      }
    }
    Fn.flags |= a, g.memoizedState = Ns(1 | l, d, _, m);
  }
  function zd(a, l) {
    return Ls(8390656, 8, a, l);
  }
  function af(a, l) {
    return Bo(2048, 8, a, l);
  }
  function $d(a, l) {
    return Bo(4, 2, a, l);
  }
  function jd(a, l) {
    return Bo(4, 4, a, l);
  }
  function tm(a, l) {
    if (typeof l == "function")
      return a = a(), l(a), function() {
        l(null);
      };
    if (l != null)
      return a = a(), l.current = a, function() {
        l.current = null;
      };
  }
  function Iu(a, l, d) {
    return d = d != null ? d.concat([a]) : null, Bo(4, 4, tm.bind(null, l, a), d);
  }
  function Id() {
  }
  function Fu(a, l) {
    var d = $i();
    l = l === void 0 ? null : l;
    var m = d.memoizedState;
    return m !== null && l !== null && As(l, m[1]) ? m[0] : (d.memoizedState = [a, l], a);
  }
  function Ul(a, l) {
    var d = $i();
    l = l === void 0 ? null : l;
    var m = d.memoizedState;
    return m !== null && l !== null && As(l, m[1]) ? m[0] : (a = a(), d.memoizedState = [a, l], a);
  }
  function ji(a, l, d) {
    return Rs & 21 ? (va(d, l) || (d = bu(), Fn.lanes |= d, Wo |= d, a.baseState = !0), l) : (a.baseState && (a.baseState = !1, gr = !0), a.memoizedState = d);
  }
  function l1(a, l) {
    var d = cn;
    cn = d !== 0 && 4 > d ? d : 4, a(!0);
    var m = em.transition;
    em.transition = {};
    try {
      a(!1), l();
    } finally {
      cn = d, em.transition = m;
    }
  }
  function Dn() {
    return $i().memoizedState;
  }
  function Fd(a, l, d) {
    var m = br(a);
    if (d = { lane: m, action: d, hasEagerState: !1, eagerState: null, next: null }, Uu(a))
      of(l, d);
    else if (d = Qy(a, l, d, m), d !== null) {
      var g = oi();
      li(d, a, m, g), ag(d, l, m);
    }
  }
  function Ud(a, l, d) {
    var m = br(a), g = { lane: m, action: d, hasEagerState: !1, eagerState: null, next: null };
    if (Uu(a))
      of(l, g);
    else {
      var _ = a.alternate;
      if (a.lanes === 0 && (_ === null || _.lanes === 0) && (_ = l.lastRenderedReducer, _ !== null))
        try {
          var D = l.lastRenderedState, $ = _(D, d);
          if (g.hasEagerState = !0, g.eagerState = $, va($, D)) {
            var B = l.interleaved;
            B === null ? (g.next = g, Gh(l)) : (g.next = B.next, B.next = g), l.interleaved = g;
            return;
          }
        } catch {
        } finally {
        }
      d = Qy(a, l, g, m), d !== null && (g = oi(), li(d, a, m, g), ag(d, l, m));
    }
  }
  function Uu(a) {
    var l = a.alternate;
    return a === Fn || l !== null && l === Fn;
  }
  function of(a, l) {
    ho = bt = !0;
    var d = a.pending;
    d === null ? l.next = l : (l.next = d.next, d.next = l), a.pending = l;
  }
  function ag(a, l, d) {
    if (d & 4194240) {
      var m = l.lanes;
      m &= a.pendingLanes, d |= m, l.lanes = d, so(a, d);
    }
  }
  var Bd = { readContext: ur, useCallback: Un, useContext: Un, useEffect: Un, useImperativeHandle: Un, useInsertionEffect: Un, useLayoutEffect: Un, useMemo: Un, useReducer: Un, useRef: Un, useState: Un, useDebugValue: Un, useDeferredValue: Un, useTransition: Un, useMutableSource: Un, useSyncExternalStore: Un, useId: Un, unstable_isNewReconciler: !1 }, s1 = { readContext: ur, useCallback: function(a, l) {
    return _a().memoizedState = [a, l === void 0 ? null : l], a;
  }, useContext: ur, useEffect: zd, useImperativeHandle: function(a, l, d) {
    return d = d != null ? d.concat([a]) : null, Ls(
      4194308,
      4,
      tm.bind(null, l, a),
      d
    );
  }, useLayoutEffect: function(a, l) {
    return Ls(4194308, 4, a, l);
  }, useInsertionEffect: function(a, l) {
    return Ls(4, 2, a, l);
  }, useMemo: function(a, l) {
    var d = _a();
    return l = l === void 0 ? null : l, a = a(), d.memoizedState = [a, l], a;
  }, useReducer: function(a, l, d) {
    var m = _a();
    return l = d !== void 0 ? d(l) : l, m.memoizedState = m.baseState = l, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: l }, m.queue = a, a = a.dispatch = Fd.bind(null, Fn, a), [m.memoizedState, a];
  }, useRef: function(a) {
    var l = _a();
    return a = { current: a }, l.memoizedState = a;
  }, useState: Ld, useDebugValue: Id, useDeferredValue: function(a) {
    return _a().memoizedState = a;
  }, useTransition: function() {
    var a = Ld(!1), l = a[0];
    return a = l1.bind(null, a[1]), _a().memoizedState = a, [l, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, l, d) {
    var m = Fn, g = _a();
    if (In) {
      if (d === void 0)
        throw Error(i(407));
      d = d();
    } else {
      if (d = l(), Qn === null)
        throw Error(i(349));
      Rs & 30 || Od(m, l, d);
    }
    g.memoizedState = d;
    var _ = { value: d, getSnapshot: l };
    return g.queue = _, zd(Dd.bind(
      null,
      m,
      _,
      a
    ), [a]), m.flags |= 2048, Ns(9, Ad.bind(null, m, _, d, l), void 0, null), d;
  }, useId: function() {
    var a = _a(), l = Qn.identifierPrefix;
    if (In) {
      var d = Io, m = Ur;
      d = (m & ~(1 << 32 - pi(m) - 1)).toString(32) + d, l = ":" + l + "R" + d, d = ra++, 0 < d && (l += "H" + d.toString(32)), l += ":";
    } else
      d = Os++, l = ":" + l + "r" + d.toString(32) + ":";
    return a.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, u1 = {
    readContext: ur,
    useCallback: Fu,
    useContext: ur,
    useEffect: af,
    useImperativeHandle: Iu,
    useInsertionEffect: $d,
    useLayoutEffect: jd,
    useMemo: Ul,
    useReducer: nf,
    useRef: Pd,
    useState: function() {
      return nf(Ms);
    },
    useDebugValue: Id,
    useDeferredValue: function(a) {
      var l = $i();
      return ji(l, pe.memoizedState, a);
    },
    useTransition: function() {
      var a = nf(Ms)[0], l = $i().memoizedState;
      return [a, l];
    },
    useMutableSource: Td,
    useSyncExternalStore: Rd,
    useId: Dn,
    unstable_isNewReconciler: !1
  }, nm = { readContext: ur, useCallback: Fu, useContext: ur, useEffect: af, useImperativeHandle: Iu, useInsertionEffect: $d, useLayoutEffect: jd, useMemo: Ul, useReducer: rf, useRef: Pd, useState: function() {
    return rf(Ms);
  }, useDebugValue: Id, useDeferredValue: function(a) {
    var l = $i();
    return pe === null ? l.memoizedState = a : ji(l, pe.memoizedState, a);
  }, useTransition: function() {
    var a = rf(Ms)[0], l = $i().memoizedState;
    return [a, l];
  }, useMutableSource: Td, useSyncExternalStore: Rd, useId: Dn, unstable_isNewReconciler: !1 };
  function Bu(a, l) {
    try {
      var d = "", m = l;
      do
        d += Mt(m), m = m.return;
      while (m);
      var g = d;
    } catch (_) {
      g = `
Error generating stack: ` + _.message + `
` + _.stack;
    }
    return { value: a, source: l, stack: g, digest: null };
  }
  function lf(a, l, d) {
    return { value: a, source: null, stack: d ?? null, digest: l ?? null };
  }
  function Hd(a, l) {
    try {
      console.error(l.value);
    } catch (d) {
      setTimeout(function() {
        throw d;
      });
    }
  }
  var c1 = typeof WeakMap == "function" ? WeakMap : Map;
  function og(a, l, d) {
    d = Uo(-1, d), d.tag = 3, d.payload = { element: null };
    var m = l.value;
    return d.callback = function() {
      Xd || (Xd = !0, Is = m), Hd(a, l);
    }, d;
  }
  function sf(a, l, d) {
    d = Uo(-1, d), d.tag = 3;
    var m = a.type.getDerivedStateFromError;
    if (typeof m == "function") {
      var g = l.value;
      d.payload = function() {
        return m(g);
      }, d.callback = function() {
        Hd(a, l);
      };
    }
    var _ = a.stateNode;
    return _ !== null && typeof _.componentDidCatch == "function" && (d.callback = function() {
      Hd(a, l), typeof m != "function" && (yo === null ? yo = /* @__PURE__ */ new Set([this]) : yo.add(this));
      var D = l.stack;
      this.componentDidCatch(l.value, { componentStack: D !== null ? D : "" });
    }), d;
  }
  function lg(a, l, d) {
    var m = a.pingCache;
    if (m === null) {
      m = a.pingCache = new c1();
      var g = /* @__PURE__ */ new Set();
      m.set(l, g);
    } else
      g = m.get(l), g === void 0 && (g = /* @__PURE__ */ new Set(), m.set(l, g));
    g.has(d) || (g.add(d), a = y1.bind(null, a, l, d), l.then(a, a));
  }
  function rm(a) {
    do {
      var l;
      if ((l = a.tag === 13) && (l = a.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l)
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function im(a, l, d, m, g) {
    return a.mode & 1 ? (a.flags |= 65536, a.lanes = g, a) : (a === l ? a.flags |= 65536 : (a.flags |= 128, d.flags |= 131072, d.flags &= -52805, d.tag === 1 && (d.alternate === null ? d.tag = 17 : (l = Uo(-1, 1), l.tag = 2, $l(d, l, 1))), d.lanes |= 1), a);
  }
  var f1 = te.ReactCurrentOwner, gr = !1;
  function wr(a, l, d, m) {
    l.child = a === null ? ig(l, null, d, m) : $u(l, a.child, d, m);
  }
  function Bl(a, l, d, m, g) {
    d = d.render;
    var _ = l.ref;
    return $e(l, g), m = Fl(a, l, d, m, _, g), d = Ds(), a !== null && !gr ? (l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~g, Hr(a, l, g)) : (In && d && md(l), l.flags |= 1, wr(a, l, m, g), l.child);
  }
  function Vd(a, l, d, m, g) {
    if (a === null) {
      var _ = d.type;
      return typeof _ == "function" && !_m(_) && _.defaultProps === void 0 && d.compare === null && d.defaultProps === void 0 ? (l.tag = 15, l.type = _, Ii(a, l, _, m, g)) : (a = np(d.type, null, m, l, l.mode, g), a.ref = l.ref, a.return = l, l.child = a);
    }
    if (_ = a.child, !(a.lanes & g)) {
      var D = _.memoizedProps;
      if (d = d.compare, d = d !== null ? d : Bc, d(D, m) && a.ref === l.ref)
        return Hr(a, l, g);
    }
    return l.flags |= 1, a = Yl(_, m), a.ref = l.ref, a.return = l, l.child = a;
  }
  function Ii(a, l, d, m, g) {
    if (a !== null) {
      var _ = a.memoizedProps;
      if (Bc(_, m) && a.ref === l.ref)
        if (gr = !1, l.pendingProps = m = _, (a.lanes & g) !== 0)
          a.flags & 131072 && (gr = !0);
        else
          return l.lanes = a.lanes, Hr(a, l, g);
    }
    return Hu(a, l, d, m, g);
  }
  function Ps(a, l, d) {
    var m = l.pendingProps, g = m.children, _ = a !== null ? a.memoizedState : null;
    if (m.mode === "hidden")
      if (!(l.mode & 1))
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, gn(Gu, ia), ia |= d;
      else {
        if (!(d & 1073741824))
          return a = _ !== null ? _.baseLanes | d : d, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, l.updateQueue = null, gn(Gu, ia), ia |= a, null;
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, m = _ !== null ? _.baseLanes : d, gn(Gu, ia), ia |= m;
      }
    else
      _ !== null ? (m = _.baseLanes | d, l.memoizedState = null) : m = d, gn(Gu, ia), ia |= m;
    return wr(a, l, g, d), l.child;
  }
  function zt(a, l) {
    var d = l.ref;
    (a === null && d !== null || a !== null && a.ref !== d) && (l.flags |= 512, l.flags |= 2097152);
  }
  function Hu(a, l, d, m, g) {
    var _ = Hn(d) ? Mi : _t.current;
    return _ = ga(l, _), $e(l, g), d = Fl(a, l, d, m, _, g), m = Ds(), a !== null && !gr ? (l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~g, Hr(a, l, g)) : (In && m && md(l), l.flags |= 1, wr(a, l, d, g), l.child);
  }
  function am(a, l, d, m, g) {
    if (Hn(d)) {
      var _ = !0;
      hd(l);
    } else
      _ = !1;
    if ($e(l, g), l.stateNode === null)
      ri(a, l), eg(l, d, m), _d(l, d, m, g), m = !0;
    else if (a === null) {
      var D = l.stateNode, $ = l.memoizedProps;
      D.props = $;
      var B = D.context, ae = d.contextType;
      typeof ae == "object" && ae !== null ? ae = ur(ae) : (ae = Hn(d) ? Mi : _t.current, ae = ga(l, ae));
      var Se = d.getDerivedStateFromProps, _e = typeof Se == "function" || typeof D.getSnapshotBeforeUpdate == "function";
      _e || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || ($ !== m || B !== ae) && tg(l, D, m, ae), zl = !1;
      var be = l.memoizedState;
      D.state = be, jl(l, m, D, g), B = l.memoizedState, $ !== m || be !== B || ir.current || zl ? (typeof Se == "function" && (Kh(l, d, Se, m), B = l.memoizedState), ($ = zl || Jy(l, d, $, m, be, B, ae)) ? (_e || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount()), typeof D.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof D.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = m, l.memoizedState = B), D.props = m, D.state = B, D.context = ae, m = $) : (typeof D.componentDidMount == "function" && (l.flags |= 4194308), m = !1);
    } else {
      D = l.stateNode, xr(a, l), $ = l.memoizedProps, ae = l.type === l.elementType ? $ : na(l.type, $), D.props = ae, _e = l.pendingProps, be = D.context, B = d.contextType, typeof B == "object" && B !== null ? B = ur(B) : (B = Hn(d) ? Mi : _t.current, B = ga(l, B));
      var He = d.getDerivedStateFromProps;
      (Se = typeof He == "function" || typeof D.getSnapshotBeforeUpdate == "function") || typeof D.UNSAFE_componentWillReceiveProps != "function" && typeof D.componentWillReceiveProps != "function" || ($ !== _e || be !== B) && tg(l, D, m, B), zl = !1, be = l.memoizedState, D.state = be, jl(l, m, D, g);
      var et = l.memoizedState;
      $ !== _e || be !== et || ir.current || zl ? (typeof He == "function" && (Kh(l, d, He, m), et = l.memoizedState), (ae = zl || Jy(l, d, ae, m, be, et, B) || !1) ? (Se || typeof D.UNSAFE_componentWillUpdate != "function" && typeof D.componentWillUpdate != "function" || (typeof D.componentWillUpdate == "function" && D.componentWillUpdate(m, et, B), typeof D.UNSAFE_componentWillUpdate == "function" && D.UNSAFE_componentWillUpdate(m, et, B)), typeof D.componentDidUpdate == "function" && (l.flags |= 4), typeof D.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof D.componentDidUpdate != "function" || $ === a.memoizedProps && be === a.memoizedState || (l.flags |= 4), typeof D.getSnapshotBeforeUpdate != "function" || $ === a.memoizedProps && be === a.memoizedState || (l.flags |= 1024), l.memoizedProps = m, l.memoizedState = et), D.props = m, D.state = et, D.context = B, m = ae) : (typeof D.componentDidUpdate != "function" || $ === a.memoizedProps && be === a.memoizedState || (l.flags |= 4), typeof D.getSnapshotBeforeUpdate != "function" || $ === a.memoizedProps && be === a.memoizedState || (l.flags |= 1024), m = !1);
    }
    return sg(a, l, d, m, _, g);
  }
  function sg(a, l, d, m, g, _) {
    zt(a, l);
    var D = (l.flags & 128) !== 0;
    if (!m && !D)
      return g && Zy(l, d, !1), Hr(a, l, _);
    m = l.stateNode, f1.current = l;
    var $ = D && typeof d.getDerivedStateFromError != "function" ? null : m.render();
    return l.flags |= 1, a !== null && D ? (l.child = $u(l, a.child, null, _), l.child = $u(l, null, $, _)) : wr(a, l, $, _), l.memoizedState = m.state, g && Zy(l, d, !0), l.child;
  }
  function ug(a) {
    var l = a.stateNode;
    l.pendingContext ? Ml(a, l.pendingContext, l.pendingContext !== l.context) : l.context && Ml(a, l.context, !1), Jh(a, l.containerInfo);
  }
  function Wd(a, l, d, m, g) {
    return Gn(), Yh(g), l.flags |= 256, wr(a, l, d, m), l.child;
  }
  var zs = { dehydrated: null, treeContext: null, retryLane: 0 };
  function om(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function lm(a, l, d) {
    var m = l.pendingProps, g = vt.current, _ = !1, D = (l.flags & 128) !== 0, $;
    if (($ = D) || ($ = a !== null && a.memoizedState === null ? !1 : (g & 2) !== 0), $ ? (_ = !0, l.flags &= -129) : (a === null || a.memoizedState !== null) && (g |= 1), gn(vt, g & 1), a === null)
      return yd(l), a = l.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (l.mode & 1 ? a.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (D = m.children, a = m.fallback, _ ? (m = l.mode, _ = l.child, D = { mode: "hidden", children: D }, !(m & 1) && _ !== null ? (_.childLanes = 0, _.pendingProps = D) : _ = gf(D, m, 0, null), a = Vs(a, m, d, null), _.return = l, a.return = l, _.sibling = a, l.child = _, l.child.memoizedState = om(d), l.memoizedState = zs, a) : sm(l, D));
    if (g = a.memoizedState, g !== null && ($ = g.dehydrated, $ !== null))
      return d1(a, l, D, m, $, g, d);
    if (_) {
      _ = m.fallback, D = l.mode, g = a.child, $ = g.sibling;
      var B = { mode: "hidden", children: m.children };
      return !(D & 1) && l.child !== g ? (m = l.child, m.childLanes = 0, m.pendingProps = B, l.deletions = null) : (m = Yl(g, B), m.subtreeFlags = g.subtreeFlags & 14680064), $ !== null ? _ = Yl($, _) : (_ = Vs(_, D, d, null), _.flags |= 2), _.return = l, m.return = l, m.sibling = _, l.child = m, m = _, _ = l.child, D = a.child.memoizedState, D = D === null ? om(d) : { baseLanes: D.baseLanes | d, cachePool: null, transitions: D.transitions }, _.memoizedState = D, _.childLanes = a.childLanes & ~d, l.memoizedState = zs, m;
    }
    return _ = a.child, a = _.sibling, m = Yl(_, { mode: "visible", children: m.children }), !(l.mode & 1) && (m.lanes = d), m.return = l, m.sibling = null, a !== null && (d = l.deletions, d === null ? (l.deletions = [a], l.flags |= 16) : d.push(a)), l.child = m, l.memoizedState = null, m;
  }
  function sm(a, l) {
    return l = gf({ mode: "visible", children: l }, a.mode, 0, null), l.return = a, a.child = l;
  }
  function Vu(a, l, d, m) {
    return m !== null && Yh(m), $u(l, a.child, null, d), a = sm(l, l.pendingProps.children), a.flags |= 2, l.memoizedState = null, a;
  }
  function d1(a, l, d, m, g, _, D) {
    if (d)
      return l.flags & 256 ? (l.flags &= -257, m = lf(Error(i(422))), Vu(a, l, D, m)) : l.memoizedState !== null ? (l.child = a.child, l.flags |= 128, null) : (_ = m.fallback, g = l.mode, m = gf({ mode: "visible", children: m.children }, g, 0, null), _ = Vs(_, g, D, null), _.flags |= 2, m.return = l, _.return = l, m.sibling = _, l.child = m, l.mode & 1 && $u(l, a.child, null, D), l.child.memoizedState = om(D), l.memoizedState = zs, _);
    if (!(l.mode & 1))
      return Vu(a, l, D, null);
    if (g.data === "$!") {
      if (m = g.nextSibling && g.nextSibling.dataset, m)
        var $ = m.dgst;
      return m = $, _ = Error(i(419)), m = lf(_, m, void 0), Vu(a, l, D, m);
    }
    if ($ = (D & a.childLanes) !== 0, gr || $) {
      if (m = Qn, m !== null) {
        switch (D & -D) {
          case 4:
            g = 2;
            break;
          case 16:
            g = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            g = 32;
            break;
          case 536870912:
            g = 268435456;
            break;
          default:
            g = 0;
        }
        g = g & (m.suspendedLanes | D) ? 0 : g, g !== 0 && g !== _.retryLane && (_.retryLane = g, Fo(a, g), li(m, a, g, -1));
      }
      return Sm(), m = lf(Error(i(421))), Vu(a, l, D, m);
    }
    return g.data === "$?" ? (l.flags |= 128, l.child = a.child, l = g1.bind(null, a), g._reactRetry = l, null) : (a = _.treeContext, zi = Wa(g.nextSibling), ta = l, In = !0, xa = null, a !== null && (Pi[ni++] = Ur, Pi[ni++] = Io, Pi[ni++] = Sa, Ur = a.id, Io = a.overflow, Sa = l), l = sm(l, m.children), l.flags |= 4096, l);
  }
  function um(a, l, d) {
    a.lanes |= l;
    var m = a.alternate;
    m !== null && (m.lanes |= l), Mr(a.return, l, d);
  }
  function Yd(a, l, d, m, g) {
    var _ = a.memoizedState;
    _ === null ? a.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: m, tail: d, tailMode: g } : (_.isBackwards = l, _.rendering = null, _.renderingStartTime = 0, _.last = m, _.tail = d, _.tailMode = g);
  }
  function cm(a, l, d) {
    var m = l.pendingProps, g = m.revealOrder, _ = m.tail;
    if (wr(a, l, m.children, d), m = vt.current, m & 2)
      m = m & 1 | 2, l.flags |= 128;
    else {
      if (a !== null && a.flags & 128)
        e:
          for (a = l.child; a !== null; ) {
            if (a.tag === 13)
              a.memoizedState !== null && um(a, d, l);
            else if (a.tag === 19)
              um(a, d, l);
            else if (a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === l)
              break e;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === l)
                break e;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
      m &= 1;
    }
    if (gn(vt, m), !(l.mode & 1))
      l.memoizedState = null;
    else
      switch (g) {
        case "forwards":
          for (d = l.child, g = null; d !== null; )
            a = d.alternate, a !== null && Xn(a) === null && (g = d), d = d.sibling;
          d = g, d === null ? (g = l.child, l.child = null) : (g = d.sibling, d.sibling = null), Yd(l, !1, g, d, _);
          break;
        case "backwards":
          for (d = null, g = l.child, l.child = null; g !== null; ) {
            if (a = g.alternate, a !== null && Xn(a) === null) {
              l.child = g;
              break;
            }
            a = g.sibling, g.sibling = d, d = g, g = a;
          }
          Yd(l, !0, d, null, _);
          break;
        case "together":
          Yd(l, !1, null, null, void 0);
          break;
        default:
          l.memoizedState = null;
      }
    return l.child;
  }
  function ri(a, l) {
    !(l.mode & 1) && a !== null && (a.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function Hr(a, l, d) {
    if (a !== null && (l.dependencies = a.dependencies), Wo |= l.lanes, !(d & l.childLanes))
      return null;
    if (a !== null && l.child !== a.child)
      throw Error(i(153));
    if (l.child !== null) {
      for (a = l.child, d = Yl(a, a.pendingProps), l.child = d, d.return = l; a.sibling !== null; )
        a = a.sibling, d = d.sibling = Yl(a, a.pendingProps), d.return = l;
      d.sibling = null;
    }
    return l.child;
  }
  function Ho(a, l, d) {
    switch (l.tag) {
      case 3:
        ug(l), Gn();
        break;
      case 5:
        ht(l);
        break;
      case 1:
        Hn(l.type) && hd(l);
        break;
      case 4:
        Jh(l, l.stateNode.containerInfo);
        break;
      case 10:
        var m = l.type._context, g = l.memoizedProps.value;
        gn(po, m._currentValue), m._currentValue = g;
        break;
      case 13:
        if (m = l.memoizedState, m !== null)
          return m.dehydrated !== null ? (gn(vt, vt.current & 1), l.flags |= 128, null) : d & l.child.childLanes ? lm(a, l, d) : (gn(vt, vt.current & 1), a = Hr(a, l, d), a !== null ? a.sibling : null);
        gn(vt, vt.current & 1);
        break;
      case 19:
        if (m = (d & l.childLanes) !== 0, a.flags & 128) {
          if (m)
            return cm(a, l, d);
          l.flags |= 128;
        }
        if (g = l.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), gn(vt, vt.current), m)
          break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, Ps(a, l, d);
    }
    return Hr(a, l, d);
  }
  var uf, $s, Ea, _r;
  uf = function(a, l) {
    for (var d = l.child; d !== null; ) {
      if (d.tag === 5 || d.tag === 6)
        a.appendChild(d.stateNode);
      else if (d.tag !== 4 && d.child !== null) {
        d.child.return = d, d = d.child;
        continue;
      }
      if (d === l)
        break;
      for (; d.sibling === null; ) {
        if (d.return === null || d.return === l)
          return;
        d = d.return;
      }
      d.sibling.return = d.return, d = d.sibling;
    }
  }, $s = function() {
  }, Ea = function(a, l, d, m) {
    var g = a.memoizedProps;
    if (g !== m) {
      a = l.stateNode, Ts(Ya.current);
      var _ = null;
      switch (d) {
        case "input":
          g = sr(a, g), m = sr(a, m), _ = [];
          break;
        case "select":
          g = O({}, g, { value: void 0 }), m = O({}, m, { value: void 0 }), _ = [];
          break;
        case "textarea":
          g = ei(a, g), m = ei(a, m), _ = [];
          break;
        default:
          typeof g.onClick != "function" && typeof m.onClick == "function" && (a.onclick = pd);
      }
      Cn(d, m);
      var D;
      d = null;
      for (ae in g)
        if (!m.hasOwnProperty(ae) && g.hasOwnProperty(ae) && g[ae] != null)
          if (ae === "style") {
            var $ = g[ae];
            for (D in $)
              $.hasOwnProperty(D) && (d || (d = {}), d[D] = "");
          } else
            ae !== "dangerouslySetInnerHTML" && ae !== "children" && ae !== "suppressContentEditableWarning" && ae !== "suppressHydrationWarning" && ae !== "autoFocus" && (u.hasOwnProperty(ae) ? _ || (_ = []) : (_ = _ || []).push(ae, null));
      for (ae in m) {
        var B = m[ae];
        if ($ = g != null ? g[ae] : void 0, m.hasOwnProperty(ae) && B !== $ && (B != null || $ != null))
          if (ae === "style")
            if ($) {
              for (D in $)
                !$.hasOwnProperty(D) || B && B.hasOwnProperty(D) || (d || (d = {}), d[D] = "");
              for (D in B)
                B.hasOwnProperty(D) && $[D] !== B[D] && (d || (d = {}), d[D] = B[D]);
            } else
              d || (_ || (_ = []), _.push(
                ae,
                d
              )), d = B;
          else
            ae === "dangerouslySetInnerHTML" ? (B = B ? B.__html : void 0, $ = $ ? $.__html : void 0, B != null && $ !== B && (_ = _ || []).push(ae, B)) : ae === "children" ? typeof B != "string" && typeof B != "number" || (_ = _ || []).push(ae, "" + B) : ae !== "suppressContentEditableWarning" && ae !== "suppressHydrationWarning" && (u.hasOwnProperty(ae) ? (B != null && ae === "onScroll" && An("scroll", a), _ || $ === B || (_ = [])) : (_ = _ || []).push(ae, B));
      }
      d && (_ = _ || []).push("style", d);
      var ae = _;
      (l.updateQueue = ae) && (l.flags |= 4);
    }
  }, _r = function(a, l, d, m) {
    d !== m && (l.flags |= 4);
  };
  function cf(a, l) {
    if (!In)
      switch (a.tailMode) {
        case "hidden":
          l = a.tail;
          for (var d = null; l !== null; )
            l.alternate !== null && (d = l), l = l.sibling;
          d === null ? a.tail = null : d.sibling = null;
          break;
        case "collapsed":
          d = a.tail;
          for (var m = null; d !== null; )
            d.alternate !== null && (m = d), d = d.sibling;
          m === null ? l || a.tail === null ? a.tail = null : a.tail.sibling = null : m.sibling = null;
      }
  }
  function ii(a) {
    var l = a.alternate !== null && a.alternate.child === a.child, d = 0, m = 0;
    if (l)
      for (var g = a.child; g !== null; )
        d |= g.lanes | g.childLanes, m |= g.subtreeFlags & 14680064, m |= g.flags & 14680064, g.return = a, g = g.sibling;
    else
      for (g = a.child; g !== null; )
        d |= g.lanes | g.childLanes, m |= g.subtreeFlags, m |= g.flags, g.return = a, g = g.sibling;
    return a.subtreeFlags |= m, a.childLanes = d, l;
  }
  function p1(a, l, d) {
    var m = l.pendingProps;
    switch (Vh(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ii(l), null;
      case 1:
        return Hn(l.type) && ba(), ii(l), null;
      case 3:
        return m = l.stateNode, Il(), hn(ir), hn(_t), Cd(), m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null), (a === null || a.child === null) && (gd(l) ? l.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, xa !== null && (yf(xa), xa = null))), $s(a, l), ii(l), null;
      case 5:
        Bt(l);
        var g = Ts(ju.current);
        if (d = l.type, a !== null && l.stateNode != null)
          Ea(a, l, d, m, g), a.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(i(166));
            return ii(l), null;
          }
          if (a = Ts(Ya.current), gd(l)) {
            m = l.stateNode, d = l.type;
            var _ = l.memoizedProps;
            switch (m[co] = l, m[Es] = _, a = (l.mode & 1) !== 0, d) {
              case "dialog":
                An("cancel", m), An("close", m);
                break;
              case "iframe":
              case "object":
              case "embed":
                An("load", m);
                break;
              case "video":
              case "audio":
                for (g = 0; g < Yc.length; g++)
                  An(Yc[g], m);
                break;
              case "source":
                An("error", m);
                break;
              case "img":
              case "image":
              case "link":
                An(
                  "error",
                  m
                ), An("load", m);
                break;
              case "details":
                An("toggle", m);
                break;
              case "input":
                tr(m, _), An("invalid", m);
                break;
              case "select":
                m._wrapperState = { wasMultiple: !!_.multiple }, An("invalid", m);
                break;
              case "textarea":
                Rr(m, _), An("invalid", m);
            }
            Cn(d, _), g = null;
            for (var D in _)
              if (_.hasOwnProperty(D)) {
                var $ = _[D];
                D === "children" ? typeof $ == "string" ? m.textContent !== $ && (_.suppressHydrationWarning !== !0 && dd(m.textContent, $, a), g = ["children", $]) : typeof $ == "number" && m.textContent !== "" + $ && (_.suppressHydrationWarning !== !0 && dd(
                  m.textContent,
                  $,
                  a
                ), g = ["children", "" + $]) : u.hasOwnProperty(D) && $ != null && D === "onScroll" && An("scroll", m);
              }
            switch (d) {
              case "input":
                hr(m), jr(m, _, !0);
                break;
              case "textarea":
                hr(m), le(m);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof _.onClick == "function" && (m.onclick = pd);
            }
            m = g, l.updateQueue = m, m !== null && (l.flags |= 4);
          } else {
            D = g.nodeType === 9 ? g : g.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = Ce(d)), a === "http://www.w3.org/1999/xhtml" ? d === "script" ? (a = D.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof m.is == "string" ? a = D.createElement(d, { is: m.is }) : (a = D.createElement(d), d === "select" && (D = a, m.multiple ? D.multiple = !0 : m.size && (D.size = m.size))) : a = D.createElementNS(a, d), a[co] = l, a[Es] = m, uf(a, l, !1, !1), l.stateNode = a;
            e: {
              switch (D = sn(d, m), d) {
                case "dialog":
                  An("cancel", a), An("close", a), g = m;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  An("load", a), g = m;
                  break;
                case "video":
                case "audio":
                  for (g = 0; g < Yc.length; g++)
                    An(Yc[g], a);
                  g = m;
                  break;
                case "source":
                  An("error", a), g = m;
                  break;
                case "img":
                case "image":
                case "link":
                  An(
                    "error",
                    a
                  ), An("load", a), g = m;
                  break;
                case "details":
                  An("toggle", a), g = m;
                  break;
                case "input":
                  tr(a, m), g = sr(a, m), An("invalid", a);
                  break;
                case "option":
                  g = m;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!m.multiple }, g = O({}, m, { value: void 0 }), An("invalid", a);
                  break;
                case "textarea":
                  Rr(a, m), g = ei(a, m), An("invalid", a);
                  break;
                default:
                  g = m;
              }
              Cn(d, g), $ = g;
              for (_ in $)
                if ($.hasOwnProperty(_)) {
                  var B = $[_];
                  _ === "style" ? qt(a, B) : _ === "dangerouslySetInnerHTML" ? (B = B ? B.__html : void 0, B != null && It(a, B)) : _ === "children" ? typeof B == "string" ? (d !== "textarea" || B !== "") && $n(a, B) : typeof B == "number" && $n(a, "" + B) : _ !== "suppressContentEditableWarning" && _ !== "suppressHydrationWarning" && _ !== "autoFocus" && (u.hasOwnProperty(_) ? B != null && _ === "onScroll" && An("scroll", a) : B != null && G(a, _, B, D));
                }
              switch (d) {
                case "input":
                  hr(a), jr(a, m, !1);
                  break;
                case "textarea":
                  hr(a), le(a);
                  break;
                case "option":
                  m.value != null && a.setAttribute("value", "" + xt(m.value));
                  break;
                case "select":
                  a.multiple = !!m.multiple, _ = m.value, _ != null ? Tr(a, !!m.multiple, _, !1) : m.defaultValue != null && Tr(
                    a,
                    !!m.multiple,
                    m.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof g.onClick == "function" && (a.onclick = pd);
              }
              switch (d) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  m = !!m.autoFocus;
                  break e;
                case "img":
                  m = !0;
                  break e;
                default:
                  m = !1;
              }
            }
            m && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return ii(l), null;
      case 6:
        if (a && l.stateNode != null)
          _r(a, l, a.memoizedProps, m);
        else {
          if (typeof m != "string" && l.stateNode === null)
            throw Error(i(166));
          if (d = Ts(ju.current), Ts(Ya.current), gd(l)) {
            if (m = l.stateNode, d = l.memoizedProps, m[co] = l, (_ = m.nodeValue !== d) && (a = ta, a !== null))
              switch (a.tag) {
                case 3:
                  dd(m.nodeValue, d, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== !0 && dd(m.nodeValue, d, (a.mode & 1) !== 0);
              }
            _ && (l.flags |= 4);
          } else
            m = (d.nodeType === 9 ? d : d.ownerDocument).createTextNode(m), m[co] = l, l.stateNode = m;
        }
        return ii(l), null;
      case 13:
        if (hn(vt), m = l.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (In && zi !== null && l.mode & 1 && !(l.flags & 128))
            Xy(), Gn(), l.flags |= 98560, _ = !1;
          else if (_ = gd(l), m !== null && m.dehydrated !== null) {
            if (a === null) {
              if (!_)
                throw Error(i(318));
              if (_ = l.memoizedState, _ = _ !== null ? _.dehydrated : null, !_)
                throw Error(i(317));
              _[co] = l;
            } else
              Gn(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            ii(l), _ = !1;
          } else
            xa !== null && (yf(xa), xa = null), _ = !0;
          if (!_)
            return l.flags & 65536 ? l : null;
        }
        return l.flags & 128 ? (l.lanes = d, l) : (m = m !== null, m !== (a !== null && a.memoizedState !== null) && m && (l.child.flags |= 8192, l.mode & 1 && (a === null || vt.current & 1 ? Cr === 0 && (Cr = 3) : Sm())), l.updateQueue !== null && (l.flags |= 4), ii(l), null);
      case 4:
        return Il(), $s(a, l), a === null && Nu(l.stateNode.containerInfo), ii(l), null;
      case 10:
        return Pl(l.type._context), ii(l), null;
      case 17:
        return Hn(l.type) && ba(), ii(l), null;
      case 19:
        if (hn(vt), _ = l.memoizedState, _ === null)
          return ii(l), null;
        if (m = (l.flags & 128) !== 0, D = _.rendering, D === null)
          if (m)
            cf(_, !1);
          else {
            if (Cr !== 0 || a !== null && a.flags & 128)
              for (a = l.child; a !== null; ) {
                if (D = Xn(a), D !== null) {
                  for (l.flags |= 128, cf(_, !1), m = D.updateQueue, m !== null && (l.updateQueue = m, l.flags |= 4), l.subtreeFlags = 0, m = d, d = l.child; d !== null; )
                    _ = d, a = m, _.flags &= 14680066, D = _.alternate, D === null ? (_.childLanes = 0, _.lanes = a, _.child = null, _.subtreeFlags = 0, _.memoizedProps = null, _.memoizedState = null, _.updateQueue = null, _.dependencies = null, _.stateNode = null) : (_.childLanes = D.childLanes, _.lanes = D.lanes, _.child = D.child, _.subtreeFlags = 0, _.deletions = null, _.memoizedProps = D.memoizedProps, _.memoizedState = D.memoizedState, _.updateQueue = D.updateQueue, _.type = D.type, a = D.dependencies, _.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), d = d.sibling;
                  return gn(vt, vt.current & 1 | 2), l.child;
                }
                a = a.sibling;
              }
            _.tail !== null && an() > Qu && (l.flags |= 128, m = !0, cf(_, !1), l.lanes = 4194304);
          }
        else {
          if (!m)
            if (a = Xn(D), a !== null) {
              if (l.flags |= 128, m = !0, d = a.updateQueue, d !== null && (l.updateQueue = d, l.flags |= 4), cf(_, !0), _.tail === null && _.tailMode === "hidden" && !D.alternate && !In)
                return ii(l), null;
            } else
              2 * an() - _.renderingStartTime > Qu && d !== 1073741824 && (l.flags |= 128, m = !0, cf(_, !1), l.lanes = 4194304);
          _.isBackwards ? (D.sibling = l.child, l.child = D) : (d = _.last, d !== null ? d.sibling = D : l.child = D, _.last = D);
        }
        return _.tail !== null ? (l = _.tail, _.rendering = l, _.tail = l.sibling, _.renderingStartTime = an(), l.sibling = null, d = vt.current, gn(vt, m ? d & 1 | 2 : d & 1), l) : (ii(l), null);
      case 22:
      case 23:
        return bm(), m = l.memoizedState !== null, a !== null && a.memoizedState !== null !== m && (l.flags |= 8192), m && l.mode & 1 ? ia & 1073741824 && (ii(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : ii(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(i(156, l.tag));
  }
  function fm(a, l) {
    switch (Vh(l), l.tag) {
      case 1:
        return Hn(l.type) && ba(), a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 3:
        return Il(), hn(ir), hn(_t), Cd(), a = l.flags, a & 65536 && !(a & 128) ? (l.flags = a & -65537 | 128, l) : null;
      case 5:
        return Bt(l), null;
      case 13:
        if (hn(vt), a = l.memoizedState, a !== null && a.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(i(340));
          Gn();
        }
        return a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 19:
        return hn(vt), null;
      case 4:
        return Il(), null;
      case 10:
        return Pl(l.type._context), null;
      case 22:
      case 23:
        return bm(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ff = !1, Er = !1, cg = typeof WeakSet == "function" ? WeakSet : Set, Ke = null;
  function Wu(a, l) {
    var d = a.ref;
    if (d !== null)
      if (typeof d == "function")
        try {
          d(null);
        } catch (m) {
          or(a, l, m);
        }
      else
        d.current = null;
  }
  function df(a, l, d) {
    try {
      d();
    } catch (m) {
      or(a, l, m);
    }
  }
  var fg = !1;
  function dg(a, l) {
    if (zh = ma, a = ld(), Po(a)) {
      if ("selectionStart" in a)
        var d = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          d = (d = a.ownerDocument) && d.defaultView || window;
          var m = d.getSelection && d.getSelection();
          if (m && m.rangeCount !== 0) {
            d = m.anchorNode;
            var g = m.anchorOffset, _ = m.focusNode;
            m = m.focusOffset;
            try {
              d.nodeType, _.nodeType;
            } catch {
              d = null;
              break e;
            }
            var D = 0, $ = -1, B = -1, ae = 0, Se = 0, _e = a, be = null;
            t:
              for (; ; ) {
                for (var He; _e !== d || g !== 0 && _e.nodeType !== 3 || ($ = D + g), _e !== _ || m !== 0 && _e.nodeType !== 3 || (B = D + m), _e.nodeType === 3 && (D += _e.nodeValue.length), (He = _e.firstChild) !== null; )
                  be = _e, _e = He;
                for (; ; ) {
                  if (_e === a)
                    break t;
                  if (be === d && ++ae === g && ($ = D), be === _ && ++Se === m && (B = D), (He = _e.nextSibling) !== null)
                    break;
                  _e = be, be = _e.parentNode;
                }
                _e = He;
              }
            d = $ === -1 || B === -1 ? null : { start: $, end: B };
          } else
            d = null;
        }
      d = d || { start: 0, end: 0 };
    } else
      d = null;
    for (ws = { focusedElem: a, selectionRange: d }, ma = !1, Ke = l; Ke !== null; )
      if (l = Ke, a = l.child, (l.subtreeFlags & 1028) !== 0 && a !== null)
        a.return = l, Ke = a;
      else
        for (; Ke !== null; ) {
          l = Ke;
          try {
            var et = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (et !== null) {
                    var it = et.memoizedProps, cr = et.memoizedState, X = l.stateNode, Y = X.getSnapshotBeforeUpdate(l.elementType === l.type ? it : na(l.type, it), cr);
                    X.__reactInternalSnapshotBeforeUpdate = Y;
                  }
                  break;
                case 3:
                  var J = l.stateNode.containerInfo;
                  J.nodeType === 1 ? J.textContent = "" : J.nodeType === 9 && J.documentElement && J.removeChild(J.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(i(163));
              }
          } catch (Oe) {
            or(l, l.return, Oe);
          }
          if (a = l.sibling, a !== null) {
            a.return = l.return, Ke = a;
            break;
          }
          Ke = l.return;
        }
    return et = fg, fg = !1, et;
  }
  function pf(a, l, d) {
    var m = l.updateQueue;
    if (m = m !== null ? m.lastEffect : null, m !== null) {
      var g = m = m.next;
      do {
        if ((g.tag & a) === a) {
          var _ = g.destroy;
          g.destroy = void 0, _ !== void 0 && df(l, d, _);
        }
        g = g.next;
      } while (g !== m);
    }
  }
  function hf(a, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var d = l = l.next;
      do {
        if ((d.tag & a) === a) {
          var m = d.create;
          d.destroy = m();
        }
        d = d.next;
      } while (d !== l);
    }
  }
  function dm(a) {
    var l = a.ref;
    if (l !== null) {
      var d = a.stateNode;
      switch (a.tag) {
        case 5:
          a = d;
          break;
        default:
          a = d;
      }
      typeof l == "function" ? l(a) : l.current = a;
    }
  }
  function pm(a) {
    var l = a.alternate;
    l !== null && (a.alternate = null, pm(l)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (l = a.stateNode, l !== null && (delete l[co], delete l[Es], delete l[Ih], delete l[o1], delete l[Fh])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  function pg(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function Zd(a) {
    e:
      for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || pg(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
          if (a.flags & 2 || a.child === null || a.tag === 4)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2))
          return a.stateNode;
      }
  }
  function Yu(a, l, d) {
    var m = a.tag;
    if (m === 5 || m === 6)
      a = a.stateNode, l ? d.nodeType === 8 ? d.parentNode.insertBefore(a, l) : d.insertBefore(a, l) : (d.nodeType === 8 ? (l = d.parentNode, l.insertBefore(a, d)) : (l = d, l.appendChild(a)), d = d._reactRootContainer, d != null || l.onclick !== null || (l.onclick = pd));
    else if (m !== 4 && (a = a.child, a !== null))
      for (Yu(a, l, d), a = a.sibling; a !== null; )
        Yu(a, l, d), a = a.sibling;
  }
  function mo(a, l, d) {
    var m = a.tag;
    if (m === 5 || m === 6)
      a = a.stateNode, l ? d.insertBefore(a, l) : d.appendChild(a);
    else if (m !== 4 && (a = a.child, a !== null))
      for (mo(a, l, d), a = a.sibling; a !== null; )
        mo(a, l, d), a = a.sibling;
  }
  var Vn = null, Nr = !1;
  function Ca(a, l, d) {
    for (d = d.child; d !== null; )
      Zu(a, l, d), d = d.sibling;
  }
  function Zu(a, l, d) {
    if (Ri && typeof Ri.onCommitFiberUnmount == "function")
      try {
        Ri.onCommitFiberUnmount(yl, d);
      } catch {
      }
    switch (d.tag) {
      case 5:
        Er || Wu(d, l);
      case 6:
        var m = Vn, g = Nr;
        Vn = null, Ca(a, l, d), Vn = m, Nr = g, Vn !== null && (Nr ? (a = Vn, d = d.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(d) : a.removeChild(d)) : Vn.removeChild(d.stateNode));
        break;
      case 18:
        Vn !== null && (Nr ? (a = Vn, d = d.stateNode, a.nodeType === 8 ? Ol(a.parentNode, d) : a.nodeType === 1 && Ol(a, d), El(a)) : Ol(Vn, d.stateNode));
        break;
      case 4:
        m = Vn, g = Nr, Vn = d.stateNode.containerInfo, Nr = !0, Ca(a, l, d), Vn = m, Nr = g;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Er && (m = d.updateQueue, m !== null && (m = m.lastEffect, m !== null))) {
          g = m = m.next;
          do {
            var _ = g, D = _.destroy;
            _ = _.tag, D !== void 0 && (_ & 2 || _ & 4) && df(d, l, D), g = g.next;
          } while (g !== m);
        }
        Ca(a, l, d);
        break;
      case 1:
        if (!Er && (Wu(d, l), m = d.stateNode, typeof m.componentWillUnmount == "function"))
          try {
            m.props = d.memoizedProps, m.state = d.memoizedState, m.componentWillUnmount();
          } catch ($) {
            or(d, l, $);
          }
        Ca(a, l, d);
        break;
      case 21:
        Ca(a, l, d);
        break;
      case 22:
        d.mode & 1 ? (Er = (m = Er) || d.memoizedState !== null, Ca(a, l, d), Er = m) : Ca(a, l, d);
        break;
      default:
        Ca(a, l, d);
    }
  }
  function Vo(a) {
    var l = a.updateQueue;
    if (l !== null) {
      a.updateQueue = null;
      var d = a.stateNode;
      d === null && (d = a.stateNode = new cg()), l.forEach(function(m) {
        var g = b1.bind(null, a, m);
        d.has(m) || (d.add(m), m.then(g, g));
      });
    }
  }
  function Za(a, l) {
    var d = l.deletions;
    if (d !== null)
      for (var m = 0; m < d.length; m++) {
        var g = d[m];
        try {
          var _ = a, D = l, $ = D;
          e:
            for (; $ !== null; ) {
              switch ($.tag) {
                case 5:
                  Vn = $.stateNode, Nr = !1;
                  break e;
                case 3:
                  Vn = $.stateNode.containerInfo, Nr = !0;
                  break e;
                case 4:
                  Vn = $.stateNode.containerInfo, Nr = !0;
                  break e;
              }
              $ = $.return;
            }
          if (Vn === null)
            throw Error(i(160));
          Zu(_, D, g), Vn = null, Nr = !1;
          var B = g.alternate;
          B !== null && (B.return = null), g.return = null;
        } catch (ae) {
          or(g, l, ae);
        }
      }
    if (l.subtreeFlags & 12854)
      for (l = l.child; l !== null; )
        hg(l, a), l = l.sibling;
  }
  function hg(a, l) {
    var d = a.alternate, m = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Za(l, a), vo(a), m & 4) {
          try {
            pf(3, a, a.return), hf(3, a);
          } catch (it) {
            or(a, a.return, it);
          }
          try {
            pf(5, a, a.return);
          } catch (it) {
            or(a, a.return, it);
          }
        }
        break;
      case 1:
        Za(l, a), vo(a), m & 512 && d !== null && Wu(d, d.return);
        break;
      case 5:
        if (Za(l, a), vo(a), m & 512 && d !== null && Wu(d, d.return), a.flags & 32) {
          var g = a.stateNode;
          try {
            $n(g, "");
          } catch (it) {
            or(a, a.return, it);
          }
        }
        if (m & 4 && (g = a.stateNode, g != null)) {
          var _ = a.memoizedProps, D = d !== null ? d.memoizedProps : _, $ = a.type, B = a.updateQueue;
          if (a.updateQueue = null, B !== null)
            try {
              $ === "input" && _.type === "radio" && _.name != null && nr(g, _), sn($, D);
              var ae = sn($, _);
              for (D = 0; D < B.length; D += 2) {
                var Se = B[D], _e = B[D + 1];
                Se === "style" ? qt(g, _e) : Se === "dangerouslySetInnerHTML" ? It(g, _e) : Se === "children" ? $n(g, _e) : G(g, Se, _e, ae);
              }
              switch ($) {
                case "input":
                  Zn(g, _);
                  break;
                case "textarea":
                  ci(g, _);
                  break;
                case "select":
                  var be = g._wrapperState.wasMultiple;
                  g._wrapperState.wasMultiple = !!_.multiple;
                  var He = _.value;
                  He != null ? Tr(g, !!_.multiple, He, !1) : be !== !!_.multiple && (_.defaultValue != null ? Tr(
                    g,
                    !!_.multiple,
                    _.defaultValue,
                    !0
                  ) : Tr(g, !!_.multiple, _.multiple ? [] : "", !1));
              }
              g[Es] = _;
            } catch (it) {
              or(a, a.return, it);
            }
        }
        break;
      case 6:
        if (Za(l, a), vo(a), m & 4) {
          if (a.stateNode === null)
            throw Error(i(162));
          g = a.stateNode, _ = a.memoizedProps;
          try {
            g.nodeValue = _;
          } catch (it) {
            or(a, a.return, it);
          }
        }
        break;
      case 3:
        if (Za(l, a), vo(a), m & 4 && d !== null && d.memoizedState.isDehydrated)
          try {
            El(l.containerInfo);
          } catch (it) {
            or(a, a.return, it);
          }
        break;
      case 4:
        Za(l, a), vo(a);
        break;
      case 13:
        Za(l, a), vo(a), g = a.child, g.flags & 8192 && (_ = g.memoizedState !== null, g.stateNode.isHidden = _, !_ || g.alternate !== null && g.alternate.memoizedState !== null || (vm = an())), m & 4 && Vo(a);
        break;
      case 22:
        if (Se = d !== null && d.memoizedState !== null, a.mode & 1 ? (Er = (ae = Er) || Se, Za(l, a), Er = ae) : Za(l, a), vo(a), m & 8192) {
          if (ae = a.memoizedState !== null, (a.stateNode.isHidden = ae) && !Se && a.mode & 1)
            for (Ke = a, Se = a.child; Se !== null; ) {
              for (_e = Ke = Se; Ke !== null; ) {
                switch (be = Ke, He = be.child, be.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    pf(4, be, be.return);
                    break;
                  case 1:
                    Wu(be, be.return);
                    var et = be.stateNode;
                    if (typeof et.componentWillUnmount == "function") {
                      m = be, d = be.return;
                      try {
                        l = m, et.props = l.memoizedProps, et.state = l.memoizedState, et.componentWillUnmount();
                      } catch (it) {
                        or(m, d, it);
                      }
                    }
                    break;
                  case 5:
                    Wu(be, be.return);
                    break;
                  case 22:
                    if (be.memoizedState !== null) {
                      hm(_e);
                      continue;
                    }
                }
                He !== null ? (He.return = be, Ke = He) : hm(_e);
              }
              Se = Se.sibling;
            }
          e:
            for (Se = null, _e = a; ; ) {
              if (_e.tag === 5) {
                if (Se === null) {
                  Se = _e;
                  try {
                    g = _e.stateNode, ae ? (_ = g.style, typeof _.setProperty == "function" ? _.setProperty("display", "none", "important") : _.display = "none") : ($ = _e.stateNode, B = _e.memoizedProps.style, D = B != null && B.hasOwnProperty("display") ? B.display : null, $.style.display = Ct("display", D));
                  } catch (it) {
                    or(a, a.return, it);
                  }
                }
              } else if (_e.tag === 6) {
                if (Se === null)
                  try {
                    _e.stateNode.nodeValue = ae ? "" : _e.memoizedProps;
                  } catch (it) {
                    or(a, a.return, it);
                  }
              } else if ((_e.tag !== 22 && _e.tag !== 23 || _e.memoizedState === null || _e === a) && _e.child !== null) {
                _e.child.return = _e, _e = _e.child;
                continue;
              }
              if (_e === a)
                break e;
              for (; _e.sibling === null; ) {
                if (_e.return === null || _e.return === a)
                  break e;
                Se === _e && (Se = null), _e = _e.return;
              }
              Se === _e && (Se = null), _e.sibling.return = _e.return, _e = _e.sibling;
            }
        }
        break;
      case 19:
        Za(l, a), vo(a), m & 4 && Vo(a);
        break;
      case 21:
        break;
      default:
        Za(
          l,
          a
        ), vo(a);
    }
  }
  function vo(a) {
    var l = a.flags;
    if (l & 2) {
      try {
        e: {
          for (var d = a.return; d !== null; ) {
            if (pg(d)) {
              var m = d;
              break e;
            }
            d = d.return;
          }
          throw Error(i(160));
        }
        switch (m.tag) {
          case 5:
            var g = m.stateNode;
            m.flags & 32 && ($n(g, ""), m.flags &= -33);
            var _ = Zd(a);
            mo(a, _, g);
            break;
          case 3:
          case 4:
            var D = m.stateNode.containerInfo, $ = Zd(a);
            Yu(a, $, D);
            break;
          default:
            throw Error(i(161));
        }
      } catch (B) {
        or(a, a.return, B);
      }
      a.flags &= -3;
    }
    l & 4096 && (a.flags &= -4097);
  }
  function mg(a, l, d) {
    Ke = a, qu(a);
  }
  function qu(a, l, d) {
    for (var m = (a.mode & 1) !== 0; Ke !== null; ) {
      var g = Ke, _ = g.child;
      if (g.tag === 22 && m) {
        var D = g.memoizedState !== null || ff;
        if (!D) {
          var $ = g.alternate, B = $ !== null && $.memoizedState !== null || Er;
          $ = ff;
          var ae = Er;
          if (ff = D, (Er = B) && !ae)
            for (Ke = g; Ke !== null; )
              D = Ke, B = D.child, D.tag === 22 && D.memoizedState !== null ? yg(g) : B !== null ? (B.return = D, Ke = B) : yg(g);
          for (; _ !== null; )
            Ke = _, qu(_), _ = _.sibling;
          Ke = g, ff = $, Er = ae;
        }
        vg(a);
      } else
        g.subtreeFlags & 8772 && _ !== null ? (_.return = g, Ke = _) : vg(a);
    }
  }
  function vg(a) {
    for (; Ke !== null; ) {
      var l = Ke;
      if (l.flags & 8772) {
        var d = l.alternate;
        try {
          if (l.flags & 8772)
            switch (l.tag) {
              case 0:
              case 11:
              case 15:
                Er || hf(5, l);
                break;
              case 1:
                var m = l.stateNode;
                if (l.flags & 4 && !Er)
                  if (d === null)
                    m.componentDidMount();
                  else {
                    var g = l.elementType === l.type ? d.memoizedProps : na(l.type, d.memoizedProps);
                    m.componentDidUpdate(g, d.memoizedState, m.__reactInternalSnapshotBeforeUpdate);
                  }
                var _ = l.updateQueue;
                _ !== null && ks(l, _, m);
                break;
              case 3:
                var D = l.updateQueue;
                if (D !== null) {
                  if (d = null, l.child !== null)
                    switch (l.child.tag) {
                      case 5:
                        d = l.child.stateNode;
                        break;
                      case 1:
                        d = l.child.stateNode;
                    }
                  ks(l, D, d);
                }
                break;
              case 5:
                var $ = l.stateNode;
                if (d === null && l.flags & 4) {
                  d = $;
                  var B = l.memoizedProps;
                  switch (l.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      B.autoFocus && d.focus();
                      break;
                    case "img":
                      B.src && (d.src = B.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (l.memoizedState === null) {
                  var ae = l.alternate;
                  if (ae !== null) {
                    var Se = ae.memoizedState;
                    if (Se !== null) {
                      var _e = Se.dehydrated;
                      _e !== null && El(_e);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(i(163));
            }
          Er || l.flags & 512 && dm(l);
        } catch (be) {
          or(l, l.return, be);
        }
      }
      if (l === a) {
        Ke = null;
        break;
      }
      if (d = l.sibling, d !== null) {
        d.return = l.return, Ke = d;
        break;
      }
      Ke = l.return;
    }
  }
  function hm(a) {
    for (; Ke !== null; ) {
      var l = Ke;
      if (l === a) {
        Ke = null;
        break;
      }
      var d = l.sibling;
      if (d !== null) {
        d.return = l.return, Ke = d;
        break;
      }
      Ke = l.return;
    }
  }
  function yg(a) {
    for (; Ke !== null; ) {
      var l = Ke;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var d = l.return;
            try {
              hf(4, l);
            } catch (B) {
              or(l, d, B);
            }
            break;
          case 1:
            var m = l.stateNode;
            if (typeof m.componentDidMount == "function") {
              var g = l.return;
              try {
                m.componentDidMount();
              } catch (B) {
                or(l, g, B);
              }
            }
            var _ = l.return;
            try {
              dm(l);
            } catch (B) {
              or(l, _, B);
            }
            break;
          case 5:
            var D = l.return;
            try {
              dm(l);
            } catch (B) {
              or(l, D, B);
            }
        }
      } catch (B) {
        or(l, l.return, B);
      }
      if (l === a) {
        Ke = null;
        break;
      }
      var $ = l.sibling;
      if ($ !== null) {
        $.return = l.return, Ke = $;
        break;
      }
      Ke = l.return;
    }
  }
  var qd = Math.ceil, mf = te.ReactCurrentDispatcher, mm = te.ReactCurrentOwner, ai = te.ReactCurrentBatchConfig, Gt = 0, Qn = null, ar = null, Lr = 0, ia = 0, Gu = Pt(0), Cr = 0, vf = null, Wo = 0, Gd = 0, Xu = 0, js = null, vi = null, vm = 0, Qu = 1 / 0, Yo = null, Xd = !1, Is = null, yo = null, Hl = !1, Vl = null, Qd = 0, Ku = 0, Kd = null, Fs = -1, Us = 0;
  function oi() {
    return Gt & 6 ? an() : Fs !== -1 ? Fs : Fs = an();
  }
  function br(a) {
    return a.mode & 1 ? Gt & 2 && Lr !== 0 ? Lr & -Lr : bd.transition !== null ? (Us === 0 && (Us = bu()), Us) : (a = cn, a !== 0 || (a = window.event, a = a === void 0 ? 16 : $c(a.type)), a) : 1;
  }
  function li(a, l, d, m) {
    if (50 < Ku)
      throw Ku = 0, Kd = null, Error(i(185));
    Ao(a, d, m), (!(Gt & 2) || a !== Qn) && (a === Qn && (!(Gt & 2) && (Gd |= d), Cr === 4 && ka(a, Lr)), si(a, m), d === 1 && Gt === 0 && !(l.mode & 1) && (Qu = an() + 500, Dr && Ni()));
  }
  function si(a, l) {
    var d = a.callbackNode;
    Sl(a, l);
    var m = hi(a, a === Qn ? Lr : 0);
    if (m === 0)
      d !== null && Fr(d), a.callbackNode = null, a.callbackPriority = 0;
    else if (l = m & -m, a.callbackPriority !== l) {
      if (d != null && Fr(d), l === 1)
        a.tag === 0 ? Bh(gg.bind(null, a)) : Uh(gg.bind(null, a)), jh(function() {
          !(Gt & 6) && Ni();
        }), d = null;
      else {
        switch (xu(m)) {
          case 1:
            d = Ia;
            break;
          case 4:
            d = Ft;
            break;
          case 16:
            d = lo;
            break;
          case 536870912:
            d = yu;
            break;
          default:
            d = lo;
        }
        d = wm(d, Ju.bind(null, a));
      }
      a.callbackPriority = l, a.callbackNode = d;
    }
  }
  function Ju(a, l) {
    if (Fs = -1, Us = 0, Gt & 6)
      throw Error(i(327));
    var d = a.callbackNode;
    if (tc() && a.callbackNode !== d)
      return null;
    var m = hi(a, a === Qn ? Lr : 0);
    if (m === 0)
      return null;
    if (m & 30 || m & a.expiredLanes || l)
      l = ep(a, m);
    else {
      l = m;
      var g = Gt;
      Gt |= 2;
      var _ = Jd();
      (Qn !== a || Lr !== l) && (Yo = null, Qu = an() + 500, Bs(a, l));
      do
        try {
          m1();
          break;
        } catch ($) {
          bg(a, $);
        }
      while (!0);
      qh(), mf.current = _, Gt = g, ar !== null ? l = 0 : (Qn = null, Lr = 0, l = Cr);
    }
    if (l !== 0) {
      if (l === 2 && (g = xl(a), g !== 0 && (m = g, l = ym(a, g))), l === 1)
        throw d = vf, Bs(a, 0), ka(a, m), si(a, an()), d;
      if (l === 6)
        ka(a, m);
      else {
        if (g = a.current.alternate, !(m & 30) && !gm(g) && (l = ep(a, m), l === 2 && (_ = xl(a), _ !== 0 && (m = _, l = ym(a, _))), l === 1))
          throw d = vf, Bs(a, 0), ka(a, m), si(a, an()), d;
        switch (a.finishedWork = g, a.finishedLanes = m, l) {
          case 0:
          case 1:
            throw Error(i(345));
          case 2:
            Hs(a, vi, Yo);
            break;
          case 3:
            if (ka(a, m), (m & 130023424) === m && (l = vm + 500 - an(), 10 < l)) {
              if (hi(a, 0) !== 0)
                break;
              if (g = a.suspendedLanes, (g & m) !== m) {
                oi(), a.pingedLanes |= a.suspendedLanes & g;
                break;
              }
              a.timeoutHandle = _s(Hs.bind(null, a, vi, Yo), l);
              break;
            }
            Hs(a, vi, Yo);
            break;
          case 4:
            if (ka(a, m), (m & 4194240) === m)
              break;
            for (l = a.eventTimes, g = -1; 0 < m; ) {
              var D = 31 - pi(m);
              _ = 1 << D, D = l[D], D > g && (g = D), m &= ~_;
            }
            if (m = g, m = an() - m, m = (120 > m ? 120 : 480 > m ? 480 : 1080 > m ? 1080 : 1920 > m ? 1920 : 3e3 > m ? 3e3 : 4320 > m ? 4320 : 1960 * qd(m / 1960)) - m, 10 < m) {
              a.timeoutHandle = _s(Hs.bind(null, a, vi, Yo), m);
              break;
            }
            Hs(a, vi, Yo);
            break;
          case 5:
            Hs(a, vi, Yo);
            break;
          default:
            throw Error(i(329));
        }
      }
    }
    return si(a, an()), a.callbackNode === d ? Ju.bind(null, a) : null;
  }
  function ym(a, l) {
    var d = js;
    return a.current.memoizedState.isDehydrated && (Bs(a, l).flags |= 256), a = ep(a, l), a !== 2 && (l = vi, vi = d, l !== null && yf(l)), a;
  }
  function yf(a) {
    vi === null ? vi = a : vi.push.apply(vi, a);
  }
  function gm(a) {
    for (var l = a; ; ) {
      if (l.flags & 16384) {
        var d = l.updateQueue;
        if (d !== null && (d = d.stores, d !== null))
          for (var m = 0; m < d.length; m++) {
            var g = d[m], _ = g.getSnapshot;
            g = g.value;
            try {
              if (!va(_(), g))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (d = l.child, l.subtreeFlags & 16384 && d !== null)
        d.return = l, l = d;
      else {
        if (l === a)
          break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function ka(a, l) {
    for (l &= ~Xu, l &= ~Gd, a.suspendedLanes |= l, a.pingedLanes &= ~l, a = a.expirationTimes; 0 < l; ) {
      var d = 31 - pi(l), m = 1 << d;
      a[d] = -1, l &= ~m;
    }
  }
  function gg(a) {
    if (Gt & 6)
      throw Error(i(327));
    tc();
    var l = hi(a, 0);
    if (!(l & 1))
      return si(a, an()), null;
    var d = ep(a, l);
    if (a.tag !== 0 && d === 2) {
      var m = xl(a);
      m !== 0 && (l = m, d = ym(a, m));
    }
    if (d === 1)
      throw d = vf, Bs(a, 0), ka(a, l), si(a, an()), d;
    if (d === 6)
      throw Error(i(345));
    return a.finishedWork = a.current.alternate, a.finishedLanes = l, Hs(a, vi, Yo), si(a, an()), null;
  }
  function ec(a, l) {
    var d = Gt;
    Gt |= 1;
    try {
      return a(l);
    } finally {
      Gt = d, Gt === 0 && (Qu = an() + 500, Dr && Ni());
    }
  }
  function Wl(a) {
    Vl !== null && Vl.tag === 0 && !(Gt & 6) && tc();
    var l = Gt;
    Gt |= 1;
    var d = ai.transition, m = cn;
    try {
      if (ai.transition = null, cn = 1, a)
        return a();
    } finally {
      cn = m, ai.transition = d, Gt = l, !(Gt & 6) && Ni();
    }
  }
  function bm() {
    ia = Gu.current, hn(Gu);
  }
  function Bs(a, l) {
    a.finishedWork = null, a.finishedLanes = 0;
    var d = a.timeoutHandle;
    if (d !== -1 && (a.timeoutHandle = -1, Yy(d)), ar !== null)
      for (d = ar.return; d !== null; ) {
        var m = d;
        switch (Vh(m), m.tag) {
          case 1:
            m = m.type.childContextTypes, m != null && ba();
            break;
          case 3:
            Il(), hn(ir), hn(_t), Cd();
            break;
          case 5:
            Bt(m);
            break;
          case 4:
            Il();
            break;
          case 13:
            hn(vt);
            break;
          case 19:
            hn(vt);
            break;
          case 10:
            Pl(m.type._context);
            break;
          case 22:
          case 23:
            bm();
        }
        d = d.return;
      }
    if (Qn = a, ar = a = Yl(a.current, null), Lr = ia = l, Cr = 0, vf = null, Xu = Gd = Wo = 0, vi = js = null, Br !== null) {
      for (l = 0; l < Br.length; l++)
        if (d = Br[l], m = d.interleaved, m !== null) {
          d.interleaved = null;
          var g = m.next, _ = d.pending;
          if (_ !== null) {
            var D = _.next;
            _.next = g, m.next = D;
          }
          d.pending = m;
        }
      Br = null;
    }
    return a;
  }
  function bg(a, l) {
    do {
      var d = ar;
      try {
        if (qh(), kd.current = Bd, bt) {
          for (var m = Fn.memoizedState; m !== null; ) {
            var g = m.queue;
            g !== null && (g.pending = null), m = m.next;
          }
          bt = !1;
        }
        if (Rs = 0, Jt = pe = Fn = null, ho = !1, ra = 0, mm.current = null, d === null || d.return === null) {
          Cr = 1, vf = l, ar = null;
          break;
        }
        e: {
          var _ = a, D = d.return, $ = d, B = l;
          if (l = Lr, $.flags |= 32768, B !== null && typeof B == "object" && typeof B.then == "function") {
            var ae = B, Se = $, _e = Se.tag;
            if (!(Se.mode & 1) && (_e === 0 || _e === 11 || _e === 15)) {
              var be = Se.alternate;
              be ? (Se.updateQueue = be.updateQueue, Se.memoizedState = be.memoizedState, Se.lanes = be.lanes) : (Se.updateQueue = null, Se.memoizedState = null);
            }
            var He = rm(D);
            if (He !== null) {
              He.flags &= -257, im(He, D, $, _, l), He.mode & 1 && lg(_, ae, l), l = He, B = ae;
              var et = l.updateQueue;
              if (et === null) {
                var it = /* @__PURE__ */ new Set();
                it.add(B), l.updateQueue = it;
              } else
                et.add(B);
              break e;
            } else {
              if (!(l & 1)) {
                lg(_, ae, l), Sm();
                break e;
              }
              B = Error(i(426));
            }
          } else if (In && $.mode & 1) {
            var cr = rm(D);
            if (cr !== null) {
              !(cr.flags & 65536) && (cr.flags |= 256), im(cr, D, $, _, l), Yh(Bu(B, $));
              break e;
            }
          }
          _ = B = Bu(B, $), Cr !== 4 && (Cr = 2), js === null ? js = [_] : js.push(_), _ = D;
          do {
            switch (_.tag) {
              case 3:
                _.flags |= 65536, l &= -l, _.lanes |= l;
                var X = og(_, B, l);
                Qh(_, X);
                break e;
              case 1:
                $ = B;
                var Y = _.type, J = _.stateNode;
                if (!(_.flags & 128) && (typeof Y.getDerivedStateFromError == "function" || J !== null && typeof J.componentDidCatch == "function" && (yo === null || !yo.has(J)))) {
                  _.flags |= 65536, l &= -l, _.lanes |= l;
                  var Oe = sf(_, $, l);
                  Qh(_, Oe);
                  break e;
                }
            }
            _ = _.return;
          } while (_ !== null);
        }
        xm(d);
      } catch (ot) {
        l = ot, ar === d && d !== null && (ar = d = d.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Jd() {
    var a = mf.current;
    return mf.current = Bd, a === null ? Bd : a;
  }
  function Sm() {
    (Cr === 0 || Cr === 3 || Cr === 2) && (Cr = 4), Qn === null || !(Wo & 268435455) && !(Gd & 268435455) || ka(Qn, Lr);
  }
  function ep(a, l) {
    var d = Gt;
    Gt |= 2;
    var m = Jd();
    (Qn !== a || Lr !== l) && (Yo = null, Bs(a, l));
    do
      try {
        h1();
        break;
      } catch (g) {
        bg(a, g);
      }
    while (!0);
    if (qh(), Gt = d, mf.current = m, ar !== null)
      throw Error(i(261));
    return Qn = null, Lr = 0, Cr;
  }
  function h1() {
    for (; ar !== null; )
      Sg(ar);
  }
  function m1() {
    for (; ar !== null && !oo(); )
      Sg(ar);
  }
  function Sg(a) {
    var l = wg(a.alternate, a, ia);
    a.memoizedProps = a.pendingProps, l === null ? xm(a) : ar = l, mm.current = null;
  }
  function xm(a) {
    var l = a;
    do {
      var d = l.alternate;
      if (a = l.return, l.flags & 32768) {
        if (d = fm(d, l), d !== null) {
          d.flags &= 32767, ar = d;
          return;
        }
        if (a !== null)
          a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          Cr = 6, ar = null;
          return;
        }
      } else if (d = p1(d, l, ia), d !== null) {
        ar = d;
        return;
      }
      if (l = l.sibling, l !== null) {
        ar = l;
        return;
      }
      ar = l = a;
    } while (l !== null);
    Cr === 0 && (Cr = 5);
  }
  function Hs(a, l, d) {
    var m = cn, g = ai.transition;
    try {
      ai.transition = null, cn = 1, v1(a, l, d, m);
    } finally {
      ai.transition = g, cn = m;
    }
    return null;
  }
  function v1(a, l, d, m) {
    do
      tc();
    while (Vl !== null);
    if (Gt & 6)
      throw Error(i(327));
    d = a.finishedWork;
    var g = a.finishedLanes;
    if (d === null)
      return null;
    if (a.finishedWork = null, a.finishedLanes = 0, d === a.current)
      throw Error(i(177));
    a.callbackNode = null, a.callbackPriority = 0;
    var _ = d.lanes | d.childLanes;
    if (yh(a, _), a === Qn && (ar = Qn = null, Lr = 0), !(d.subtreeFlags & 2064) && !(d.flags & 2064) || Hl || (Hl = !0, wm(lo, function() {
      return tc(), null;
    })), _ = (d.flags & 15990) !== 0, d.subtreeFlags & 15990 || _) {
      _ = ai.transition, ai.transition = null;
      var D = cn;
      cn = 1;
      var $ = Gt;
      Gt |= 4, mm.current = null, dg(a, d), hg(d, a), sd(ws), ma = !!zh, ws = zh = null, a.current = d, mg(d), vu(), Gt = $, cn = D, ai.transition = _;
    } else
      a.current = d;
    if (Hl && (Hl = !1, Vl = a, Qd = g), _ = a.pendingLanes, _ === 0 && (yo = null), Lc(d.stateNode), si(a, an()), l !== null)
      for (m = a.onRecoverableError, d = 0; d < l.length; d++)
        g = l[d], m(g.value, { componentStack: g.stack, digest: g.digest });
    if (Xd)
      throw Xd = !1, a = Is, Is = null, a;
    return Qd & 1 && a.tag !== 0 && tc(), _ = a.pendingLanes, _ & 1 ? a === Kd ? Ku++ : (Ku = 0, Kd = a) : Ku = 0, Ni(), null;
  }
  function tc() {
    if (Vl !== null) {
      var a = xu(Qd), l = ai.transition, d = cn;
      try {
        if (ai.transition = null, cn = 16 > a ? 16 : a, Vl === null)
          var m = !1;
        else {
          if (a = Vl, Vl = null, Qd = 0, Gt & 6)
            throw Error(i(331));
          var g = Gt;
          for (Gt |= 4, Ke = a.current; Ke !== null; ) {
            var _ = Ke, D = _.child;
            if (Ke.flags & 16) {
              var $ = _.deletions;
              if ($ !== null) {
                for (var B = 0; B < $.length; B++) {
                  var ae = $[B];
                  for (Ke = ae; Ke !== null; ) {
                    var Se = Ke;
                    switch (Se.tag) {
                      case 0:
                      case 11:
                      case 15:
                        pf(8, Se, _);
                    }
                    var _e = Se.child;
                    if (_e !== null)
                      _e.return = Se, Ke = _e;
                    else
                      for (; Ke !== null; ) {
                        Se = Ke;
                        var be = Se.sibling, He = Se.return;
                        if (pm(Se), Se === ae) {
                          Ke = null;
                          break;
                        }
                        if (be !== null) {
                          be.return = He, Ke = be;
                          break;
                        }
                        Ke = He;
                      }
                  }
                }
                var et = _.alternate;
                if (et !== null) {
                  var it = et.child;
                  if (it !== null) {
                    et.child = null;
                    do {
                      var cr = it.sibling;
                      it.sibling = null, it = cr;
                    } while (it !== null);
                  }
                }
                Ke = _;
              }
            }
            if (_.subtreeFlags & 2064 && D !== null)
              D.return = _, Ke = D;
            else
              e:
                for (; Ke !== null; ) {
                  if (_ = Ke, _.flags & 2048)
                    switch (_.tag) {
                      case 0:
                      case 11:
                      case 15:
                        pf(9, _, _.return);
                    }
                  var X = _.sibling;
                  if (X !== null) {
                    X.return = _.return, Ke = X;
                    break e;
                  }
                  Ke = _.return;
                }
          }
          var Y = a.current;
          for (Ke = Y; Ke !== null; ) {
            D = Ke;
            var J = D.child;
            if (D.subtreeFlags & 2064 && J !== null)
              J.return = D, Ke = J;
            else
              e:
                for (D = Y; Ke !== null; ) {
                  if ($ = Ke, $.flags & 2048)
                    try {
                      switch ($.tag) {
                        case 0:
                        case 11:
                        case 15:
                          hf(9, $);
                      }
                    } catch (ot) {
                      or($, $.return, ot);
                    }
                  if ($ === D) {
                    Ke = null;
                    break e;
                  }
                  var Oe = $.sibling;
                  if (Oe !== null) {
                    Oe.return = $.return, Ke = Oe;
                    break e;
                  }
                  Ke = $.return;
                }
          }
          if (Gt = g, Ni(), Ri && typeof Ri.onPostCommitFiberRoot == "function")
            try {
              Ri.onPostCommitFiberRoot(yl, a);
            } catch {
            }
          m = !0;
        }
        return m;
      } finally {
        cn = d, ai.transition = l;
      }
    }
    return !1;
  }
  function xg(a, l, d) {
    l = Bu(d, l), l = og(a, l, 1), a = $l(a, l, 1), l = oi(), a !== null && (Ao(a, 1, l), si(a, l));
  }
  function or(a, l, d) {
    if (a.tag === 3)
      xg(a, a, d);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          xg(l, a, d);
          break;
        } else if (l.tag === 1) {
          var m = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (yo === null || !yo.has(m))) {
            a = Bu(d, a), a = sf(l, a, 1), l = $l(l, a, 1), a = oi(), l !== null && (Ao(l, 1, a), si(l, a));
            break;
          }
        }
        l = l.return;
      }
  }
  function y1(a, l, d) {
    var m = a.pingCache;
    m !== null && m.delete(l), l = oi(), a.pingedLanes |= a.suspendedLanes & d, Qn === a && (Lr & d) === d && (Cr === 4 || Cr === 3 && (Lr & 130023424) === Lr && 500 > an() - vm ? Bs(a, 0) : Xu |= d), si(a, l);
  }
  function tp(a, l) {
    l === 0 && (a.mode & 1 ? (l = gl, gl <<= 1, !(gl & 130023424) && (gl = 4194304)) : l = 1);
    var d = oi();
    a = Fo(a, l), a !== null && (Ao(a, l, d), si(a, d));
  }
  function g1(a) {
    var l = a.memoizedState, d = 0;
    l !== null && (d = l.retryLane), tp(a, d);
  }
  function b1(a, l) {
    var d = 0;
    switch (a.tag) {
      case 13:
        var m = a.stateNode, g = a.memoizedState;
        g !== null && (d = g.retryLane);
        break;
      case 19:
        m = a.stateNode;
        break;
      default:
        throw Error(i(314));
    }
    m !== null && m.delete(l), tp(a, d);
  }
  var wg;
  wg = function(a, l, d) {
    if (a !== null)
      if (a.memoizedProps !== l.pendingProps || ir.current)
        gr = !0;
      else {
        if (!(a.lanes & d) && !(l.flags & 128))
          return gr = !1, Ho(a, l, d);
        gr = !!(a.flags & 131072);
      }
    else
      gr = !1, In && l.flags & 1048576 && Hh(l, Pu, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var m = l.type;
        ri(a, l), a = l.pendingProps;
        var g = ga(l, _t.current);
        $e(l, d), g = Fl(null, l, m, a, g, d);
        var _ = Ds();
        return l.flags |= 1, typeof g == "object" && g !== null && typeof g.render == "function" && g.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, Hn(m) ? (_ = !0, hd(l)) : _ = !1, l.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, Xh(l), g.updater = wd, l.stateNode = g, g._reactInternals = l, _d(l, m, a, d), l = sg(null, l, m, !0, _, d)) : (l.tag = 0, In && _ && md(l), wr(null, l, g, d), l = l.child), l;
      case 16:
        m = l.elementType;
        e: {
          switch (ri(a, l), a = l.pendingProps, g = m._init, m = g(m._payload), l.type = m, g = l.tag = x1(m), a = na(m, a), g) {
            case 0:
              l = Hu(null, l, m, a, d);
              break e;
            case 1:
              l = am(null, l, m, a, d);
              break e;
            case 11:
              l = Bl(null, l, m, a, d);
              break e;
            case 14:
              l = Vd(null, l, m, na(m.type, a), d);
              break e;
          }
          throw Error(i(
            306,
            m,
            ""
          ));
        }
        return l;
      case 0:
        return m = l.type, g = l.pendingProps, g = l.elementType === m ? g : na(m, g), Hu(a, l, m, g, d);
      case 1:
        return m = l.type, g = l.pendingProps, g = l.elementType === m ? g : na(m, g), am(a, l, m, g, d);
      case 3:
        e: {
          if (ug(l), a === null)
            throw Error(i(387));
          m = l.pendingProps, _ = l.memoizedState, g = _.element, xr(a, l), jl(l, m, null, d);
          var D = l.memoizedState;
          if (m = D.element, _.isDehydrated)
            if (_ = { element: m, isDehydrated: !1, cache: D.cache, pendingSuspenseBoundaries: D.pendingSuspenseBoundaries, transitions: D.transitions }, l.updateQueue.baseState = _, l.memoizedState = _, l.flags & 256) {
              g = Bu(Error(i(423)), l), l = Wd(a, l, m, d, g);
              break e;
            } else if (m !== g) {
              g = Bu(Error(i(424)), l), l = Wd(a, l, m, d, g);
              break e;
            } else
              for (zi = Wa(l.stateNode.containerInfo.firstChild), ta = l, In = !0, xa = null, d = ig(l, null, m, d), l.child = d; d; )
                d.flags = d.flags & -3 | 4096, d = d.sibling;
          else {
            if (Gn(), m === g) {
              l = Hr(a, l, d);
              break e;
            }
            wr(a, l, m, d);
          }
          l = l.child;
        }
        return l;
      case 5:
        return ht(l), a === null && yd(l), m = l.type, g = l.pendingProps, _ = a !== null ? a.memoizedProps : null, D = g.children, Gc(m, g) ? D = null : _ !== null && Gc(m, _) && (l.flags |= 32), zt(a, l), wr(a, l, D, d), l.child;
      case 6:
        return a === null && yd(l), null;
      case 13:
        return lm(a, l, d);
      case 4:
        return Jh(l, l.stateNode.containerInfo), m = l.pendingProps, a === null ? l.child = $u(l, null, m, d) : wr(a, l, m, d), l.child;
      case 11:
        return m = l.type, g = l.pendingProps, g = l.elementType === m ? g : na(m, g), Bl(a, l, m, g, d);
      case 7:
        return wr(a, l, l.pendingProps, d), l.child;
      case 8:
        return wr(a, l, l.pendingProps.children, d), l.child;
      case 12:
        return wr(a, l, l.pendingProps.children, d), l.child;
      case 10:
        e: {
          if (m = l.type._context, g = l.pendingProps, _ = l.memoizedProps, D = g.value, gn(po, m._currentValue), m._currentValue = D, _ !== null)
            if (va(_.value, D)) {
              if (_.children === g.children && !ir.current) {
                l = Hr(a, l, d);
                break e;
              }
            } else
              for (_ = l.child, _ !== null && (_.return = l); _ !== null; ) {
                var $ = _.dependencies;
                if ($ !== null) {
                  D = _.child;
                  for (var B = $.firstContext; B !== null; ) {
                    if (B.context === m) {
                      if (_.tag === 1) {
                        B = Uo(-1, d & -d), B.tag = 2;
                        var ae = _.updateQueue;
                        if (ae !== null) {
                          ae = ae.shared;
                          var Se = ae.pending;
                          Se === null ? B.next = B : (B.next = Se.next, Se.next = B), ae.pending = B;
                        }
                      }
                      _.lanes |= d, B = _.alternate, B !== null && (B.lanes |= d), Mr(
                        _.return,
                        d,
                        l
                      ), $.lanes |= d;
                      break;
                    }
                    B = B.next;
                  }
                } else if (_.tag === 10)
                  D = _.type === l.type ? null : _.child;
                else if (_.tag === 18) {
                  if (D = _.return, D === null)
                    throw Error(i(341));
                  D.lanes |= d, $ = D.alternate, $ !== null && ($.lanes |= d), Mr(D, d, l), D = _.sibling;
                } else
                  D = _.child;
                if (D !== null)
                  D.return = _;
                else
                  for (D = _; D !== null; ) {
                    if (D === l) {
                      D = null;
                      break;
                    }
                    if (_ = D.sibling, _ !== null) {
                      _.return = D.return, D = _;
                      break;
                    }
                    D = D.return;
                  }
                _ = D;
              }
          wr(a, l, g.children, d), l = l.child;
        }
        return l;
      case 9:
        return g = l.type, m = l.pendingProps.children, $e(l, d), g = ur(g), m = m(g), l.flags |= 1, wr(a, l, m, d), l.child;
      case 14:
        return m = l.type, g = na(m, l.pendingProps), g = na(m.type, g), Vd(a, l, m, g, d);
      case 15:
        return Ii(a, l, l.type, l.pendingProps, d);
      case 17:
        return m = l.type, g = l.pendingProps, g = l.elementType === m ? g : na(m, g), ri(a, l), l.tag = 1, Hn(m) ? (a = !0, hd(l)) : a = !1, $e(l, d), eg(l, m, g), _d(l, m, g, d), sg(null, l, m, !0, a, d);
      case 19:
        return cm(a, l, d);
      case 22:
        return Ps(a, l, d);
    }
    throw Error(i(156, l.tag));
  };
  function wm(a, l) {
    return Nn(a, l);
  }
  function S1(a, l, d, m) {
    this.tag = a, this.key = d, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ta(a, l, d, m) {
    return new S1(a, l, d, m);
  }
  function _m(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function x1(a) {
    if (typeof a == "function")
      return _m(a) ? 1 : 0;
    if (a != null) {
      if (a = a.$$typeof, a === ve)
        return 11;
      if (a === We)
        return 14;
    }
    return 2;
  }
  function Yl(a, l) {
    var d = a.alternate;
    return d === null ? (d = Ta(a.tag, l, a.key, a.mode), d.elementType = a.elementType, d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.pendingProps = l, d.type = a.type, d.flags = 0, d.subtreeFlags = 0, d.deletions = null), d.flags = a.flags & 14680064, d.childLanes = a.childLanes, d.lanes = a.lanes, d.child = a.child, d.memoizedProps = a.memoizedProps, d.memoizedState = a.memoizedState, d.updateQueue = a.updateQueue, l = a.dependencies, d.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, d.sibling = a.sibling, d.index = a.index, d.ref = a.ref, d;
  }
  function np(a, l, d, m, g, _) {
    var D = 2;
    if (m = a, typeof a == "function")
      _m(a) && (D = 1);
    else if (typeof a == "string")
      D = 5;
    else
      e:
        switch (a) {
          case ue:
            return Vs(d.children, g, _, l);
          case we:
            D = 8, g |= 8;
            break;
          case me:
            return a = Ta(12, d, l, g | 2), a.elementType = me, a.lanes = _, a;
          case Pe:
            return a = Ta(13, d, l, g), a.elementType = Pe, a.lanes = _, a;
          case Ue:
            return a = Ta(19, d, l, g), a.elementType = Ue, a.lanes = _, a;
          case Te:
            return gf(d, g, _, l);
          default:
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case Le:
                  D = 10;
                  break e;
                case xe:
                  D = 9;
                  break e;
                case ve:
                  D = 11;
                  break e;
                case We:
                  D = 14;
                  break e;
                case at:
                  D = 16, m = null;
                  break e;
              }
            throw Error(i(130, a == null ? a : typeof a, ""));
        }
    return l = Ta(D, d, l, g), l.elementType = a, l.type = m, l.lanes = _, l;
  }
  function Vs(a, l, d, m) {
    return a = Ta(7, a, m, l), a.lanes = d, a;
  }
  function gf(a, l, d, m) {
    return a = Ta(22, a, m, l), a.elementType = Te, a.lanes = d, a.stateNode = { isHidden: !1 }, a;
  }
  function bf(a, l, d) {
    return a = Ta(6, a, null, l), a.lanes = d, a;
  }
  function Ws(a, l, d) {
    return l = Ta(4, a.children !== null ? a.children : [], a.key, l), l.lanes = d, l.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, l;
  }
  function w1(a, l, d, m, g) {
    this.tag = l, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Su(0), this.expirationTimes = Su(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Su(0), this.identifierPrefix = m, this.onRecoverableError = g, this.mutableSourceEagerHydrationData = null;
  }
  function rp(a, l, d, m, g, _, D, $, B) {
    return a = new w1(a, l, d, $, B), l === 1 ? (l = 1, _ === !0 && (l |= 8)) : l = 0, _ = Ta(3, null, null, l), a.current = _, _.stateNode = a, _.memoizedState = { element: m, isDehydrated: d, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Xh(_), a;
  }
  function _g(a, l, d) {
    var m = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: V, key: m == null ? null : "" + m, children: a, containerInfo: l, implementation: d };
  }
  function Em(a) {
    if (!a)
      return fo;
    a = a._reactInternals;
    e: {
      if (Dt(a) !== a || a.tag !== 1)
        throw Error(i(170));
      var l = a;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (Hn(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(i(171));
    }
    if (a.tag === 1) {
      var d = a.type;
      if (Hn(d))
        return Kc(a, d, l);
    }
    return l;
  }
  function Eg(a, l, d, m, g, _, D, $, B) {
    return a = rp(d, m, !0, a, g, _, D, $, B), a.context = Em(null), d = a.current, m = oi(), g = br(d), _ = Uo(m, g), _.callback = l ?? null, $l(d, _, g), a.current.lanes = g, Ao(a, g, m), si(a, m), a;
  }
  function Sf(a, l, d, m) {
    var g = l.current, _ = oi(), D = br(g);
    return d = Em(d), l.context === null ? l.context = d : l.pendingContext = d, l = Uo(_, D), l.payload = { element: a }, m = m === void 0 ? null : m, m !== null && (l.callback = m), a = $l(g, l, D), a !== null && (li(a, g, D, _), xd(a, g, D)), D;
  }
  function ip(a) {
    if (a = a.current, !a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function Cg(a, l) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var d = a.retryLane;
      a.retryLane = d !== 0 && d < l ? d : l;
    }
  }
  function Cm(a, l) {
    Cg(a, l), (a = a.alternate) && Cg(a, l);
  }
  function kg() {
    return null;
  }
  var km = typeof reportError == "function" ? reportError : function(a) {
    console.error(a);
  };
  function ap(a) {
    this._internalRoot = a;
  }
  Zo.prototype.render = ap.prototype.render = function(a) {
    var l = this._internalRoot;
    if (l === null)
      throw Error(i(409));
    Sf(a, l, null, null);
  }, Zo.prototype.unmount = ap.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var l = a.containerInfo;
      Wl(function() {
        Sf(null, a, null, null);
      }), l[jo] = null;
    }
  };
  function Zo(a) {
    this._internalRoot = a;
  }
  Zo.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var l = _u();
      a = { blockedOn: null, target: a, priority: l };
      for (var d = 0; d < yn.length && l !== 0 && l < yn[d].priority; d++)
        ;
      yn.splice(d, 0, a), d === 0 && td(a);
    }
  };
  function Tm(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function op(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
  }
  function Tg() {
  }
  function _1(a, l, d, m, g) {
    if (g) {
      if (typeof m == "function") {
        var _ = m;
        m = function() {
          var ae = ip(D);
          _.call(ae);
        };
      }
      var D = Eg(l, m, a, 0, null, !1, !1, "", Tg);
      return a._reactRootContainer = D, a[jo] = D.current, Nu(a.nodeType === 8 ? a.parentNode : a), Wl(), D;
    }
    for (; g = a.lastChild; )
      a.removeChild(g);
    if (typeof m == "function") {
      var $ = m;
      m = function() {
        var ae = ip(B);
        $.call(ae);
      };
    }
    var B = rp(a, 0, !1, null, null, !1, !1, "", Tg);
    return a._reactRootContainer = B, a[jo] = B.current, Nu(a.nodeType === 8 ? a.parentNode : a), Wl(function() {
      Sf(l, B, d, m);
    }), B;
  }
  function lp(a, l, d, m, g) {
    var _ = d._reactRootContainer;
    if (_) {
      var D = _;
      if (typeof g == "function") {
        var $ = g;
        g = function() {
          var B = ip(D);
          $.call(B);
        };
      }
      Sf(l, D, a, g);
    } else
      D = _1(d, l, a, g, m);
    return ip(D);
  }
  ms = function(a) {
    switch (a.tag) {
      case 3:
        var l = a.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var d = Fa(l.pendingLanes);
          d !== 0 && (so(l, d | 1), si(l, an()), !(Gt & 6) && (Qu = an() + 500, Ni()));
        }
        break;
      case 13:
        Wl(function() {
          var m = Fo(a, 1);
          if (m !== null) {
            var g = oi();
            li(m, a, 1, g);
          }
        }), Cm(a, 1);
    }
  }, wu = function(a) {
    if (a.tag === 13) {
      var l = Fo(a, 134217728);
      if (l !== null) {
        var d = oi();
        li(l, a, 134217728, d);
      }
      Cm(a, 134217728);
    }
  }, on = function(a) {
    if (a.tag === 13) {
      var l = br(a), d = Fo(a, l);
      if (d !== null) {
        var m = oi();
        li(d, a, l, m);
      }
      Cm(a, l);
    }
  }, _u = function() {
    return cn;
  }, Eu = function(a, l) {
    var d = cn;
    try {
      return cn = a, l();
    } finally {
      cn = d;
    }
  }, fi = function(a, l, d) {
    switch (l) {
      case "input":
        if (Zn(a, d), l = d.name, d.type === "radio" && l != null) {
          for (d = a; d.parentNode; )
            d = d.parentNode;
          for (d = d.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < d.length; l++) {
            var m = d[l];
            if (m !== a && m.form === a.form) {
              var g = ct(m);
              if (!g)
                throw Error(i(90));
              Jr(m), Zn(m, g);
            }
          }
        }
        break;
      case "textarea":
        ci(a, d);
        break;
      case "select":
        l = d.value, l != null && Tr(a, !!d.multiple, l, !1);
    }
  }, hs = ec, mu = Wl;
  var E1 = { usingClientEntryPoint: !1, Events: [Qc, Lu, ct, pa, hl, ec] }, nc = { findFiberByHostInstance: ya, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, C1 = { bundleType: nc.bundleType, version: nc.version, rendererPackageName: nc.rendererPackageName, rendererConfig: nc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: te.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    return a = vr(a), a === null ? null : a.stateNode;
  }, findFiberByHostInstance: nc.findFiberByHostInstance || kg, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var sp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!sp.isDisabled && sp.supportsFiber)
      try {
        yl = sp.inject(C1), Ri = sp;
      } catch {
      }
  }
  return Na.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = E1, Na.createPortal = function(a, l) {
    var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Tm(l))
      throw Error(i(200));
    return _g(a, l, null, d);
  }, Na.createRoot = function(a, l) {
    if (!Tm(a))
      throw Error(i(299));
    var d = !1, m = "", g = km;
    return l != null && (l.unstable_strictMode === !0 && (d = !0), l.identifierPrefix !== void 0 && (m = l.identifierPrefix), l.onRecoverableError !== void 0 && (g = l.onRecoverableError)), l = rp(a, 1, !1, null, null, d, !1, m, g), a[jo] = l.current, Nu(a.nodeType === 8 ? a.parentNode : a), new ap(l);
  }, Na.findDOMNode = function(a) {
    if (a == null)
      return null;
    if (a.nodeType === 1)
      return a;
    var l = a._reactInternals;
    if (l === void 0)
      throw typeof a.render == "function" ? Error(i(188)) : (a = Object.keys(a).join(","), Error(i(268, a)));
    return a = vr(l), a = a === null ? null : a.stateNode, a;
  }, Na.flushSync = function(a) {
    return Wl(a);
  }, Na.hydrate = function(a, l, d) {
    if (!op(l))
      throw Error(i(200));
    return lp(null, a, l, !0, d);
  }, Na.hydrateRoot = function(a, l, d) {
    if (!Tm(a))
      throw Error(i(405));
    var m = d != null && d.hydratedSources || null, g = !1, _ = "", D = km;
    if (d != null && (d.unstable_strictMode === !0 && (g = !0), d.identifierPrefix !== void 0 && (_ = d.identifierPrefix), d.onRecoverableError !== void 0 && (D = d.onRecoverableError)), l = Eg(l, null, a, 1, d ?? null, g, !1, _, D), a[jo] = l.current, Nu(a), m)
      for (a = 0; a < m.length; a++)
        d = m[a], g = d._getVersion, g = g(d._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [d, g] : l.mutableSourceEagerHydrationData.push(
          d,
          g
        );
    return new Zo(l);
  }, Na.render = function(a, l, d) {
    if (!op(l))
      throw Error(i(200));
    return lp(null, a, l, !1, d);
  }, Na.unmountComponentAtNode = function(a) {
    if (!op(a))
      throw Error(i(40));
    return a._reactRootContainer ? (Wl(function() {
      lp(null, null, a, !1, function() {
        a._reactRootContainer = null, a[jo] = null;
      });
    }), !0) : !1;
  }, Na.unstable_batchedUpdates = ec, Na.unstable_renderSubtreeIntoContainer = function(a, l, d, m) {
    if (!op(d))
      throw Error(i(200));
    if (a == null || a._reactInternals === void 0)
      throw Error(i(38));
    return lp(a, l, d, !1, m);
  }, Na.version = "18.2.0-next-9e3b772b8-20220608", Na;
}
var La = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SR;
function g5() {
  return SR || (SR = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = L, n = S4(), i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, o = !1;
    function u(e) {
      o = e;
    }
    function f(e) {
      if (!o) {
        for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), c = 1; c < r; c++)
          s[c - 1] = arguments[c];
        v("warn", e, s);
      }
    }
    function p(e) {
      if (!o) {
        for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), c = 1; c < r; c++)
          s[c - 1] = arguments[c];
        v("error", e, s);
      }
    }
    function v(e, r, s) {
      {
        var c = i.ReactDebugCurrentFrame, h = c.getStackAddendum();
        h !== "" && (r += "%s", s = s.concat([h]));
        var y = s.map(function(x) {
          return String(x);
        });
        y.unshift("Warning: " + r), Function.prototype.apply.call(console[e], console, y);
      }
    }
    var b = 0, S = 1, E = 2, w = 3, R = 4, k = 5, N = 6, z = 7, I = 8, H = 9, q = 10, G = 11, te = 12, ee = 13, V = 14, ue = 15, we = 16, me = 17, Le = 18, xe = 19, ve = 21, Pe = 22, Ue = 23, We = 24, at = 25, Te = !0, ye = !1, Fe = !1, O = !1, ce = !1, De = !0, j = !1, rt = !1, Mt = !0, lt = !0, Nt = !0, xt = /* @__PURE__ */ new Set(), Zt = {}, er = {};
    function hr(e, r) {
      Jr(e, r), Jr(e + "Capture", r);
    }
    function Jr(e, r) {
      Zt[e] && p("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), Zt[e] = r;
      {
        var s = e.toLowerCase();
        er[s] = e, e === "onDoubleClick" && (er.ondblclick = e);
      }
      for (var c = 0; c < r.length; c++)
        xt.add(r[c]);
    }
    var zn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", sr = Object.prototype.hasOwnProperty;
    function tr(e) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, s = r && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return s;
      }
    }
    function nr(e) {
      try {
        return Zn(e), !1;
      } catch {
        return !0;
      }
    }
    function Zn(e) {
      return "" + e;
    }
    function jr(e, r) {
      if (nr(e))
        return p("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", r, tr(e)), Zn(e);
    }
    function Ir(e) {
      if (nr(e))
        return p("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", tr(e)), Zn(e);
    }
    function mr(e, r) {
      if (nr(e))
        return p("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", r, tr(e)), Zn(e);
    }
    function Tr(e, r) {
      if (nr(e))
        return p("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", r, tr(e)), Zn(e);
    }
    function ei(e) {
      if (nr(e))
        return p("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", tr(e)), Zn(e);
    }
    function Rr(e) {
      if (nr(e))
        return p("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", tr(e)), Zn(e);
    }
    var ci = 0, le = 1, Ce = 2, Ge = 3, gt = 4, It = 5, $n = 6, Re = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Xe = Re + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ct = new RegExp("^[" + Re + "][" + Xe + "]*$"), qt = {}, At = {};
    function Cn(e) {
      return sr.call(At, e) ? !0 : sr.call(qt, e) ? !1 : Ct.test(e) ? (At[e] = !0, !0) : (qt[e] = !0, p("Invalid attribute name: `%s`", e), !1);
    }
    function sn(e, r, s) {
      return r !== null ? r.type === ci : s ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function ti(e, r, s, c) {
      if (s !== null && s.type === ci)
        return !1;
      switch (typeof r) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (c)
            return !1;
          if (s !== null)
            return !s.acceptsBooleans;
          var h = e.toLowerCase().slice(0, 5);
          return h !== "data-" && h !== "aria-";
        }
        default:
          return !1;
      }
    }
    function wn(e, r, s, c) {
      if (r === null || typeof r > "u" || ti(e, r, s, c))
        return !0;
      if (c)
        return !1;
      if (s !== null)
        switch (s.type) {
          case Ge:
            return !r;
          case gt:
            return r === !1;
          case It:
            return isNaN(r);
          case $n:
            return isNaN(r) || r < 1;
        }
      return !1;
    }
    function fi(e) {
      return vn.hasOwnProperty(e) ? vn[e] : null;
    }
    function mn(e, r, s, c, h, y, x) {
      this.acceptsBooleans = r === Ce || r === Ge || r === gt, this.attributeName = c, this.attributeNamespace = h, this.mustUseProperty = s, this.propertyName = e, this.type = r, this.sanitizeURL = y, this.removeEmptyString = x;
    }
    var vn = {}, ja = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ja.forEach(function(e) {
      vn[e] = new mn(
        e,
        ci,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var r = e[0], s = e[1];
      vn[r] = new mn(
        r,
        le,
        !1,
        // mustUseProperty
        s,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      vn[e] = new mn(
        e,
        Ce,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      vn[e] = new mn(
        e,
        Ce,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      vn[e] = new mn(
        e,
        Ge,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      vn[e] = new mn(
        e,
        Ge,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      vn[e] = new mn(
        e,
        gt,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      vn[e] = new mn(
        e,
        $n,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      vn[e] = new mn(
        e,
        It,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var pa = /[\-\:]([a-z])/g, hl = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(pa, hl);
      vn[r] = new mn(
        r,
        le,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(pa, hl);
      vn[r] = new mn(
        r,
        le,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(pa, hl);
      vn[r] = new mn(
        r,
        le,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      vn[e] = new mn(
        e,
        le,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var hs = "xlinkHref";
    vn[hs] = new mn(
      "xlinkHref",
      le,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      vn[e] = new mn(
        e,
        le,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var mu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Oo = !1;
    function ml(e) {
      !Oo && mu.test(e) && (Oo = !0, p("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function Xi(e, r, s, c) {
      if (c.mustUseProperty) {
        var h = c.propertyName;
        return e[h];
      } else {
        jr(s, r), c.sanitizeURL && ml("" + s);
        var y = c.attributeName, x = null;
        if (c.type === gt) {
          if (e.hasAttribute(y)) {
            var C = e.getAttribute(y);
            return C === "" ? !0 : wn(r, s, c, !1) ? C : C === "" + s ? s : C;
          }
        } else if (e.hasAttribute(y)) {
          if (wn(r, s, c, !1))
            return e.getAttribute(y);
          if (c.type === Ge)
            return s;
          x = e.getAttribute(y);
        }
        return wn(r, s, c, !1) ? x === null ? s : x : x === "" + s ? s : x;
      }
    }
    function ro(e, r, s, c) {
      {
        if (!Cn(r))
          return;
        if (!e.hasAttribute(r))
          return s === void 0 ? void 0 : null;
        var h = e.getAttribute(r);
        return jr(s, r), h === "" + s ? s : h;
      }
    }
    function Qi(e, r, s, c) {
      var h = fi(r);
      if (!sn(r, h, c)) {
        if (wn(r, s, h, c) && (s = null), c || h === null) {
          if (Cn(r)) {
            var y = r;
            s === null ? e.removeAttribute(y) : (jr(s, r), e.setAttribute(y, "" + s));
          }
          return;
        }
        var x = h.mustUseProperty;
        if (x) {
          var C = h.propertyName;
          if (s === null) {
            var T = h.type;
            e[C] = T === Ge ? !1 : "";
          } else
            e[C] = s;
          return;
        }
        var M = h.attributeName, P = h.attributeNamespace;
        if (s === null)
          e.removeAttribute(M);
        else {
          var Z = h.type, W;
          Z === Ge || Z === gt && s === !0 ? W = "" : (jr(s, M), W = "" + s, h.sanitizeURL && ml(W.toString())), P ? e.setAttributeNS(P, M, W) : e.setAttribute(M, W);
        }
      }
    }
    var io = Symbol.for("react.element"), di = Symbol.for("react.portal"), Ki = Symbol.for("react.fragment"), ao = Symbol.for("react.strict_mode"), U = Symbol.for("react.profiler"), ge = Symbol.for("react.provider"), ze = Symbol.for("react.context"), Ye = Symbol.for("react.forward_ref"), Dt = Symbol.for("react.suspense"), Kt = Symbol.for("react.suspense_list"), Lt = Symbol.for("react.memo"), ft = Symbol.for("react.lazy"), vr = Symbol.for("react.scope"), Mn = Symbol.for("react.debug_trace_mode"), Nn = Symbol.for("react.offscreen"), Fr = Symbol.for("react.legacy_hidden"), oo = Symbol.for("react.cache"), vu = Symbol.for("react.tracing_marker"), an = Symbol.iterator, vh = "@@iterator";
    function Ia(e) {
      if (e === null || typeof e != "object")
        return null;
      var r = an && e[an] || e[vh];
      return typeof r == "function" ? r : null;
    }
    var Ft = Object.assign, lo = 0, vl, yu, yl, Ri, Lc, pi, Pc;
    function zc() {
    }
    zc.__reactDisabledLog = !0;
    function Jf() {
      {
        if (lo === 0) {
          vl = console.log, yu = console.info, yl = console.warn, Ri = console.error, Lc = console.group, pi = console.groupCollapsed, Pc = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: zc,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        lo++;
      }
    }
    function gu() {
      {
        if (lo--, lo === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ft({}, e, {
              value: vl
            }),
            info: Ft({}, e, {
              value: yu
            }),
            warn: Ft({}, e, {
              value: yl
            }),
            error: Ft({}, e, {
              value: Ri
            }),
            group: Ft({}, e, {
              value: Lc
            }),
            groupCollapsed: Ft({}, e, {
              value: pi
            }),
            groupEnd: Ft({}, e, {
              value: Pc
            })
          });
        }
        lo < 0 && p("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var gl = i.ReactCurrentDispatcher, Fa;
    function hi(e, r, s) {
      {
        if (Fa === void 0)
          try {
            throw Error();
          } catch (h) {
            var c = h.stack.trim().match(/\n( *(at )?)/);
            Fa = c && c[1] || "";
          }
        return `
` + Fa + e;
      }
    }
    var bl = !1, Sl;
    {
      var xl = typeof WeakMap == "function" ? WeakMap : Map;
      Sl = new xl();
    }
    function bu(e, r) {
      if (!e || bl)
        return "";
      {
        var s = Sl.get(e);
        if (s !== void 0)
          return s;
      }
      var c;
      bl = !0;
      var h = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var y;
      y = gl.current, gl.current = null, Jf();
      try {
        if (r) {
          var x = function() {
            throw Error();
          };
          if (Object.defineProperty(x.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(x, []);
            } catch (ie) {
              c = ie;
            }
            Reflect.construct(e, [], x);
          } else {
            try {
              x.call();
            } catch (ie) {
              c = ie;
            }
            e.call(x.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ie) {
            c = ie;
          }
          e();
        }
      } catch (ie) {
        if (ie && c && typeof ie.stack == "string") {
          for (var C = ie.stack.split(`
`), T = c.stack.split(`
`), M = C.length - 1, P = T.length - 1; M >= 1 && P >= 0 && C[M] !== T[P]; )
            P--;
          for (; M >= 1 && P >= 0; M--, P--)
            if (C[M] !== T[P]) {
              if (M !== 1 || P !== 1)
                do
                  if (M--, P--, P < 0 || C[M] !== T[P]) {
                    var Z = `
` + C[M].replace(" at new ", " at ");
                    return e.displayName && Z.includes("<anonymous>") && (Z = Z.replace("<anonymous>", e.displayName)), typeof e == "function" && Sl.set(e, Z), Z;
                  }
                while (M >= 1 && P >= 0);
              break;
            }
        }
      } finally {
        bl = !1, gl.current = y, gu(), Error.prepareStackTrace = h;
      }
      var W = e ? e.displayName || e.name : "", ne = W ? hi(W) : "";
      return typeof e == "function" && Sl.set(e, ne), ne;
    }
    function Su(e, r, s) {
      return bu(e, !0);
    }
    function Ao(e, r, s) {
      return bu(e, !1);
    }
    function yh(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function so(e, r, s) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return bu(e, yh(e));
      if (typeof e == "string")
        return hi(e);
      switch (e) {
        case Dt:
          return hi("Suspense");
        case Kt:
          return hi("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case Ye:
            return Ao(e.render);
          case Lt:
            return so(e.type, r, s);
          case ft: {
            var c = e, h = c._payload, y = c._init;
            try {
              return so(y(h), r, s);
            } catch {
            }
          }
        }
      return "";
    }
    function cn(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case k:
          return hi(e.type);
        case we:
          return hi("Lazy");
        case ee:
          return hi("Suspense");
        case xe:
          return hi("SuspenseList");
        case b:
        case E:
        case ue:
          return Ao(e.type);
        case G:
          return Ao(e.type.render);
        case S:
          return Su(e.type);
        default:
          return "";
      }
    }
    function xu(e) {
      try {
        var r = "", s = e;
        do
          r += cn(s), s = s.return;
        while (s);
        return r;
      } catch (c) {
        return `
Error generating stack: ` + c.message + `
` + c.stack;
      }
    }
    function ms(e, r, s) {
      var c = e.displayName;
      if (c)
        return c;
      var h = r.displayName || r.name || "";
      return h !== "" ? s + "(" + h + ")" : s;
    }
    function wu(e) {
      return e.displayName || "Context";
    }
    function on(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && p("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case Ki:
          return "Fragment";
        case di:
          return "Portal";
        case U:
          return "Profiler";
        case ao:
          return "StrictMode";
        case Dt:
          return "Suspense";
        case Kt:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case ze:
            var r = e;
            return wu(r) + ".Consumer";
          case ge:
            var s = e;
            return wu(s._context) + ".Provider";
          case Ye:
            return ms(e, e.render, "ForwardRef");
          case Lt:
            var c = e.displayName || null;
            return c !== null ? c : on(e.type) || "Memo";
          case ft: {
            var h = e, y = h._payload, x = h._init;
            try {
              return on(x(y));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function _u(e, r, s) {
      var c = r.displayName || r.name || "";
      return e.displayName || (c !== "" ? s + "(" + c + ")" : s);
    }
    function Eu(e) {
      return e.displayName || "Context";
    }
    function kt(e) {
      var r = e.tag, s = e.type;
      switch (r) {
        case We:
          return "Cache";
        case H:
          var c = s;
          return Eu(c) + ".Consumer";
        case q:
          var h = s;
          return Eu(h._context) + ".Provider";
        case Le:
          return "DehydratedFragment";
        case G:
          return _u(s, s.render, "ForwardRef");
        case z:
          return "Fragment";
        case k:
          return s;
        case R:
          return "Portal";
        case w:
          return "Root";
        case N:
          return "Text";
        case we:
          return on(s);
        case I:
          return s === ao ? "StrictMode" : "Mode";
        case Pe:
          return "Offscreen";
        case te:
          return "Profiler";
        case ve:
          return "Scope";
        case ee:
          return "Suspense";
        case xe:
          return "SuspenseList";
        case at:
          return "TracingMarker";
        case S:
        case b:
        case me:
        case E:
        case V:
        case ue:
          if (typeof s == "function")
            return s.displayName || s.name || null;
          if (typeof s == "string")
            return s;
          break;
      }
      return null;
    }
    var vs = i.ReactDebugCurrentFrame, qn = null, Oi = !1;
    function mi() {
      {
        if (qn === null)
          return null;
        var e = qn._debugOwner;
        if (e !== null && typeof e < "u")
          return kt(e);
      }
      return null;
    }
    function wl() {
      return qn === null ? "" : xu(qn);
    }
    function rr() {
      vs.getCurrentStack = null, qn = null, Oi = !1;
    }
    function yn(e) {
      vs.getCurrentStack = e === null ? null : wl, qn = e, Oi = !1;
    }
    function ed() {
      return qn;
    }
    function Ai(e) {
      Oi = e;
    }
    function Or(e) {
      return "" + e;
    }
    function uo(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return Rr(e), e;
        default:
          return "";
      }
    }
    var td = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Do(e, r) {
      td[r.type] || r.onChange || r.onInput || r.readOnly || r.disabled || r.value == null || p("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), r.onChange || r.readOnly || r.disabled || r.checked == null || p("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function _l(e) {
      var r = e.type, s = e.nodeName;
      return s && s.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function nd(e) {
      return e._valueTracker;
    }
    function ha(e) {
      e._valueTracker = null;
    }
    function El(e) {
      var r = "";
      return e && (_l(e) ? r = e.checked ? "true" : "false" : r = e.value), r;
    }
    function Cl(e) {
      var r = _l(e) ? "checked" : "value", s = Object.getOwnPropertyDescriptor(e.constructor.prototype, r);
      Rr(e[r]);
      var c = "" + e[r];
      if (!(e.hasOwnProperty(r) || typeof s > "u" || typeof s.get != "function" || typeof s.set != "function")) {
        var h = s.get, y = s.set;
        Object.defineProperty(e, r, {
          configurable: !0,
          get: function() {
            return h.call(this);
          },
          set: function(C) {
            Rr(C), c = "" + C, y.call(this, C);
          }
        }), Object.defineProperty(e, r, {
          enumerable: s.enumerable
        });
        var x = {
          getValue: function() {
            return c;
          },
          setValue: function(C) {
            Rr(C), c = "" + C;
          },
          stopTracking: function() {
            ha(e), delete e[r];
          }
        };
        return x;
      }
    }
    function ma(e) {
      nd(e) || (e._valueTracker = Cl(e));
    }
    function Cu(e) {
      if (!e)
        return !1;
      var r = nd(e);
      if (!r)
        return !0;
      var s = r.getValue(), c = El(e);
      return c !== s ? (r.setValue(c), !0) : !1;
    }
    function kl(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var Tl = !1, ys = !1, ku = !1, $c = !1;
    function Ua(e) {
      var r = e.type === "checkbox" || e.type === "radio";
      return r ? e.checked != null : e.value != null;
    }
    function A(e, r) {
      var s = e, c = r.checked, h = Ft({}, r, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: c ?? s._wrapperState.initialChecked
      });
      return h;
    }
    function F(e, r) {
      Do("input", r), r.checked !== void 0 && r.defaultChecked !== void 0 && !ys && (p("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", mi() || "A component", r.type), ys = !0), r.value !== void 0 && r.defaultValue !== void 0 && !Tl && (p("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", mi() || "A component", r.type), Tl = !0);
      var s = e, c = r.defaultValue == null ? "" : r.defaultValue;
      s._wrapperState = {
        initialChecked: r.checked != null ? r.checked : r.defaultChecked,
        initialValue: uo(r.value != null ? r.value : c),
        controlled: Ua(r)
      };
    }
    function re(e, r) {
      var s = e, c = r.checked;
      c != null && Qi(s, "checked", c, !1);
    }
    function se(e, r) {
      var s = e;
      {
        var c = Ua(r);
        !s._wrapperState.controlled && c && !$c && (p("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), $c = !0), s._wrapperState.controlled && !c && !ku && (p("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), ku = !0);
      }
      re(e, r);
      var h = uo(r.value), y = r.type;
      if (h != null)
        y === "number" ? (h === 0 && s.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        s.value != h) && (s.value = Or(h)) : s.value !== Or(h) && (s.value = Or(h));
      else if (y === "submit" || y === "reset") {
        s.removeAttribute("value");
        return;
      }
      r.hasOwnProperty("value") ? pt(s, r.type, h) : r.hasOwnProperty("defaultValue") && pt(s, r.type, uo(r.defaultValue)), r.checked == null && r.defaultChecked != null && (s.defaultChecked = !!r.defaultChecked);
    }
    function ke(e, r, s) {
      var c = e;
      if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
        var h = r.type, y = h === "submit" || h === "reset";
        if (y && (r.value === void 0 || r.value === null))
          return;
        var x = Or(c._wrapperState.initialValue);
        s || x !== c.value && (c.value = x), c.defaultValue = x;
      }
      var C = c.name;
      C !== "" && (c.name = ""), c.defaultChecked = !c.defaultChecked, c.defaultChecked = !!c._wrapperState.initialChecked, C !== "" && (c.name = C);
    }
    function mt(e, r) {
      var s = e;
      se(s, r), Ie(s, r);
    }
    function Ie(e, r) {
      var s = r.name;
      if (r.type === "radio" && s != null) {
        for (var c = e; c.parentNode; )
          c = c.parentNode;
        jr(s, "name");
        for (var h = c.querySelectorAll("input[name=" + JSON.stringify("" + s) + '][type="radio"]'), y = 0; y < h.length; y++) {
          var x = h[y];
          if (!(x === e || x.form !== e.form)) {
            var C = Vg(x);
            if (!C)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Cu(x), se(x, C);
          }
        }
      }
    }
    function pt(e, r, s) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (r !== "number" || kl(e.ownerDocument) !== e) && (s == null ? e.defaultValue = Or(e._wrapperState.initialValue) : e.defaultValue !== Or(s) && (e.defaultValue = Or(s)));
    }
    var Ut = !1, ln = !1, Rn = !1;
    function _n(e, r) {
      r.value == null && (typeof r.children == "object" && r.children !== null ? t.Children.forEach(r.children, function(s) {
        s != null && (typeof s == "string" || typeof s == "number" || ln || (ln = !0, p("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : r.dangerouslySetInnerHTML != null && (Rn || (Rn = !0, p("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), r.selected != null && !Ut && (p("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Ut = !0);
    }
    function On(e, r) {
      r.value != null && e.setAttribute("value", Or(uo(r.value)));
    }
    var Ln = Array.isArray;
    function Qt(e) {
      return Ln(e);
    }
    var Mo;
    Mo = !1;
    function Tu() {
      var e = mi();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var jc = ["value", "defaultValue"];
    function gh(e) {
      {
        Do("select", e);
        for (var r = 0; r < jc.length; r++) {
          var s = jc[r];
          if (e[s] != null) {
            var c = Qt(e[s]);
            e.multiple && !c ? p("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", s, Tu()) : !e.multiple && c && p("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", s, Tu());
          }
        }
      }
    }
    function Ba(e, r, s, c) {
      var h = e.options;
      if (r) {
        for (var y = s, x = {}, C = 0; C < y.length; C++)
          x["$" + y[C]] = !0;
        for (var T = 0; T < h.length; T++) {
          var M = x.hasOwnProperty("$" + h[T].value);
          h[T].selected !== M && (h[T].selected = M), M && c && (h[T].defaultSelected = !0);
        }
      } else {
        for (var P = Or(uo(s)), Z = null, W = 0; W < h.length; W++) {
          if (h[W].value === P) {
            h[W].selected = !0, c && (h[W].defaultSelected = !0);
            return;
          }
          Z === null && !h[W].disabled && (Z = h[W]);
        }
        Z !== null && (Z.selected = !0);
      }
    }
    function Ic(e, r) {
      return Ft({}, r, {
        value: void 0
      });
    }
    function Fc(e, r) {
      var s = e;
      gh(r), s._wrapperState = {
        wasMultiple: !!r.multiple
      }, r.value !== void 0 && r.defaultValue !== void 0 && !Mo && (p("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Mo = !0);
    }
    function bh(e, r) {
      var s = e;
      s.multiple = !!r.multiple;
      var c = r.value;
      c != null ? Ba(s, !!r.multiple, c, !1) : r.defaultValue != null && Ba(s, !!r.multiple, r.defaultValue, !0);
    }
    function YS(e, r) {
      var s = e, c = s._wrapperState.wasMultiple;
      s._wrapperState.wasMultiple = !!r.multiple;
      var h = r.value;
      h != null ? Ba(s, !!r.multiple, h, !1) : c !== !!r.multiple && (r.defaultValue != null ? Ba(s, !!r.multiple, r.defaultValue, !0) : Ba(s, !!r.multiple, r.multiple ? [] : "", !1));
    }
    function ZS(e, r) {
      var s = e, c = r.value;
      c != null && Ba(s, !!r.multiple, c, !1);
    }
    var Sh = !1;
    function xh(e, r) {
      var s = e;
      if (r.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var c = Ft({}, r, {
        value: void 0,
        defaultValue: void 0,
        children: Or(s._wrapperState.initialValue)
      });
      return c;
    }
    function by(e, r) {
      var s = e;
      Do("textarea", r), r.value !== void 0 && r.defaultValue !== void 0 && !Sh && (p("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", mi() || "A component"), Sh = !0);
      var c = r.value;
      if (c == null) {
        var h = r.children, y = r.defaultValue;
        if (h != null) {
          p("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (y != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Qt(h)) {
              if (h.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              h = h[0];
            }
            y = h;
          }
        }
        y == null && (y = ""), c = y;
      }
      s._wrapperState = {
        initialValue: uo(c)
      };
    }
    function Sy(e, r) {
      var s = e, c = uo(r.value), h = uo(r.defaultValue);
      if (c != null) {
        var y = Or(c);
        y !== s.value && (s.value = y), r.defaultValue == null && s.defaultValue !== y && (s.defaultValue = y);
      }
      h != null && (s.defaultValue = Or(h));
    }
    function xy(e, r) {
      var s = e, c = s.textContent;
      c === s._wrapperState.initialValue && c !== "" && c !== null && (s.value = c);
    }
    function wh(e, r) {
      Sy(e, r);
    }
    var No = "http://www.w3.org/1999/xhtml", qS = "http://www.w3.org/1998/Math/MathML", _h = "http://www.w3.org/2000/svg";
    function rd(e) {
      switch (e) {
        case "svg":
          return _h;
        case "math":
          return qS;
        default:
          return No;
      }
    }
    function Eh(e, r) {
      return e == null || e === No ? rd(r) : e === _h && r === "foreignObject" ? No : e;
    }
    var GS = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, s, c, h) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(r, s, c, h);
        });
      } : e;
    }, id, wy = GS(function(e, r) {
      if (e.namespaceURI === _h && !("innerHTML" in e)) {
        id = id || document.createElement("div"), id.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>";
        for (var s = id.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; s.firstChild; )
          e.appendChild(s.firstChild);
        return;
      }
      e.innerHTML = r;
    }), Di = 1, Lo = 3, yr = 8, Ha = 9, gs = 11, ad = function(e, r) {
      if (r) {
        var s = e.firstChild;
        if (s && s === e.lastChild && s.nodeType === Lo) {
          s.nodeValue = r;
          return;
        }
      }
      e.textContent = r;
    }, _y = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Ru = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ey(e, r) {
      return e + r.charAt(0).toUpperCase() + r.substring(1);
    }
    var Cy = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Ru).forEach(function(e) {
      Cy.forEach(function(r) {
        Ru[Ey(r, e)] = Ru[e];
      });
    });
    function od(e, r, s) {
      var c = r == null || typeof r == "boolean" || r === "";
      return c ? "" : !s && typeof r == "number" && r !== 0 && !(Ru.hasOwnProperty(e) && Ru[e]) ? r + "px" : (Tr(r, e), ("" + r).trim());
    }
    var Ou = /([A-Z])/g, XS = /^ms-/;
    function QS(e) {
      return e.replace(Ou, "-$1").toLowerCase().replace(XS, "-ms-");
    }
    var ky = function() {
    };
    {
      var Ty = /^(?:webkit|moz|o)[A-Z]/, Ry = /^-ms-/, Uc = /-(.)/g, Au = /;\s*$/, Du = {}, Mu = {}, Oy = !1, Ch = !1, kh = function(e) {
        return e.replace(Uc, function(r, s) {
          return s.toUpperCase();
        });
      }, Th = function(e) {
        Du.hasOwnProperty(e) && Du[e] || (Du[e] = !0, p(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          kh(e.replace(Ry, "ms-"))
        ));
      }, Ay = function(e) {
        Du.hasOwnProperty(e) && Du[e] || (Du[e] = !0, p("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, Dy = function(e, r) {
        Mu.hasOwnProperty(r) && Mu[r] || (Mu[r] = !0, p(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, r.replace(Au, "")));
      }, My = function(e, r) {
        Oy || (Oy = !0, p("`NaN` is an invalid value for the `%s` css style property.", e));
      }, KS = function(e, r) {
        Ch || (Ch = !0, p("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      ky = function(e, r) {
        e.indexOf("-") > -1 ? Th(e) : Ty.test(e) ? Ay(e) : Au.test(r) && Dy(e, r), typeof r == "number" && (isNaN(r) ? My(e, r) : isFinite(r) || KS(e, r));
      };
    }
    var JS = ky;
    function e1(e) {
      {
        var r = "", s = "";
        for (var c in e)
          if (e.hasOwnProperty(c)) {
            var h = e[c];
            if (h != null) {
              var y = c.indexOf("--") === 0;
              r += s + (y ? c : QS(c)) + ":", r += od(c, h, y), s = ";";
            }
          }
        return r || null;
      }
    }
    function Ny(e, r) {
      var s = e.style;
      for (var c in r)
        if (r.hasOwnProperty(c)) {
          var h = c.indexOf("--") === 0;
          h || JS(c, r[c]);
          var y = od(c, r[c], h);
          c === "float" && (c = "cssFloat"), h ? s.setProperty(c, y) : s[c] = y;
        }
    }
    function t1(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function va(e) {
      var r = {};
      for (var s in e)
        for (var c = _y[s] || [s], h = 0; h < c.length; h++)
          r[c[h]] = s;
      return r;
    }
    function Bc(e, r) {
      {
        if (!r)
          return;
        var s = va(e), c = va(r), h = {};
        for (var y in s) {
          var x = s[y], C = c[y];
          if (C && x !== C) {
            var T = x + "," + C;
            if (h[T])
              continue;
            h[T] = !0, p("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", t1(e[x]) ? "Removing" : "Updating", x, C);
          }
        }
      }
    }
    var Ly = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Py = Ft({
      menuitem: !0
    }, Ly), zy = "__html";
    function ld(e, r) {
      if (r) {
        if (Py[e] && (r.children != null || r.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (r.dangerouslySetInnerHTML != null) {
          if (r.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof r.dangerouslySetInnerHTML != "object" || !(zy in r.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!r.suppressContentEditableWarning && r.contentEditable && r.children != null && p("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), r.style != null && typeof r.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Po(e, r) {
      if (e.indexOf("-") === -1)
        return typeof r.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var sd = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, $y = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Va = {}, Rh = new RegExp("^(aria)-[" + Xe + "]*$"), Hc = new RegExp("^(aria)[A-Z][" + Xe + "]*$");
    function Oh(e, r) {
      {
        if (sr.call(Va, r) && Va[r])
          return !0;
        if (Hc.test(r)) {
          var s = "aria-" + r.slice(4).toLowerCase(), c = $y.hasOwnProperty(s) ? s : null;
          if (c == null)
            return p("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", r), Va[r] = !0, !0;
          if (r !== c)
            return p("Invalid ARIA attribute `%s`. Did you mean `%s`?", r, c), Va[r] = !0, !0;
        }
        if (Rh.test(r)) {
          var h = r.toLowerCase(), y = $y.hasOwnProperty(h) ? h : null;
          if (y == null)
            return Va[r] = !0, !1;
          if (r !== y)
            return p("Unknown ARIA attribute `%s`. Did you mean `%s`?", r, y), Va[r] = !0, !0;
        }
      }
      return !0;
    }
    function jy(e, r) {
      {
        var s = [];
        for (var c in r) {
          var h = Oh(e, c);
          h || s.push(c);
        }
        var y = s.map(function(x) {
          return "`" + x + "`";
        }).join(", ");
        s.length === 1 ? p("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", y, e) : s.length > 1 && p("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", y, e);
      }
    }
    function ud(e, r) {
      Po(e, r) || jy(e, r);
    }
    var bs = !1;
    function Ah(e, r) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        r != null && r.value === null && !bs && (bs = !0, e === "select" && r.multiple ? p("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : p("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var Dh = function() {
    };
    {
      var Ar = {}, Mh = /^on./, Iy = /^on[^A-Z]/, Fy = new RegExp("^(aria)-[" + Xe + "]*$"), Uy = new RegExp("^(aria)[A-Z][" + Xe + "]*$");
      Dh = function(e, r, s, c) {
        if (sr.call(Ar, r) && Ar[r])
          return !0;
        var h = r.toLowerCase();
        if (h === "onfocusin" || h === "onfocusout")
          return p("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Ar[r] = !0, !0;
        if (c != null) {
          var y = c.registrationNameDependencies, x = c.possibleRegistrationNames;
          if (y.hasOwnProperty(r))
            return !0;
          var C = x.hasOwnProperty(h) ? x[h] : null;
          if (C != null)
            return p("Invalid event handler property `%s`. Did you mean `%s`?", r, C), Ar[r] = !0, !0;
          if (Mh.test(r))
            return p("Unknown event handler property `%s`. It will be ignored.", r), Ar[r] = !0, !0;
        } else if (Mh.test(r))
          return Iy.test(r) && p("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", r), Ar[r] = !0, !0;
        if (Fy.test(r) || Uy.test(r))
          return !0;
        if (h === "innerhtml")
          return p("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Ar[r] = !0, !0;
        if (h === "aria")
          return p("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Ar[r] = !0, !0;
        if (h === "is" && s !== null && s !== void 0 && typeof s != "string")
          return p("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof s), Ar[r] = !0, !0;
        if (typeof s == "number" && isNaN(s))
          return p("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", r), Ar[r] = !0, !0;
        var T = fi(r), M = T !== null && T.type === ci;
        if (sd.hasOwnProperty(h)) {
          var P = sd[h];
          if (P !== r)
            return p("Invalid DOM property `%s`. Did you mean `%s`?", r, P), Ar[r] = !0, !0;
        } else if (!M && r !== h)
          return p("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", r, h), Ar[r] = !0, !0;
        return typeof s == "boolean" && ti(r, s, T, !1) ? (s ? p('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', s, r, r, s, r) : p('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', s, r, r, s, r, r, r), Ar[r] = !0, !0) : M ? !0 : ti(r, s, T, !1) ? (Ar[r] = !0, !1) : ((s === "false" || s === "true") && T !== null && T.type === Ge && (p("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", s, r, s === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', r, s), Ar[r] = !0), !0);
      };
    }
    var By = function(e, r, s) {
      {
        var c = [];
        for (var h in r) {
          var y = Dh(e, h, r[h], s);
          y || c.push(h);
        }
        var x = c.map(function(C) {
          return "`" + C + "`";
        }).join(", ");
        c.length === 1 ? p("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", x, e) : c.length > 1 && p("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", x, e);
      }
    };
    function Hy(e, r, s) {
      Po(e, r) || By(e, r, s);
    }
    var zo = 1, Vc = 2, Ss = 4, n1 = zo | Vc | Ss, Wc = null;
    function Yc(e) {
      Wc !== null && p("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Wc = e;
    }
    function r1() {
      Wc === null && p("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Wc = null;
    }
    function Vy(e) {
      return e === Wc;
    }
    function cd(e) {
      var r = e.target || e.srcElement || window;
      return r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === Lo ? r.parentNode : r;
    }
    var An = null, Rl = null, $o = null;
    function Nu(e) {
      var r = ac(e);
      if (r) {
        if (typeof An != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var s = r.stateNode;
        if (s) {
          var c = Vg(s);
          An(r.stateNode, r.type, c);
        }
      }
    }
    function Wy(e) {
      An = e;
    }
    function fd(e) {
      Rl ? $o ? $o.push(e) : $o = [e] : Rl = e;
    }
    function Zc() {
      return Rl !== null || $o !== null;
    }
    function qc() {
      if (Rl) {
        var e = Rl, r = $o;
        if (Rl = null, $o = null, Nu(e), r)
          for (var s = 0; s < r.length; s++)
            Nu(r[s]);
      }
    }
    var xs = function(e, r) {
      return e(r);
    }, Nh = function() {
    }, Lh = !1;
    function i1() {
      var e = Zc();
      e && (Nh(), qc());
    }
    function Ph(e, r, s) {
      if (Lh)
        return e(r, s);
      Lh = !0;
      try {
        return xs(e, r, s);
      } finally {
        Lh = !1, i1();
      }
    }
    function dd(e, r, s) {
      xs = e, Nh = s;
    }
    function pd(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function zh(e, r, s) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(s.disabled && pd(r));
        default:
          return !1;
      }
    }
    function ws(e, r) {
      var s = e.stateNode;
      if (s === null)
        return null;
      var c = Vg(s);
      if (c === null)
        return null;
      var h = c[r];
      if (zh(r, e.type, c))
        return null;
      if (h && typeof h != "function")
        throw new Error("Expected `" + r + "` listener to be a function, instead got a value of `" + typeof h + "` type.");
      return h;
    }
    var Gc = !1;
    if (zn)
      try {
        var _s = {};
        Object.defineProperty(_s, "passive", {
          get: function() {
            Gc = !0;
          }
        }), window.addEventListener("test", _s, _s), window.removeEventListener("test", _s, _s);
      } catch {
        Gc = !1;
      }
    function Yy(e, r, s, c, h, y, x, C, T) {
      var M = Array.prototype.slice.call(arguments, 3);
      try {
        r.apply(s, M);
      } catch (P) {
        this.onError(P);
      }
    }
    var $h = Yy;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var jh = document.createElement("react");
      $h = function(r, s, c, h, y, x, C, T, M) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var P = document.createEvent("Event"), Z = !1, W = !0, ne = window.event, ie = Object.getOwnPropertyDescriptor(window, "event");
        function fe() {
          jh.removeEventListener(de, dt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ne);
        }
        var Ze = Array.prototype.slice.call(arguments, 3);
        function dt() {
          Z = !0, fe(), s.apply(c, Ze), W = !1;
        }
        var st, tn = !1, Xt = !1;
        function Q(K) {
          if (st = K.error, tn = !0, st === null && K.colno === 0 && K.lineno === 0 && (Xt = !0), K.defaultPrevented && st != null && typeof st == "object")
            try {
              st._suppressLogging = !0;
            } catch {
            }
        }
        var de = "react-" + (r || "invokeguardedcallback");
        if (window.addEventListener("error", Q), jh.addEventListener(de, dt, !1), P.initEvent(de, !1, !1), jh.dispatchEvent(P), ie && Object.defineProperty(window, "event", ie), Z && W && (tn ? Xt && (st = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : st = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(st)), window.removeEventListener("error", Q), !Z)
          return fe(), Yy.apply(this, arguments);
      };
    }
    var a1 = $h, Ol = !1, Wa = null, Xc = !1, Al = null, co = {
      onError: function(e) {
        Ol = !0, Wa = e;
      }
    };
    function Es(e, r, s, c, h, y, x, C, T) {
      Ol = !1, Wa = null, a1.apply(co, arguments);
    }
    function jo(e, r, s, c, h, y, x, C, T) {
      if (Es.apply(this, arguments), Ol) {
        var M = Fh();
        Xc || (Xc = !0, Al = M);
      }
    }
    function Ih() {
      if (Xc) {
        var e = Al;
        throw Xc = !1, Al = null, e;
      }
    }
    function o1() {
      return Ol;
    }
    function Fh() {
      if (Ol) {
        var e = Wa;
        return Ol = !1, Wa = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ya(e) {
      return e._reactInternals;
    }
    function Qc(e) {
      return e._reactInternals !== void 0;
    }
    function Lu(e, r) {
      e._reactInternals = r;
    }
    var ct = (
      /*                      */
      0
    ), Dl = (
      /*                */
      1
    ), jn = (
      /*                    */
      2
    ), Pt = (
      /*                       */
      4
    ), hn = (
      /*                */
      16
    ), gn = (
      /*                 */
      32
    ), fo = (
      /*                     */
      64
    ), _t = (
      /*                   */
      128
    ), ir = (
      /*            */
      256
    ), Mi = (
      /*                          */
      512
    ), ga = (
      /*                     */
      1024
    ), Hn = (
      /*                      */
      2048
    ), ba = (
      /*                    */
      4096
    ), Ml = (
      /*                   */
      8192
    ), Kc = (
      /*             */
      16384
    ), hd = Hn | Pt | fo | Mi | ga | Kc, Zy = (
      /*               */
      32767
    ), Ji = (
      /*                   */
      32768
    ), Dr = (
      /*                */
      65536
    ), Jc = (
      /* */
      131072
    ), Uh = (
      /*                       */
      1048576
    ), Bh = (
      /*                    */
      2097152
    ), Ni = (
      /*                 */
      4194304
    ), Nl = (
      /*                */
      8388608
    ), Li = (
      /*               */
      16777216
    ), Cs = (
      /*              */
      33554432
    ), Pu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Pt | ga | 0
    ), Pi = jn | Pt | hn | gn | Mi | ba | Ml, ni = Pt | fo | Mi | Ml, Sa = Hn | hn, Ur = Ni | Nl | Bh, Io = i.ReactCurrentOwner;
    function ea(e) {
      var r = e, s = e;
      if (e.alternate)
        for (; r.return; )
          r = r.return;
      else {
        var c = r;
        do
          r = c, (r.flags & (jn | ba)) !== ct && (s = r.return), c = r.return;
        while (c);
      }
      return r.tag === w ? s : null;
    }
    function Hh(e) {
      if (e.tag === ee) {
        var r = e.memoizedState;
        if (r === null) {
          var s = e.alternate;
          s !== null && (r = s.memoizedState);
        }
        if (r !== null)
          return r.dehydrated;
      }
      return null;
    }
    function md(e) {
      return e.tag === w ? e.stateNode.containerInfo : null;
    }
    function Vh(e) {
      return ea(e) === e;
    }
    function ta(e) {
      {
        var r = Io.current;
        if (r !== null && r.tag === S) {
          var s = r, c = s.stateNode;
          c._warnedAboutRefsInRender || p("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", kt(s) || "A component"), c._warnedAboutRefsInRender = !0;
        }
      }
      var h = ya(e);
      return h ? ea(h) === h : !1;
    }
    function zi(e) {
      if (ea(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function In(e) {
      var r = e.alternate;
      if (!r) {
        var s = ea(e);
        if (s === null)
          throw new Error("Unable to find node on an unmounted component.");
        return s !== e ? null : e;
      }
      for (var c = e, h = r; ; ) {
        var y = c.return;
        if (y === null)
          break;
        var x = y.alternate;
        if (x === null) {
          var C = y.return;
          if (C !== null) {
            c = h = C;
            continue;
          }
          break;
        }
        if (y.child === x.child) {
          for (var T = y.child; T; ) {
            if (T === c)
              return zi(y), e;
            if (T === h)
              return zi(y), r;
            T = T.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (c.return !== h.return)
          c = y, h = x;
        else {
          for (var M = !1, P = y.child; P; ) {
            if (P === c) {
              M = !0, c = y, h = x;
              break;
            }
            if (P === h) {
              M = !0, h = y, c = x;
              break;
            }
            P = P.sibling;
          }
          if (!M) {
            for (P = x.child; P; ) {
              if (P === c) {
                M = !0, c = x, h = y;
                break;
              }
              if (P === h) {
                M = !0, h = x, c = y;
                break;
              }
              P = P.sibling;
            }
            if (!M)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (c.alternate !== h)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (c.tag !== w)
        throw new Error("Unable to find node on an unmounted component.");
      return c.stateNode.current === c ? e : r;
    }
    function xa(e) {
      var r = In(e);
      return r !== null ? Wh(r) : null;
    }
    function Wh(e) {
      if (e.tag === k || e.tag === N)
        return e;
      for (var r = e.child; r !== null; ) {
        var s = Wh(r);
        if (s !== null)
          return s;
        r = r.sibling;
      }
      return null;
    }
    function qy(e) {
      var r = In(e);
      return r !== null ? vd(r) : null;
    }
    function vd(e) {
      if (e.tag === k || e.tag === N)
        return e;
      for (var r = e.child; r !== null; ) {
        if (r.tag !== R) {
          var s = vd(r);
          if (s !== null)
            return s;
        }
        r = r.sibling;
      }
      return null;
    }
    var yd = n.unstable_scheduleCallback, Gy = n.unstable_cancelCallback, gd = n.unstable_shouldYield, Xy = n.unstable_requestPaint, Gn = n.unstable_now, Yh = n.unstable_getCurrentPriorityLevel, bd = n.unstable_ImmediatePriority, na = n.unstable_UserBlockingPriority, po = n.unstable_NormalPriority, Sd = n.unstable_LowPriority, Ll = n.unstable_IdlePriority, Zh = n.unstable_yieldValue, qh = n.unstable_setDisableYieldValue, Pl = null, Mr = null, $e = null, ur = !1, Br = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Gh(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var r = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (r.isDisabled)
        return !0;
      if (!r.supportsFiber)
        return p("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Mt && (e = Ft({}, e, {
          getLaneLabelMap: $l,
          injectProfilingHooks: Uo
        })), Pl = r.inject(e), Mr = r;
      } catch (s) {
        p("React instrumentation encountered an error: %s.", s);
      }
      return !!r.checkDCE;
    }
    function Qy(e, r) {
      if (Mr && typeof Mr.onScheduleFiberRoot == "function")
        try {
          Mr.onScheduleFiberRoot(Pl, e, r);
        } catch (s) {
          ur || (ur = !0, p("React instrumentation encountered an error: %s", s));
        }
    }
    function Fo(e, r) {
      if (Mr && typeof Mr.onCommitFiberRoot == "function")
        try {
          var s = (e.current.flags & _t) === _t;
          if (lt) {
            var c;
            switch (r) {
              case ri:
                c = bd;
                break;
              case Hr:
                c = na;
                break;
              case Ho:
                c = po;
                break;
              case uf:
                c = Ll;
                break;
              default:
                c = po;
                break;
            }
            Mr.onCommitFiberRoot(Pl, e, c, s);
          }
        } catch (h) {
          ur || (ur = !0, p("React instrumentation encountered an error: %s", h));
        }
    }
    function zl(e) {
      if (Mr && typeof Mr.onPostCommitFiberRoot == "function")
        try {
          Mr.onPostCommitFiberRoot(Pl, e);
        } catch (r) {
          ur || (ur = !0, p("React instrumentation encountered an error: %s", r));
        }
    }
    function Xh(e) {
      if (Mr && typeof Mr.onCommitFiberUnmount == "function")
        try {
          Mr.onCommitFiberUnmount(Pl, e);
        } catch (r) {
          ur || (ur = !0, p("React instrumentation encountered an error: %s", r));
        }
    }
    function xr(e) {
      if (typeof Zh == "function" && (qh(e), u(e)), Mr && typeof Mr.setStrictMode == "function")
        try {
          Mr.setStrictMode(Pl, e);
        } catch (r) {
          ur || (ur = !0, p("React instrumentation encountered an error: %s", r));
        }
    }
    function Uo(e) {
      $e = e;
    }
    function $l() {
      {
        for (var e = /* @__PURE__ */ new Map(), r = 1, s = 0; s < Fn; s++) {
          var c = l1(r);
          e.set(r, c), r *= 2;
        }
        return e;
      }
    }
    function xd(e) {
      $e !== null && typeof $e.markCommitStarted == "function" && $e.markCommitStarted(e);
    }
    function Qh() {
      $e !== null && typeof $e.markCommitStopped == "function" && $e.markCommitStopped();
    }
    function jl(e) {
      $e !== null && typeof $e.markComponentRenderStarted == "function" && $e.markComponentRenderStarted(e);
    }
    function ks() {
      $e !== null && typeof $e.markComponentRenderStopped == "function" && $e.markComponentRenderStopped();
    }
    function Ky(e) {
      $e !== null && typeof $e.markComponentPassiveEffectMountStarted == "function" && $e.markComponentPassiveEffectMountStarted(e);
    }
    function Kh() {
      $e !== null && typeof $e.markComponentPassiveEffectMountStopped == "function" && $e.markComponentPassiveEffectMountStopped();
    }
    function wd(e) {
      $e !== null && typeof $e.markComponentPassiveEffectUnmountStarted == "function" && $e.markComponentPassiveEffectUnmountStarted(e);
    }
    function Jy() {
      $e !== null && typeof $e.markComponentPassiveEffectUnmountStopped == "function" && $e.markComponentPassiveEffectUnmountStopped();
    }
    function eg(e) {
      $e !== null && typeof $e.markComponentLayoutEffectMountStarted == "function" && $e.markComponentLayoutEffectMountStarted(e);
    }
    function tg() {
      $e !== null && typeof $e.markComponentLayoutEffectMountStopped == "function" && $e.markComponentLayoutEffectMountStopped();
    }
    function _d(e) {
      $e !== null && typeof $e.markComponentLayoutEffectUnmountStarted == "function" && $e.markComponentLayoutEffectUnmountStarted(e);
    }
    function zu() {
      $e !== null && typeof $e.markComponentLayoutEffectUnmountStopped == "function" && $e.markComponentLayoutEffectUnmountStopped();
    }
    function Ed(e, r, s) {
      $e !== null && typeof $e.markComponentErrored == "function" && $e.markComponentErrored(e, r, s);
    }
    function ng(e, r, s) {
      $e !== null && typeof $e.markComponentSuspended == "function" && $e.markComponentSuspended(e, r, s);
    }
    function rg(e) {
      $e !== null && typeof $e.markLayoutEffectsStarted == "function" && $e.markLayoutEffectsStarted(e);
    }
    function $u() {
      $e !== null && typeof $e.markLayoutEffectsStopped == "function" && $e.markLayoutEffectsStopped();
    }
    function ig(e) {
      $e !== null && typeof $e.markPassiveEffectsStarted == "function" && $e.markPassiveEffectsStarted(e);
    }
    function ef() {
      $e !== null && typeof $e.markPassiveEffectsStopped == "function" && $e.markPassiveEffectsStopped();
    }
    function Ya(e) {
      $e !== null && typeof $e.markRenderStarted == "function" && $e.markRenderStarted(e);
    }
    function tf() {
      $e !== null && typeof $e.markRenderYielded == "function" && $e.markRenderYielded();
    }
    function ju() {
      $e !== null && typeof $e.markRenderStopped == "function" && $e.markRenderStopped();
    }
    function Ts(e) {
      $e !== null && typeof $e.markRenderScheduled == "function" && $e.markRenderScheduled(e);
    }
    function Jh(e, r) {
      $e !== null && typeof $e.markForceUpdateScheduled == "function" && $e.markForceUpdateScheduled(e, r);
    }
    function Il(e, r) {
      $e !== null && typeof $e.markStateUpdateScheduled == "function" && $e.markStateUpdateScheduled(e, r);
    }
    var ht = (
      /*                         */
      0
    ), Bt = (
      /*                 */
      1
    ), vt = (
      /*                    */
      2
    ), Xn = (
      /*               */
      8
    ), wa = (
      /*              */
      16
    ), Cd = Math.clz32 ? Math.clz32 : Rs, kd = Math.log, em = Math.LN2;
    function Rs(e) {
      var r = e >>> 0;
      return r === 0 ? 32 : 31 - (kd(r) / em | 0) | 0;
    }
    var Fn = 31, pe = (
      /*                        */
      0
    ), Jt = (
      /*                          */
      0
    ), bt = (
      /*                        */
      1
    ), ho = (
      /*    */
      2
    ), ra = (
      /*             */
      4
    ), Os = (
      /*            */
      8
    ), Un = (
      /*                     */
      16
    ), As = (
      /*                */
      32
    ), Fl = (
      /*                       */
      4194240
    ), Ds = (
      /*                        */
      64
    ), _a = (
      /*                        */
      128
    ), $i = (
      /*                        */
      256
    ), Ms = (
      /*                        */
      512
    ), nf = (
      /*                        */
      1024
    ), rf = (
      /*                        */
      2048
    ), Td = (
      /*                        */
      4096
    ), Rd = (
      /*                        */
      8192
    ), Od = (
      /*                        */
      16384
    ), Ad = (
      /*                       */
      32768
    ), Dd = (
      /*                       */
      65536
    ), Md = (
      /*                       */
      131072
    ), Nd = (
      /*                       */
      262144
    ), Ld = (
      /*                       */
      524288
    ), Ns = (
      /*                       */
      1048576
    ), Pd = (
      /*                       */
      2097152
    ), Ls = (
      /*                            */
      130023424
    ), Bo = (
      /*                             */
      4194304
    ), zd = (
      /*                             */
      8388608
    ), af = (
      /*                             */
      16777216
    ), $d = (
      /*                             */
      33554432
    ), jd = (
      /*                             */
      67108864
    ), tm = Bo, Iu = (
      /*          */
      134217728
    ), Id = (
      /*                          */
      268435455
    ), Fu = (
      /*               */
      268435456
    ), Ul = (
      /*                        */
      536870912
    ), ji = (
      /*                   */
      1073741824
    );
    function l1(e) {
      {
        if (e & bt)
          return "Sync";
        if (e & ho)
          return "InputContinuousHydration";
        if (e & ra)
          return "InputContinuous";
        if (e & Os)
          return "DefaultHydration";
        if (e & Un)
          return "Default";
        if (e & As)
          return "TransitionHydration";
        if (e & Fl)
          return "Transition";
        if (e & Ls)
          return "Retry";
        if (e & Iu)
          return "SelectiveHydration";
        if (e & Fu)
          return "IdleHydration";
        if (e & Ul)
          return "Idle";
        if (e & ji)
          return "Offscreen";
      }
    }
    var Dn = -1, Fd = Ds, Ud = Bo;
    function Uu(e) {
      switch (gr(e)) {
        case bt:
          return bt;
        case ho:
          return ho;
        case ra:
          return ra;
        case Os:
          return Os;
        case Un:
          return Un;
        case As:
          return As;
        case Ds:
        case _a:
        case $i:
        case Ms:
        case nf:
        case rf:
        case Td:
        case Rd:
        case Od:
        case Ad:
        case Dd:
        case Md:
        case Nd:
        case Ld:
        case Ns:
        case Pd:
          return e & Fl;
        case Bo:
        case zd:
        case af:
        case $d:
        case jd:
          return e & Ls;
        case Iu:
          return Iu;
        case Fu:
          return Fu;
        case Ul:
          return Ul;
        case ji:
          return ji;
        default:
          return p("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function of(e, r) {
      var s = e.pendingLanes;
      if (s === pe)
        return pe;
      var c = pe, h = e.suspendedLanes, y = e.pingedLanes, x = s & Id;
      if (x !== pe) {
        var C = x & ~h;
        if (C !== pe)
          c = Uu(C);
        else {
          var T = x & y;
          T !== pe && (c = Uu(T));
        }
      } else {
        var M = s & ~h;
        M !== pe ? c = Uu(M) : y !== pe && (c = Uu(y));
      }
      if (c === pe)
        return pe;
      if (r !== pe && r !== c && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (r & h) === pe) {
        var P = gr(c), Z = gr(r);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          P >= Z || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          P === Un && (Z & Fl) !== pe
        )
          return r;
      }
      (c & ra) !== pe && (c |= s & Un);
      var W = e.entangledLanes;
      if (W !== pe)
        for (var ne = e.entanglements, ie = c & W; ie > 0; ) {
          var fe = Bl(ie), Ze = 1 << fe;
          c |= ne[fe], ie &= ~Ze;
        }
      return c;
    }
    function ag(e, r) {
      for (var s = e.eventTimes, c = Dn; r > 0; ) {
        var h = Bl(r), y = 1 << h, x = s[h];
        x > c && (c = x), r &= ~y;
      }
      return c;
    }
    function Bd(e, r) {
      switch (e) {
        case bt:
        case ho:
        case ra:
          return r + 250;
        case Os:
        case Un:
        case As:
        case Ds:
        case _a:
        case $i:
        case Ms:
        case nf:
        case rf:
        case Td:
        case Rd:
        case Od:
        case Ad:
        case Dd:
        case Md:
        case Nd:
        case Ld:
        case Ns:
        case Pd:
          return r + 5e3;
        case Bo:
        case zd:
        case af:
        case $d:
        case jd:
          return Dn;
        case Iu:
        case Fu:
        case Ul:
        case ji:
          return Dn;
        default:
          return p("Should have found matching lanes. This is a bug in React."), Dn;
      }
    }
    function s1(e, r) {
      for (var s = e.pendingLanes, c = e.suspendedLanes, h = e.pingedLanes, y = e.expirationTimes, x = s; x > 0; ) {
        var C = Bl(x), T = 1 << C, M = y[C];
        M === Dn ? ((T & c) === pe || (T & h) !== pe) && (y[C] = Bd(T, r)) : M <= r && (e.expiredLanes |= T), x &= ~T;
      }
    }
    function u1(e) {
      return Uu(e.pendingLanes);
    }
    function nm(e) {
      var r = e.pendingLanes & ~ji;
      return r !== pe ? r : r & ji ? ji : pe;
    }
    function Bu(e) {
      return (e & bt) !== pe;
    }
    function lf(e) {
      return (e & Id) !== pe;
    }
    function Hd(e) {
      return (e & Ls) === e;
    }
    function c1(e) {
      var r = bt | ra | Un;
      return (e & r) === pe;
    }
    function og(e) {
      return (e & Fl) === e;
    }
    function sf(e, r) {
      var s = ho | ra | Os | Un;
      return (r & s) !== pe;
    }
    function lg(e, r) {
      return (r & e.expiredLanes) !== pe;
    }
    function rm(e) {
      return (e & Fl) !== pe;
    }
    function im() {
      var e = Fd;
      return Fd <<= 1, (Fd & Fl) === pe && (Fd = Ds), e;
    }
    function f1() {
      var e = Ud;
      return Ud <<= 1, (Ud & Ls) === pe && (Ud = Bo), e;
    }
    function gr(e) {
      return e & -e;
    }
    function wr(e) {
      return gr(e);
    }
    function Bl(e) {
      return 31 - Cd(e);
    }
    function Vd(e) {
      return Bl(e);
    }
    function Ii(e, r) {
      return (e & r) !== pe;
    }
    function Ps(e, r) {
      return (e & r) === r;
    }
    function zt(e, r) {
      return e | r;
    }
    function Hu(e, r) {
      return e & ~r;
    }
    function am(e, r) {
      return e & r;
    }
    function sg(e) {
      return e;
    }
    function ug(e, r) {
      return e !== Jt && e < r ? e : r;
    }
    function Wd(e) {
      for (var r = [], s = 0; s < Fn; s++)
        r.push(e);
      return r;
    }
    function zs(e, r, s) {
      e.pendingLanes |= r, r !== Ul && (e.suspendedLanes = pe, e.pingedLanes = pe);
      var c = e.eventTimes, h = Vd(r);
      c[h] = s;
    }
    function om(e, r) {
      e.suspendedLanes |= r, e.pingedLanes &= ~r;
      for (var s = e.expirationTimes, c = r; c > 0; ) {
        var h = Bl(c), y = 1 << h;
        s[h] = Dn, c &= ~y;
      }
    }
    function lm(e, r, s) {
      e.pingedLanes |= e.suspendedLanes & r;
    }
    function sm(e, r) {
      var s = e.pendingLanes & ~r;
      e.pendingLanes = r, e.suspendedLanes = pe, e.pingedLanes = pe, e.expiredLanes &= r, e.mutableReadLanes &= r, e.entangledLanes &= r;
      for (var c = e.entanglements, h = e.eventTimes, y = e.expirationTimes, x = s; x > 0; ) {
        var C = Bl(x), T = 1 << C;
        c[C] = pe, h[C] = Dn, y[C] = Dn, x &= ~T;
      }
    }
    function Vu(e, r) {
      for (var s = e.entangledLanes |= r, c = e.entanglements, h = s; h; ) {
        var y = Bl(h), x = 1 << y;
        // Is this one of the newly entangled lanes?
        x & r | // Is this lane transitively entangled with the newly entangled lanes?
        c[y] & r && (c[y] |= r), h &= ~x;
      }
    }
    function d1(e, r) {
      var s = gr(r), c;
      switch (s) {
        case ra:
          c = ho;
          break;
        case Un:
          c = Os;
          break;
        case Ds:
        case _a:
        case $i:
        case Ms:
        case nf:
        case rf:
        case Td:
        case Rd:
        case Od:
        case Ad:
        case Dd:
        case Md:
        case Nd:
        case Ld:
        case Ns:
        case Pd:
        case Bo:
        case zd:
        case af:
        case $d:
        case jd:
          c = As;
          break;
        case Ul:
          c = Fu;
          break;
        default:
          c = Jt;
          break;
      }
      return (c & (e.suspendedLanes | r)) !== Jt ? Jt : c;
    }
    function um(e, r, s) {
      if (Br)
        for (var c = e.pendingUpdatersLaneMap; s > 0; ) {
          var h = Vd(s), y = 1 << h, x = c[h];
          x.add(r), s &= ~y;
        }
    }
    function Yd(e, r) {
      if (Br)
        for (var s = e.pendingUpdatersLaneMap, c = e.memoizedUpdaters; r > 0; ) {
          var h = Vd(r), y = 1 << h, x = s[h];
          x.size > 0 && (x.forEach(function(C) {
            var T = C.alternate;
            (T === null || !c.has(T)) && c.add(C);
          }), x.clear()), r &= ~y;
        }
    }
    function cm(e, r) {
      return null;
    }
    var ri = bt, Hr = ra, Ho = Un, uf = Ul, $s = Jt;
    function Ea() {
      return $s;
    }
    function _r(e) {
      $s = e;
    }
    function cf(e, r) {
      var s = $s;
      try {
        return $s = e, r();
      } finally {
        $s = s;
      }
    }
    function ii(e, r) {
      return e !== 0 && e < r ? e : r;
    }
    function p1(e, r) {
      return e === 0 || e > r ? e : r;
    }
    function fm(e, r) {
      return e !== 0 && e < r;
    }
    function ff(e) {
      var r = gr(e);
      return fm(ri, r) ? fm(Hr, r) ? lf(r) ? Ho : uf : Hr : ri;
    }
    function Er(e) {
      var r = e.current.memoizedState;
      return r.isDehydrated;
    }
    var cg;
    function Ke(e) {
      cg = e;
    }
    function Wu(e) {
      cg(e);
    }
    var df;
    function fg(e) {
      df = e;
    }
    var dg;
    function pf(e) {
      dg = e;
    }
    var hf;
    function dm(e) {
      hf = e;
    }
    var pm;
    function pg(e) {
      pm = e;
    }
    var Zd = !1, Yu = [], mo = null, Vn = null, Nr = null, Ca = /* @__PURE__ */ new Map(), Zu = /* @__PURE__ */ new Map(), Vo = [], Za = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function hg(e) {
      return Za.indexOf(e) > -1;
    }
    function vo(e, r, s, c, h) {
      return {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: s,
        nativeEvent: h,
        targetContainers: [c]
      };
    }
    function mg(e, r) {
      switch (e) {
        case "focusin":
        case "focusout":
          mo = null;
          break;
        case "dragenter":
        case "dragleave":
          Vn = null;
          break;
        case "mouseover":
        case "mouseout":
          Nr = null;
          break;
        case "pointerover":
        case "pointerout": {
          var s = r.pointerId;
          Ca.delete(s);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var c = r.pointerId;
          Zu.delete(c);
          break;
        }
      }
    }
    function qu(e, r, s, c, h, y) {
      if (e === null || e.nativeEvent !== y) {
        var x = vo(r, s, c, h, y);
        if (r !== null) {
          var C = ac(r);
          C !== null && df(C);
        }
        return x;
      }
      e.eventSystemFlags |= c;
      var T = e.targetContainers;
      return h !== null && T.indexOf(h) === -1 && T.push(h), e;
    }
    function vg(e, r, s, c, h) {
      switch (r) {
        case "focusin": {
          var y = h;
          return mo = qu(mo, e, r, s, c, y), !0;
        }
        case "dragenter": {
          var x = h;
          return Vn = qu(Vn, e, r, s, c, x), !0;
        }
        case "mouseover": {
          var C = h;
          return Nr = qu(Nr, e, r, s, c, C), !0;
        }
        case "pointerover": {
          var T = h, M = T.pointerId;
          return Ca.set(M, qu(Ca.get(M) || null, e, r, s, c, T)), !0;
        }
        case "gotpointercapture": {
          var P = h, Z = P.pointerId;
          return Zu.set(Z, qu(Zu.get(Z) || null, e, r, s, c, P)), !0;
        }
      }
      return !1;
    }
    function hm(e) {
      var r = _f(e.target);
      if (r !== null) {
        var s = ea(r);
        if (s !== null) {
          var c = s.tag;
          if (c === ee) {
            var h = Hh(s);
            if (h !== null) {
              e.blockedOn = h, pm(e.priority, function() {
                dg(s);
              });
              return;
            }
          } else if (c === w) {
            var y = s.stateNode;
            if (Er(y)) {
              e.blockedOn = md(s);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function yg(e) {
      for (var r = hf(), s = {
        blockedOn: null,
        target: e,
        priority: r
      }, c = 0; c < Vo.length && fm(r, Vo[c].priority); c++)
        ;
      Vo.splice(c, 0, s), c === 0 && hm(s);
    }
    function qd(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var r = e.targetContainers; r.length > 0; ) {
        var s = r[0], c = js(e.domEventName, e.eventSystemFlags, s, e.nativeEvent);
        if (c === null) {
          var h = e.nativeEvent, y = new h.constructor(h.type, h);
          Yc(y), h.target.dispatchEvent(y), r1();
        } else {
          var x = ac(c);
          return x !== null && df(x), e.blockedOn = c, !1;
        }
        r.shift();
      }
      return !0;
    }
    function mf(e, r, s) {
      qd(e) && s.delete(r);
    }
    function mm() {
      Zd = !1, mo !== null && qd(mo) && (mo = null), Vn !== null && qd(Vn) && (Vn = null), Nr !== null && qd(Nr) && (Nr = null), Ca.forEach(mf), Zu.forEach(mf);
    }
    function ai(e, r) {
      e.blockedOn === r && (e.blockedOn = null, Zd || (Zd = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, mm)));
    }
    function Gt(e) {
      if (Yu.length > 0) {
        ai(Yu[0], e);
        for (var r = 1; r < Yu.length; r++) {
          var s = Yu[r];
          s.blockedOn === e && (s.blockedOn = null);
        }
      }
      mo !== null && ai(mo, e), Vn !== null && ai(Vn, e), Nr !== null && ai(Nr, e);
      var c = function(C) {
        return ai(C, e);
      };
      Ca.forEach(c), Zu.forEach(c);
      for (var h = 0; h < Vo.length; h++) {
        var y = Vo[h];
        y.blockedOn === e && (y.blockedOn = null);
      }
      for (; Vo.length > 0; ) {
        var x = Vo[0];
        if (x.blockedOn !== null)
          break;
        hm(x), x.blockedOn === null && Vo.shift();
      }
    }
    var Qn = i.ReactCurrentBatchConfig, ar = !0;
    function Lr(e) {
      ar = !!e;
    }
    function ia() {
      return ar;
    }
    function Gu(e, r, s) {
      var c = vi(r), h;
      switch (c) {
        case ri:
          h = Cr;
          break;
        case Hr:
          h = vf;
          break;
        case Ho:
        default:
          h = Wo;
          break;
      }
      return h.bind(null, r, s, e);
    }
    function Cr(e, r, s, c) {
      var h = Ea(), y = Qn.transition;
      Qn.transition = null;
      try {
        _r(ri), Wo(e, r, s, c);
      } finally {
        _r(h), Qn.transition = y;
      }
    }
    function vf(e, r, s, c) {
      var h = Ea(), y = Qn.transition;
      Qn.transition = null;
      try {
        _r(Hr), Wo(e, r, s, c);
      } finally {
        _r(h), Qn.transition = y;
      }
    }
    function Wo(e, r, s, c) {
      ar && Gd(e, r, s, c);
    }
    function Gd(e, r, s, c) {
      var h = js(e, r, s, c);
      if (h === null) {
        N1(e, r, c, Xu, s), mg(e, c);
        return;
      }
      if (vg(h, e, r, s, c)) {
        c.stopPropagation();
        return;
      }
      if (mg(e, c), r & Ss && hg(e)) {
        for (; h !== null; ) {
          var y = ac(h);
          y !== null && Wu(y);
          var x = js(e, r, s, c);
          if (x === null && N1(e, r, c, Xu, s), x === h)
            break;
          h = x;
        }
        h !== null && c.stopPropagation();
        return;
      }
      N1(e, r, c, null, s);
    }
    var Xu = null;
    function js(e, r, s, c) {
      Xu = null;
      var h = cd(c), y = _f(h);
      if (y !== null) {
        var x = ea(y);
        if (x === null)
          y = null;
        else {
          var C = x.tag;
          if (C === ee) {
            var T = Hh(x);
            if (T !== null)
              return T;
            y = null;
          } else if (C === w) {
            var M = x.stateNode;
            if (Er(M))
              return md(x);
            y = null;
          } else
            x !== y && (y = null);
        }
      }
      return Xu = y, null;
    }
    function vi(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ri;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Hr;
        case "message": {
          var r = Yh();
          switch (r) {
            case bd:
              return ri;
            case na:
              return Hr;
            case po:
            case Sd:
              return Ho;
            case Ll:
              return uf;
            default:
              return Ho;
          }
        }
        default:
          return Ho;
      }
    }
    function vm(e, r, s) {
      return e.addEventListener(r, s, !1), s;
    }
    function Qu(e, r, s) {
      return e.addEventListener(r, s, !0), s;
    }
    function Yo(e, r, s, c) {
      return e.addEventListener(r, s, {
        capture: !0,
        passive: c
      }), s;
    }
    function Xd(e, r, s, c) {
      return e.addEventListener(r, s, {
        passive: c
      }), s;
    }
    var Is = null, yo = null, Hl = null;
    function Vl(e) {
      return Is = e, yo = Kd(), !0;
    }
    function Qd() {
      Is = null, yo = null, Hl = null;
    }
    function Ku() {
      if (Hl)
        return Hl;
      var e, r = yo, s = r.length, c, h = Kd(), y = h.length;
      for (e = 0; e < s && r[e] === h[e]; e++)
        ;
      var x = s - e;
      for (c = 1; c <= x && r[s - c] === h[y - c]; c++)
        ;
      var C = c > 1 ? 1 - c : void 0;
      return Hl = h.slice(e, C), Hl;
    }
    function Kd() {
      return "value" in Is ? Is.value : Is.textContent;
    }
    function Fs(e) {
      var r, s = e.keyCode;
      return "charCode" in e ? (r = e.charCode, r === 0 && s === 13 && (r = 13)) : r = s, r === 10 && (r = 13), r >= 32 || r === 13 ? r : 0;
    }
    function Us() {
      return !0;
    }
    function oi() {
      return !1;
    }
    function br(e) {
      function r(s, c, h, y, x) {
        this._reactName = s, this._targetInst = h, this.type = c, this.nativeEvent = y, this.target = x, this.currentTarget = null;
        for (var C in e)
          if (e.hasOwnProperty(C)) {
            var T = e[C];
            T ? this[C] = T(y) : this[C] = y[C];
          }
        var M = y.defaultPrevented != null ? y.defaultPrevented : y.returnValue === !1;
        return M ? this.isDefaultPrevented = Us : this.isDefaultPrevented = oi, this.isPropagationStopped = oi, this;
      }
      return Ft(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var s = this.nativeEvent;
          s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = !1), this.isDefaultPrevented = Us);
        },
        stopPropagation: function() {
          var s = this.nativeEvent;
          s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = !0), this.isPropagationStopped = Us);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: Us
      }), r;
    }
    var li = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, si = br(li), Ju = Ft({}, li, {
      view: 0,
      detail: 0
    }), ym = br(Ju), yf, gm, ka;
    function gg(e) {
      e !== ka && (ka && e.type === "mousemove" ? (yf = e.screenX - ka.screenX, gm = e.screenY - ka.screenY) : (yf = 0, gm = 0), ka = e);
    }
    var ec = Ft({}, Ju, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: tp,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (gg(e), yf);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : gm;
      }
    }), Wl = br(ec), bm = Ft({}, ec, {
      dataTransfer: 0
    }), Bs = br(bm), bg = Ft({}, Ju, {
      relatedTarget: 0
    }), Jd = br(bg), Sm = Ft({}, li, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), ep = br(Sm), h1 = Ft({}, li, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), m1 = br(h1), Sg = Ft({}, li, {
      data: 0
    }), xm = br(Sg), Hs = xm, v1 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, tc = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function xg(e) {
      if (e.key) {
        var r = v1[e.key] || e.key;
        if (r !== "Unidentified")
          return r;
      }
      if (e.type === "keypress") {
        var s = Fs(e);
        return s === 13 ? "Enter" : String.fromCharCode(s);
      }
      return e.type === "keydown" || e.type === "keyup" ? tc[e.keyCode] || "Unidentified" : "";
    }
    var or = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function y1(e) {
      var r = this, s = r.nativeEvent;
      if (s.getModifierState)
        return s.getModifierState(e);
      var c = or[e];
      return c ? !!s[c] : !1;
    }
    function tp(e) {
      return y1;
    }
    var g1 = Ft({}, Ju, {
      key: xg,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: tp,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? Fs(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? Fs(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), b1 = br(g1), wg = Ft({}, ec, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), wm = br(wg), S1 = Ft({}, Ju, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: tp
    }), Ta = br(S1), _m = Ft({}, li, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), x1 = br(_m), Yl = Ft({}, ec, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), np = br(Yl), Vs = [9, 13, 27, 32], gf = 229, bf = zn && "CompositionEvent" in window, Ws = null;
    zn && "documentMode" in document && (Ws = document.documentMode);
    var w1 = zn && "TextEvent" in window && !Ws, rp = zn && (!bf || Ws && Ws > 8 && Ws <= 11), _g = 32, Em = String.fromCharCode(_g);
    function Eg() {
      hr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), hr("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), hr("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), hr("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Sf = !1;
    function ip(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function Cg(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Cm(e, r) {
      return e === "keydown" && r.keyCode === gf;
    }
    function kg(e, r) {
      switch (e) {
        case "keyup":
          return Vs.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== gf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function km(e) {
      var r = e.detail;
      return typeof r == "object" && "data" in r ? r.data : null;
    }
    function ap(e) {
      return e.locale === "ko";
    }
    var Zo = !1;
    function Tm(e, r, s, c, h) {
      var y, x;
      if (bf ? y = Cg(r) : Zo ? kg(r, c) && (y = "onCompositionEnd") : Cm(r, c) && (y = "onCompositionStart"), !y)
        return null;
      rp && !ap(c) && (!Zo && y === "onCompositionStart" ? Zo = Vl(h) : y === "onCompositionEnd" && Zo && (x = Ku()));
      var C = Dg(s, y);
      if (C.length > 0) {
        var T = new xm(y, r, null, c, h);
        if (e.push({
          event: T,
          listeners: C
        }), x)
          T.data = x;
        else {
          var M = km(c);
          M !== null && (T.data = M);
        }
      }
    }
    function op(e, r) {
      switch (e) {
        case "compositionend":
          return km(r);
        case "keypress":
          var s = r.which;
          return s !== _g ? null : (Sf = !0, Em);
        case "textInput":
          var c = r.data;
          return c === Em && Sf ? null : c;
        default:
          return null;
      }
    }
    function Tg(e, r) {
      if (Zo) {
        if (e === "compositionend" || !bf && kg(e, r)) {
          var s = Ku();
          return Qd(), Zo = !1, s;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!ip(r)) {
            if (r.char && r.char.length > 1)
              return r.char;
            if (r.which)
              return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return rp && !ap(r) ? null : r.data;
        default:
          return null;
      }
    }
    function _1(e, r, s, c, h) {
      var y;
      if (w1 ? y = op(r, c) : y = Tg(r, c), !y)
        return null;
      var x = Dg(s, "onBeforeInput");
      if (x.length > 0) {
        var C = new Hs("onBeforeInput", "beforeinput", null, c, h);
        e.push({
          event: C,
          listeners: x
        }), C.data = y;
      }
    }
    function lp(e, r, s, c, h, y, x) {
      Tm(e, r, s, c, h), _1(e, r, s, c, h);
    }
    var E1 = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function nc(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r === "input" ? !!E1[e.type] : r === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function C1(e) {
      if (!zn)
        return !1;
      var r = "on" + e, s = r in document;
      if (!s) {
        var c = document.createElement("div");
        c.setAttribute(r, "return;"), s = typeof c[r] == "function";
      }
      return s;
    }
    function sp() {
      hr("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function a(e, r, s, c) {
      fd(c);
      var h = Dg(r, "onChange");
      if (h.length > 0) {
        var y = new si("onChange", "change", null, s, c);
        e.push({
          event: y,
          listeners: h
        });
      }
    }
    var l = null, d = null;
    function m(e) {
      var r = e.nodeName && e.nodeName.toLowerCase();
      return r === "select" || r === "input" && e.type === "file";
    }
    function g(e) {
      var r = [];
      a(r, d, e, cd(e)), Ph(_, r);
    }
    function _(e) {
      BC(e, 0);
    }
    function D(e) {
      var r = hp(e);
      if (Cu(r))
        return e;
    }
    function $(e, r) {
      if (e === "change")
        return r;
    }
    var B = !1;
    zn && (B = C1("input") && (!document.documentMode || document.documentMode > 9));
    function ae(e, r) {
      l = e, d = r, l.attachEvent("onpropertychange", _e);
    }
    function Se() {
      l && (l.detachEvent("onpropertychange", _e), l = null, d = null);
    }
    function _e(e) {
      e.propertyName === "value" && D(d) && g(e);
    }
    function be(e, r, s) {
      e === "focusin" ? (Se(), ae(r, s)) : e === "focusout" && Se();
    }
    function He(e, r) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return D(d);
    }
    function et(e) {
      var r = e.nodeName;
      return r && r.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function it(e, r) {
      if (e === "click")
        return D(r);
    }
    function cr(e, r) {
      if (e === "input" || e === "change")
        return D(r);
    }
    function X(e) {
      var r = e._wrapperState;
      !r || !r.controlled || e.type !== "number" || pt(e, "number", e.value);
    }
    function Y(e, r, s, c, h, y, x) {
      var C = s ? hp(s) : window, T, M;
      if (m(C) ? T = $ : nc(C) ? B ? T = cr : (T = He, M = be) : et(C) && (T = it), T) {
        var P = T(r, s);
        if (P) {
          a(e, P, c, h);
          return;
        }
      }
      M && M(r, C, s), r === "focusout" && X(C);
    }
    function J() {
      Jr("onMouseEnter", ["mouseout", "mouseover"]), Jr("onMouseLeave", ["mouseout", "mouseover"]), Jr("onPointerEnter", ["pointerout", "pointerover"]), Jr("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Oe(e, r, s, c, h, y, x) {
      var C = r === "mouseover" || r === "pointerover", T = r === "mouseout" || r === "pointerout";
      if (C && !Vy(c)) {
        var M = c.relatedTarget || c.fromElement;
        if (M && (_f(M) || Um(M)))
          return;
      }
      if (!(!T && !C)) {
        var P;
        if (h.window === h)
          P = h;
        else {
          var Z = h.ownerDocument;
          Z ? P = Z.defaultView || Z.parentWindow : P = window;
        }
        var W, ne;
        if (T) {
          var ie = c.relatedTarget || c.toElement;
          if (W = s, ne = ie ? _f(ie) : null, ne !== null) {
            var fe = ea(ne);
            (ne !== fe || ne.tag !== k && ne.tag !== N) && (ne = null);
          }
        } else
          W = null, ne = s;
        if (W !== ne) {
          var Ze = Wl, dt = "onMouseLeave", st = "onMouseEnter", tn = "mouse";
          (r === "pointerout" || r === "pointerover") && (Ze = wm, dt = "onPointerLeave", st = "onPointerEnter", tn = "pointer");
          var Xt = W == null ? P : hp(W), Q = ne == null ? P : hp(ne), de = new Ze(dt, tn + "leave", W, c, h);
          de.target = Xt, de.relatedTarget = Q;
          var K = null, Ee = _f(h);
          if (Ee === s) {
            var qe = new Ze(st, tn + "enter", ne, c, h);
            qe.target = Q, qe.relatedTarget = Xt, K = qe;
          }
          ID(e, de, K, W, ne);
        }
      }
    }
    function ot(e, r) {
      return e === r && (e !== 0 || 1 / e === 1 / r) || e !== e && r !== r;
    }
    var tt = typeof Object.is == "function" ? Object.is : ot;
    function ut(e, r) {
      if (tt(e, r))
        return !0;
      if (typeof e != "object" || e === null || typeof r != "object" || r === null)
        return !1;
      var s = Object.keys(e), c = Object.keys(r);
      if (s.length !== c.length)
        return !1;
      for (var h = 0; h < s.length; h++) {
        var y = s[h];
        if (!sr.call(r, y) || !tt(e[y], r[y]))
          return !1;
      }
      return !0;
    }
    function Et(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Pr(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function un(e, r) {
      for (var s = Et(e), c = 0, h = 0; s; ) {
        if (s.nodeType === Lo) {
          if (h = c + s.textContent.length, c <= r && h >= r)
            return {
              node: s,
              offset: r - c
            };
          c = h;
        }
        s = Et(Pr(s));
      }
    }
    function Zl(e) {
      var r = e.ownerDocument, s = r && r.defaultView || window, c = s.getSelection && s.getSelection();
      if (!c || c.rangeCount === 0)
        return null;
      var h = c.anchorNode, y = c.anchorOffset, x = c.focusNode, C = c.focusOffset;
      try {
        h.nodeType, x.nodeType;
      } catch {
        return null;
      }
      return k1(e, h, y, x, C);
    }
    function k1(e, r, s, c, h) {
      var y = 0, x = -1, C = -1, T = 0, M = 0, P = e, Z = null;
      e:
        for (; ; ) {
          for (var W = null; P === r && (s === 0 || P.nodeType === Lo) && (x = y + s), P === c && (h === 0 || P.nodeType === Lo) && (C = y + h), P.nodeType === Lo && (y += P.nodeValue.length), (W = P.firstChild) !== null; )
            Z = P, P = W;
          for (; ; ) {
            if (P === e)
              break e;
            if (Z === r && ++T === s && (x = y), Z === c && ++M === h && (C = y), (W = P.nextSibling) !== null)
              break;
            P = Z, Z = P.parentNode;
          }
          P = W;
        }
      return x === -1 || C === -1 ? null : {
        start: x,
        end: C
      };
    }
    function SD(e, r) {
      var s = e.ownerDocument || document, c = s && s.defaultView || window;
      if (c.getSelection) {
        var h = c.getSelection(), y = e.textContent.length, x = Math.min(r.start, y), C = r.end === void 0 ? x : Math.min(r.end, y);
        if (!h.extend && x > C) {
          var T = C;
          C = x, x = T;
        }
        var M = un(e, x), P = un(e, C);
        if (M && P) {
          if (h.rangeCount === 1 && h.anchorNode === M.node && h.anchorOffset === M.offset && h.focusNode === P.node && h.focusOffset === P.offset)
            return;
          var Z = s.createRange();
          Z.setStart(M.node, M.offset), h.removeAllRanges(), x > C ? (h.addRange(Z), h.extend(P.node, P.offset)) : (Z.setEnd(P.node, P.offset), h.addRange(Z));
        }
      }
    }
    function AC(e) {
      return e && e.nodeType === Lo;
    }
    function DC(e, r) {
      return !e || !r ? !1 : e === r ? !0 : AC(e) ? !1 : AC(r) ? DC(e, r.parentNode) : "contains" in e ? e.contains(r) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(r) & 16) : !1;
    }
    function xD(e) {
      return e && e.ownerDocument && DC(e.ownerDocument.documentElement, e);
    }
    function wD(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function MC() {
      for (var e = window, r = kl(); r instanceof e.HTMLIFrameElement; ) {
        if (wD(r))
          e = r.contentWindow;
        else
          return r;
        r = kl(e.document);
      }
      return r;
    }
    function T1(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r && (r === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || r === "textarea" || e.contentEditable === "true");
    }
    function _D() {
      var e = MC();
      return {
        focusedElem: e,
        selectionRange: T1(e) ? CD(e) : null
      };
    }
    function ED(e) {
      var r = MC(), s = e.focusedElem, c = e.selectionRange;
      if (r !== s && xD(s)) {
        c !== null && T1(s) && kD(s, c);
        for (var h = [], y = s; y = y.parentNode; )
          y.nodeType === Di && h.push({
            element: y,
            left: y.scrollLeft,
            top: y.scrollTop
          });
        typeof s.focus == "function" && s.focus();
        for (var x = 0; x < h.length; x++) {
          var C = h[x];
          C.element.scrollLeft = C.left, C.element.scrollTop = C.top;
        }
      }
    }
    function CD(e) {
      var r;
      return "selectionStart" in e ? r = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : r = Zl(e), r || {
        start: 0,
        end: 0
      };
    }
    function kD(e, r) {
      var s = r.start, c = r.end;
      c === void 0 && (c = s), "selectionStart" in e ? (e.selectionStart = s, e.selectionEnd = Math.min(c, e.value.length)) : SD(e, r);
    }
    var TD = zn && "documentMode" in document && document.documentMode <= 11;
    function RD() {
      hr("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var up = null, R1 = null, Rm = null, O1 = !1;
    function OD(e) {
      if ("selectionStart" in e && T1(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var r = e.ownerDocument && e.ownerDocument.defaultView || window, s = r.getSelection();
      return {
        anchorNode: s.anchorNode,
        anchorOffset: s.anchorOffset,
        focusNode: s.focusNode,
        focusOffset: s.focusOffset
      };
    }
    function AD(e) {
      return e.window === e ? e.document : e.nodeType === Ha ? e : e.ownerDocument;
    }
    function NC(e, r, s) {
      var c = AD(s);
      if (!(O1 || up == null || up !== kl(c))) {
        var h = OD(up);
        if (!Rm || !ut(Rm, h)) {
          Rm = h;
          var y = Dg(R1, "onSelect");
          if (y.length > 0) {
            var x = new si("onSelect", "select", null, r, s);
            e.push({
              event: x,
              listeners: y
            }), x.target = up;
          }
        }
      }
    }
    function DD(e, r, s, c, h, y, x) {
      var C = s ? hp(s) : window;
      switch (r) {
        case "focusin":
          (nc(C) || C.contentEditable === "true") && (up = C, R1 = s, Rm = null);
          break;
        case "focusout":
          up = null, R1 = null, Rm = null;
          break;
        case "mousedown":
          O1 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          O1 = !1, NC(e, c, h);
          break;
        case "selectionchange":
          if (TD)
            break;
        case "keydown":
        case "keyup":
          NC(e, c, h);
      }
    }
    function Rg(e, r) {
      var s = {};
      return s[e.toLowerCase()] = r.toLowerCase(), s["Webkit" + e] = "webkit" + r, s["Moz" + e] = "moz" + r, s;
    }
    var cp = {
      animationend: Rg("Animation", "AnimationEnd"),
      animationiteration: Rg("Animation", "AnimationIteration"),
      animationstart: Rg("Animation", "AnimationStart"),
      transitionend: Rg("Transition", "TransitionEnd")
    }, A1 = {}, LC = {};
    zn && (LC = document.createElement("div").style, "AnimationEvent" in window || (delete cp.animationend.animation, delete cp.animationiteration.animation, delete cp.animationstart.animation), "TransitionEvent" in window || delete cp.transitionend.transition);
    function Og(e) {
      if (A1[e])
        return A1[e];
      if (!cp[e])
        return e;
      var r = cp[e];
      for (var s in r)
        if (r.hasOwnProperty(s) && s in LC)
          return A1[e] = r[s];
      return e;
    }
    var PC = Og("animationend"), zC = Og("animationiteration"), $C = Og("animationstart"), jC = Og("transitionend"), IC = /* @__PURE__ */ new Map(), FC = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function rc(e, r) {
      IC.set(e, r), hr(r, [e]);
    }
    function MD() {
      for (var e = 0; e < FC.length; e++) {
        var r = FC[e], s = r.toLowerCase(), c = r[0].toUpperCase() + r.slice(1);
        rc(s, "on" + c);
      }
      rc(PC, "onAnimationEnd"), rc(zC, "onAnimationIteration"), rc($C, "onAnimationStart"), rc("dblclick", "onDoubleClick"), rc("focusin", "onFocus"), rc("focusout", "onBlur"), rc(jC, "onTransitionEnd");
    }
    function ND(e, r, s, c, h, y, x) {
      var C = IC.get(r);
      if (C !== void 0) {
        var T = si, M = r;
        switch (r) {
          case "keypress":
            if (Fs(c) === 0)
              return;
          case "keydown":
          case "keyup":
            T = b1;
            break;
          case "focusin":
            M = "focus", T = Jd;
            break;
          case "focusout":
            M = "blur", T = Jd;
            break;
          case "beforeblur":
          case "afterblur":
            T = Jd;
            break;
          case "click":
            if (c.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            T = Wl;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            T = Bs;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            T = Ta;
            break;
          case PC:
          case zC:
          case $C:
            T = ep;
            break;
          case jC:
            T = x1;
            break;
          case "scroll":
            T = ym;
            break;
          case "wheel":
            T = np;
            break;
          case "copy":
          case "cut":
          case "paste":
            T = m1;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            T = wm;
            break;
        }
        var P = (y & Ss) !== 0;
        {
          var Z = !P && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          r === "scroll", W = $D(s, C, c.type, P, Z);
          if (W.length > 0) {
            var ne = new T(C, M, null, c, h);
            e.push({
              event: ne,
              listeners: W
            });
          }
        }
      }
    }
    MD(), J(), sp(), RD(), Eg();
    function LD(e, r, s, c, h, y, x) {
      ND(e, r, s, c, h, y);
      var C = (y & n1) === 0;
      C && (Oe(e, r, s, c, h), Y(e, r, s, c, h), DD(e, r, s, c, h), lp(e, r, s, c, h));
    }
    var Om = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], D1 = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Om));
    function UC(e, r, s) {
      var c = e.type || "unknown-event";
      e.currentTarget = s, jo(c, r, void 0, e), e.currentTarget = null;
    }
    function PD(e, r, s) {
      var c;
      if (s)
        for (var h = r.length - 1; h >= 0; h--) {
          var y = r[h], x = y.instance, C = y.currentTarget, T = y.listener;
          if (x !== c && e.isPropagationStopped())
            return;
          UC(e, T, C), c = x;
        }
      else
        for (var M = 0; M < r.length; M++) {
          var P = r[M], Z = P.instance, W = P.currentTarget, ne = P.listener;
          if (Z !== c && e.isPropagationStopped())
            return;
          UC(e, ne, W), c = Z;
        }
    }
    function BC(e, r) {
      for (var s = (r & Ss) !== 0, c = 0; c < e.length; c++) {
        var h = e[c], y = h.event, x = h.listeners;
        PD(y, x, s);
      }
      Ih();
    }
    function zD(e, r, s, c, h) {
      var y = cd(s), x = [];
      LD(x, e, c, s, y, r), BC(x, r);
    }
    function Kn(e, r) {
      D1.has(e) || p('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var s = !1, c = dN(r), h = FD(e, s);
      c.has(h) || (HC(r, e, Vc, s), c.add(h));
    }
    function M1(e, r, s) {
      D1.has(e) && !r && p('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var c = 0;
      r && (c |= Ss), HC(s, e, c, r);
    }
    var Ag = "_reactListening" + Math.random().toString(36).slice(2);
    function Am(e) {
      if (!e[Ag]) {
        e[Ag] = !0, xt.forEach(function(s) {
          s !== "selectionchange" && (D1.has(s) || M1(s, !1, e), M1(s, !0, e));
        });
        var r = e.nodeType === Ha ? e : e.ownerDocument;
        r !== null && (r[Ag] || (r[Ag] = !0, M1("selectionchange", !1, r)));
      }
    }
    function HC(e, r, s, c, h) {
      var y = Gu(e, r, s), x = void 0;
      Gc && (r === "touchstart" || r === "touchmove" || r === "wheel") && (x = !0), e = e, c ? x !== void 0 ? Yo(e, r, y, x) : Qu(e, r, y) : x !== void 0 ? Xd(e, r, y, x) : vm(e, r, y);
    }
    function VC(e, r) {
      return e === r || e.nodeType === yr && e.parentNode === r;
    }
    function N1(e, r, s, c, h) {
      var y = c;
      if (!(r & zo) && !(r & Vc)) {
        var x = h;
        if (c !== null) {
          var C = c;
          e:
            for (; ; ) {
              if (C === null)
                return;
              var T = C.tag;
              if (T === w || T === R) {
                var M = C.stateNode.containerInfo;
                if (VC(M, x))
                  break;
                if (T === R)
                  for (var P = C.return; P !== null; ) {
                    var Z = P.tag;
                    if (Z === w || Z === R) {
                      var W = P.stateNode.containerInfo;
                      if (VC(W, x))
                        return;
                    }
                    P = P.return;
                  }
                for (; M !== null; ) {
                  var ne = _f(M);
                  if (ne === null)
                    return;
                  var ie = ne.tag;
                  if (ie === k || ie === N) {
                    C = y = ne;
                    continue e;
                  }
                  M = M.parentNode;
                }
              }
              C = C.return;
            }
        }
      }
      Ph(function() {
        return zD(e, r, s, y);
      });
    }
    function Dm(e, r, s) {
      return {
        instance: e,
        listener: r,
        currentTarget: s
      };
    }
    function $D(e, r, s, c, h, y) {
      for (var x = r !== null ? r + "Capture" : null, C = c ? x : r, T = [], M = e, P = null; M !== null; ) {
        var Z = M, W = Z.stateNode, ne = Z.tag;
        if (ne === k && W !== null && (P = W, C !== null)) {
          var ie = ws(M, C);
          ie != null && T.push(Dm(M, ie, P));
        }
        if (h)
          break;
        M = M.return;
      }
      return T;
    }
    function Dg(e, r) {
      for (var s = r + "Capture", c = [], h = e; h !== null; ) {
        var y = h, x = y.stateNode, C = y.tag;
        if (C === k && x !== null) {
          var T = x, M = ws(h, s);
          M != null && c.unshift(Dm(h, M, T));
          var P = ws(h, r);
          P != null && c.push(Dm(h, P, T));
        }
        h = h.return;
      }
      return c;
    }
    function fp(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== k);
      return e || null;
    }
    function jD(e, r) {
      for (var s = e, c = r, h = 0, y = s; y; y = fp(y))
        h++;
      for (var x = 0, C = c; C; C = fp(C))
        x++;
      for (; h - x > 0; )
        s = fp(s), h--;
      for (; x - h > 0; )
        c = fp(c), x--;
      for (var T = h; T--; ) {
        if (s === c || c !== null && s === c.alternate)
          return s;
        s = fp(s), c = fp(c);
      }
      return null;
    }
    function WC(e, r, s, c, h) {
      for (var y = r._reactName, x = [], C = s; C !== null && C !== c; ) {
        var T = C, M = T.alternate, P = T.stateNode, Z = T.tag;
        if (M !== null && M === c)
          break;
        if (Z === k && P !== null) {
          var W = P;
          if (h) {
            var ne = ws(C, y);
            ne != null && x.unshift(Dm(C, ne, W));
          } else if (!h) {
            var ie = ws(C, y);
            ie != null && x.push(Dm(C, ie, W));
          }
        }
        C = C.return;
      }
      x.length !== 0 && e.push({
        event: r,
        listeners: x
      });
    }
    function ID(e, r, s, c, h) {
      var y = c && h ? jD(c, h) : null;
      c !== null && WC(e, r, c, y, !1), h !== null && s !== null && WC(e, s, h, y, !0);
    }
    function FD(e, r) {
      return e + "__" + (r ? "capture" : "bubble");
    }
    var Ra = !1, Mm = "dangerouslySetInnerHTML", Mg = "suppressContentEditableWarning", ic = "suppressHydrationWarning", YC = "autoFocus", xf = "children", wf = "style", Ng = "__html", L1, Lg, Nm, ZC, Pg, qC, GC;
    L1 = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Lg = function(e, r) {
      ud(e, r), Ah(e, r), Hy(e, r, {
        registrationNameDependencies: Zt,
        possibleRegistrationNames: er
      });
    }, qC = zn && !document.documentMode, Nm = function(e, r, s) {
      if (!Ra) {
        var c = zg(s), h = zg(r);
        h !== c && (Ra = !0, p("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(h), JSON.stringify(c)));
      }
    }, ZC = function(e) {
      if (!Ra) {
        Ra = !0;
        var r = [];
        e.forEach(function(s) {
          r.push(s);
        }), p("Extra attributes from the server: %s", r);
      }
    }, Pg = function(e, r) {
      r === !1 ? p("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : p("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof r);
    }, GC = function(e, r) {
      var s = e.namespaceURI === No ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return s.innerHTML = r, s.innerHTML;
    };
    var UD = /\r\n?/g, BD = /\u0000|\uFFFD/g;
    function zg(e) {
      ei(e);
      var r = typeof e == "string" ? e : "" + e;
      return r.replace(UD, `
`).replace(BD, "");
    }
    function $g(e, r, s, c) {
      var h = zg(r), y = zg(e);
      if (y !== h && (c && (Ra || (Ra = !0, p('Text content did not match. Server: "%s" Client: "%s"', y, h))), s && Te))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function XC(e) {
      return e.nodeType === Ha ? e : e.ownerDocument;
    }
    function HD() {
    }
    function jg(e) {
      e.onclick = HD;
    }
    function VD(e, r, s, c, h) {
      for (var y in c)
        if (c.hasOwnProperty(y)) {
          var x = c[y];
          if (y === wf)
            x && Object.freeze(x), Ny(r, x);
          else if (y === Mm) {
            var C = x ? x[Ng] : void 0;
            C != null && wy(r, C);
          } else if (y === xf)
            if (typeof x == "string") {
              var T = e !== "textarea" || x !== "";
              T && ad(r, x);
            } else
              typeof x == "number" && ad(r, "" + x);
          else
            y === Mg || y === ic || y === YC || (Zt.hasOwnProperty(y) ? x != null && (typeof x != "function" && Pg(y, x), y === "onScroll" && Kn("scroll", r)) : x != null && Qi(r, y, x, h));
        }
    }
    function WD(e, r, s, c) {
      for (var h = 0; h < r.length; h += 2) {
        var y = r[h], x = r[h + 1];
        y === wf ? Ny(e, x) : y === Mm ? wy(e, x) : y === xf ? ad(e, x) : Qi(e, y, x, c);
      }
    }
    function YD(e, r, s, c) {
      var h, y = XC(s), x, C = c;
      if (C === No && (C = rd(e)), C === No) {
        if (h = Po(e, r), !h && e !== e.toLowerCase() && p("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var T = y.createElement("div");
          T.innerHTML = "<script><\/script>";
          var M = T.firstChild;
          x = T.removeChild(M);
        } else if (typeof r.is == "string")
          x = y.createElement(e, {
            is: r.is
          });
        else if (x = y.createElement(e), e === "select") {
          var P = x;
          r.multiple ? P.multiple = !0 : r.size && (P.size = r.size);
        }
      } else
        x = y.createElementNS(C, e);
      return C === No && !h && Object.prototype.toString.call(x) === "[object HTMLUnknownElement]" && !sr.call(L1, e) && (L1[e] = !0, p("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), x;
    }
    function ZD(e, r) {
      return XC(r).createTextNode(e);
    }
    function qD(e, r, s, c) {
      var h = Po(r, s);
      Lg(r, s);
      var y;
      switch (r) {
        case "dialog":
          Kn("cancel", e), Kn("close", e), y = s;
          break;
        case "iframe":
        case "object":
        case "embed":
          Kn("load", e), y = s;
          break;
        case "video":
        case "audio":
          for (var x = 0; x < Om.length; x++)
            Kn(Om[x], e);
          y = s;
          break;
        case "source":
          Kn("error", e), y = s;
          break;
        case "img":
        case "image":
        case "link":
          Kn("error", e), Kn("load", e), y = s;
          break;
        case "details":
          Kn("toggle", e), y = s;
          break;
        case "input":
          F(e, s), y = A(e, s), Kn("invalid", e);
          break;
        case "option":
          _n(e, s), y = s;
          break;
        case "select":
          Fc(e, s), y = Ic(e, s), Kn("invalid", e);
          break;
        case "textarea":
          by(e, s), y = xh(e, s), Kn("invalid", e);
          break;
        default:
          y = s;
      }
      switch (ld(r, y), VD(r, e, c, y, h), r) {
        case "input":
          ma(e), ke(e, s, !1);
          break;
        case "textarea":
          ma(e), xy(e);
          break;
        case "option":
          On(e, s);
          break;
        case "select":
          bh(e, s);
          break;
        default:
          typeof y.onClick == "function" && jg(e);
          break;
      }
    }
    function GD(e, r, s, c, h) {
      Lg(r, c);
      var y = null, x, C;
      switch (r) {
        case "input":
          x = A(e, s), C = A(e, c), y = [];
          break;
        case "select":
          x = Ic(e, s), C = Ic(e, c), y = [];
          break;
        case "textarea":
          x = xh(e, s), C = xh(e, c), y = [];
          break;
        default:
          x = s, C = c, typeof x.onClick != "function" && typeof C.onClick == "function" && jg(e);
          break;
      }
      ld(r, C);
      var T, M, P = null;
      for (T in x)
        if (!(C.hasOwnProperty(T) || !x.hasOwnProperty(T) || x[T] == null))
          if (T === wf) {
            var Z = x[T];
            for (M in Z)
              Z.hasOwnProperty(M) && (P || (P = {}), P[M] = "");
          } else
            T === Mm || T === xf || T === Mg || T === ic || T === YC || (Zt.hasOwnProperty(T) ? y || (y = []) : (y = y || []).push(T, null));
      for (T in C) {
        var W = C[T], ne = x != null ? x[T] : void 0;
        if (!(!C.hasOwnProperty(T) || W === ne || W == null && ne == null))
          if (T === wf)
            if (W && Object.freeze(W), ne) {
              for (M in ne)
                ne.hasOwnProperty(M) && (!W || !W.hasOwnProperty(M)) && (P || (P = {}), P[M] = "");
              for (M in W)
                W.hasOwnProperty(M) && ne[M] !== W[M] && (P || (P = {}), P[M] = W[M]);
            } else
              P || (y || (y = []), y.push(T, P)), P = W;
          else if (T === Mm) {
            var ie = W ? W[Ng] : void 0, fe = ne ? ne[Ng] : void 0;
            ie != null && fe !== ie && (y = y || []).push(T, ie);
          } else
            T === xf ? (typeof W == "string" || typeof W == "number") && (y = y || []).push(T, "" + W) : T === Mg || T === ic || (Zt.hasOwnProperty(T) ? (W != null && (typeof W != "function" && Pg(T, W), T === "onScroll" && Kn("scroll", e)), !y && ne !== W && (y = [])) : (y = y || []).push(T, W));
      }
      return P && (Bc(P, C[wf]), (y = y || []).push(wf, P)), y;
    }
    function XD(e, r, s, c, h) {
      s === "input" && h.type === "radio" && h.name != null && re(e, h);
      var y = Po(s, c), x = Po(s, h);
      switch (WD(e, r, y, x), s) {
        case "input":
          se(e, h);
          break;
        case "textarea":
          Sy(e, h);
          break;
        case "select":
          YS(e, h);
          break;
      }
    }
    function QD(e) {
      {
        var r = e.toLowerCase();
        return sd.hasOwnProperty(r) && sd[r] || null;
      }
    }
    function KD(e, r, s, c, h, y, x) {
      var C, T;
      switch (C = Po(r, s), Lg(r, s), r) {
        case "dialog":
          Kn("cancel", e), Kn("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          Kn("load", e);
          break;
        case "video":
        case "audio":
          for (var M = 0; M < Om.length; M++)
            Kn(Om[M], e);
          break;
        case "source":
          Kn("error", e);
          break;
        case "img":
        case "image":
        case "link":
          Kn("error", e), Kn("load", e);
          break;
        case "details":
          Kn("toggle", e);
          break;
        case "input":
          F(e, s), Kn("invalid", e);
          break;
        case "option":
          _n(e, s);
          break;
        case "select":
          Fc(e, s), Kn("invalid", e);
          break;
        case "textarea":
          by(e, s), Kn("invalid", e);
          break;
      }
      ld(r, s);
      {
        T = /* @__PURE__ */ new Set();
        for (var P = e.attributes, Z = 0; Z < P.length; Z++) {
          var W = P[Z].name.toLowerCase();
          switch (W) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              T.add(P[Z].name);
          }
        }
      }
      var ne = null;
      for (var ie in s)
        if (s.hasOwnProperty(ie)) {
          var fe = s[ie];
          if (ie === xf)
            typeof fe == "string" ? e.textContent !== fe && (s[ic] !== !0 && $g(e.textContent, fe, y, x), ne = [xf, fe]) : typeof fe == "number" && e.textContent !== "" + fe && (s[ic] !== !0 && $g(e.textContent, fe, y, x), ne = [xf, "" + fe]);
          else if (Zt.hasOwnProperty(ie))
            fe != null && (typeof fe != "function" && Pg(ie, fe), ie === "onScroll" && Kn("scroll", e));
          else if (x && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof C == "boolean") {
            var Ze = void 0, dt = C && j ? null : fi(ie);
            if (s[ic] !== !0) {
              if (!(ie === Mg || ie === ic || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              ie === "value" || ie === "checked" || ie === "selected")) {
                if (ie === Mm) {
                  var st = e.innerHTML, tn = fe ? fe[Ng] : void 0;
                  if (tn != null) {
                    var Xt = GC(e, tn);
                    Xt !== st && Nm(ie, st, Xt);
                  }
                } else if (ie === wf) {
                  if (T.delete(ie), qC) {
                    var Q = e1(fe);
                    Ze = e.getAttribute("style"), Q !== Ze && Nm(ie, Ze, Q);
                  }
                } else if (C && !j)
                  T.delete(ie.toLowerCase()), Ze = ro(e, ie, fe), fe !== Ze && Nm(ie, Ze, fe);
                else if (!sn(ie, dt, C) && !wn(ie, fe, dt, C)) {
                  var de = !1;
                  if (dt !== null)
                    T.delete(dt.attributeName), Ze = Xi(e, ie, fe, dt);
                  else {
                    var K = c;
                    if (K === No && (K = rd(r)), K === No)
                      T.delete(ie.toLowerCase());
                    else {
                      var Ee = QD(ie);
                      Ee !== null && Ee !== ie && (de = !0, T.delete(Ee)), T.delete(ie);
                    }
                    Ze = ro(e, ie, fe);
                  }
                  var qe = j;
                  !qe && fe !== Ze && !de && Nm(ie, Ze, fe);
                }
              }
            }
          }
        }
      switch (x && // $FlowFixMe - Should be inferred as not undefined.
      T.size > 0 && s[ic] !== !0 && ZC(T), r) {
        case "input":
          ma(e), ke(e, s, !0);
          break;
        case "textarea":
          ma(e), xy(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof s.onClick == "function" && jg(e);
          break;
      }
      return ne;
    }
    function JD(e, r, s) {
      var c = e.nodeValue !== r;
      return c;
    }
    function P1(e, r) {
      {
        if (Ra)
          return;
        Ra = !0, p("Did not expect server HTML to contain a <%s> in <%s>.", r.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function z1(e, r) {
      {
        if (Ra)
          return;
        Ra = !0, p('Did not expect server HTML to contain the text node "%s" in <%s>.', r.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function $1(e, r, s) {
      {
        if (Ra)
          return;
        Ra = !0, p("Expected server HTML to contain a matching <%s> in <%s>.", r, e.nodeName.toLowerCase());
      }
    }
    function j1(e, r) {
      {
        if (r === "" || Ra)
          return;
        Ra = !0, p('Expected server HTML to contain a matching text node for "%s" in <%s>.', r, e.nodeName.toLowerCase());
      }
    }
    function eM(e, r, s) {
      switch (r) {
        case "input":
          mt(e, s);
          return;
        case "textarea":
          wh(e, s);
          return;
        case "select":
          ZS(e, s);
          return;
      }
    }
    var Lm = function() {
    }, Pm = function() {
    };
    {
      var tM = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], QC = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], nM = QC.concat(["button"]), rM = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], KC = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Pm = function(e, r) {
        var s = Ft({}, e || KC), c = {
          tag: r
        };
        return QC.indexOf(r) !== -1 && (s.aTagInScope = null, s.buttonTagInScope = null, s.nobrTagInScope = null), nM.indexOf(r) !== -1 && (s.pTagInButtonScope = null), tM.indexOf(r) !== -1 && r !== "address" && r !== "div" && r !== "p" && (s.listItemTagAutoclosing = null, s.dlItemTagAutoclosing = null), s.current = c, r === "form" && (s.formTag = c), r === "a" && (s.aTagInScope = c), r === "button" && (s.buttonTagInScope = c), r === "nobr" && (s.nobrTagInScope = c), r === "p" && (s.pTagInButtonScope = c), r === "li" && (s.listItemTagAutoclosing = c), (r === "dd" || r === "dt") && (s.dlItemTagAutoclosing = c), s;
      };
      var iM = function(e, r) {
        switch (r) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r !== "h1" && r !== "h2" && r !== "h3" && r !== "h4" && r !== "h5" && r !== "h6";
          case "rp":
          case "rt":
            return rM.indexOf(r) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return r == null;
        }
        return !0;
      }, aM = function(e, r) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r.pTagInButtonScope;
          case "form":
            return r.formTag || r.pTagInButtonScope;
          case "li":
            return r.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return r.dlItemTagAutoclosing;
          case "button":
            return r.buttonTagInScope;
          case "a":
            return r.aTagInScope;
          case "nobr":
            return r.nobrTagInScope;
        }
        return null;
      }, JC = {};
      Lm = function(e, r, s) {
        s = s || KC;
        var c = s.current, h = c && c.tag;
        r != null && (e != null && p("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var y = iM(e, h) ? null : c, x = y ? null : aM(e, s), C = y || x;
        if (C) {
          var T = C.tag, M = !!y + "|" + e + "|" + T;
          if (!JC[M]) {
            JC[M] = !0;
            var P = e, Z = "";
            if (e === "#text" ? /\S/.test(r) ? P = "Text nodes" : (P = "Whitespace text nodes", Z = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : P = "<" + e + ">", y) {
              var W = "";
              T === "table" && e === "tr" && (W += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), p("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", P, T, Z, W);
            } else
              p("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", P, T);
          }
        }
      };
    }
    var Ig = "suppressHydrationWarning", Fg = "$", Ug = "/$", zm = "$?", $m = "$!", oM = "style", I1 = null, F1 = null;
    function lM(e) {
      var r, s, c = e.nodeType;
      switch (c) {
        case Ha:
        case gs: {
          r = c === Ha ? "#document" : "#fragment";
          var h = e.documentElement;
          s = h ? h.namespaceURI : Eh(null, "");
          break;
        }
        default: {
          var y = c === yr ? e.parentNode : e, x = y.namespaceURI || null;
          r = y.tagName, s = Eh(x, r);
          break;
        }
      }
      {
        var C = r.toLowerCase(), T = Pm(null, C);
        return {
          namespace: s,
          ancestorInfo: T
        };
      }
    }
    function sM(e, r, s) {
      {
        var c = e, h = Eh(c.namespace, r), y = Pm(c.ancestorInfo, r);
        return {
          namespace: h,
          ancestorInfo: y
        };
      }
    }
    function eV(e) {
      return e;
    }
    function uM(e) {
      I1 = ia(), F1 = _D();
      var r = null;
      return Lr(!1), r;
    }
    function cM(e) {
      ED(F1), Lr(I1), I1 = null, F1 = null;
    }
    function fM(e, r, s, c, h) {
      var y;
      {
        var x = c;
        if (Lm(e, null, x.ancestorInfo), typeof r.children == "string" || typeof r.children == "number") {
          var C = "" + r.children, T = Pm(x.ancestorInfo, e);
          Lm(null, C, T);
        }
        y = x.namespace;
      }
      var M = YD(e, r, s, y);
      return Fm(h, M), q1(M, r), M;
    }
    function dM(e, r) {
      e.appendChild(r);
    }
    function pM(e, r, s, c, h) {
      switch (qD(e, r, s, c), r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!s.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function hM(e, r, s, c, h, y) {
      {
        var x = y;
        if (typeof c.children != typeof s.children && (typeof c.children == "string" || typeof c.children == "number")) {
          var C = "" + c.children, T = Pm(x.ancestorInfo, r);
          Lm(null, C, T);
        }
      }
      return GD(e, r, s, c);
    }
    function U1(e, r) {
      return e === "textarea" || e === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    function mM(e, r, s, c) {
      {
        var h = s;
        Lm(null, e, h.ancestorInfo);
      }
      var y = ZD(e, r);
      return Fm(c, y), y;
    }
    function vM() {
      var e = window.event;
      return e === void 0 ? Ho : vi(e.type);
    }
    var B1 = typeof setTimeout == "function" ? setTimeout : void 0, yM = typeof clearTimeout == "function" ? clearTimeout : void 0, H1 = -1, ek = typeof Promise == "function" ? Promise : void 0, gM = typeof queueMicrotask == "function" ? queueMicrotask : typeof ek < "u" ? function(e) {
      return ek.resolve(null).then(e).catch(bM);
    } : B1;
    function bM(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function SM(e, r, s, c) {
      switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          s.autoFocus && e.focus();
          return;
        case "img": {
          s.src && (e.src = s.src);
          return;
        }
      }
    }
    function xM(e, r, s, c, h, y) {
      XD(e, r, s, c, h), q1(e, h);
    }
    function tk(e) {
      ad(e, "");
    }
    function wM(e, r, s) {
      e.nodeValue = s;
    }
    function _M(e, r) {
      e.appendChild(r);
    }
    function EM(e, r) {
      var s;
      e.nodeType === yr ? (s = e.parentNode, s.insertBefore(r, e)) : (s = e, s.appendChild(r));
      var c = e._reactRootContainer;
      c == null && s.onclick === null && jg(s);
    }
    function CM(e, r, s) {
      e.insertBefore(r, s);
    }
    function kM(e, r, s) {
      e.nodeType === yr ? e.parentNode.insertBefore(r, s) : e.insertBefore(r, s);
    }
    function TM(e, r) {
      e.removeChild(r);
    }
    function RM(e, r) {
      e.nodeType === yr ? e.parentNode.removeChild(r) : e.removeChild(r);
    }
    function V1(e, r) {
      var s = r, c = 0;
      do {
        var h = s.nextSibling;
        if (e.removeChild(s), h && h.nodeType === yr) {
          var y = h.data;
          if (y === Ug)
            if (c === 0) {
              e.removeChild(h), Gt(r);
              return;
            } else
              c--;
          else
            (y === Fg || y === zm || y === $m) && c++;
        }
        s = h;
      } while (s);
      Gt(r);
    }
    function OM(e, r) {
      e.nodeType === yr ? V1(e.parentNode, r) : e.nodeType === Di && V1(e, r), Gt(e);
    }
    function AM(e) {
      e = e;
      var r = e.style;
      typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
    }
    function DM(e) {
      e.nodeValue = "";
    }
    function MM(e, r) {
      e = e;
      var s = r[oM], c = s != null && s.hasOwnProperty("display") ? s.display : null;
      e.style.display = od("display", c);
    }
    function NM(e, r) {
      e.nodeValue = r;
    }
    function LM(e) {
      e.nodeType === Di ? e.textContent = "" : e.nodeType === Ha && e.documentElement && e.removeChild(e.documentElement);
    }
    function PM(e, r, s) {
      return e.nodeType !== Di || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function zM(e, r) {
      return r === "" || e.nodeType !== Lo ? null : e;
    }
    function $M(e) {
      return e.nodeType !== yr ? null : e;
    }
    function nk(e) {
      return e.data === zm;
    }
    function W1(e) {
      return e.data === $m;
    }
    function jM(e) {
      var r = e.nextSibling && e.nextSibling.dataset, s, c, h;
      return r && (s = r.dgst, c = r.msg, h = r.stck), {
        message: c,
        digest: s,
        stack: h
      };
    }
    function IM(e, r) {
      e._reactRetry = r;
    }
    function Bg(e) {
      for (; e != null; e = e.nextSibling) {
        var r = e.nodeType;
        if (r === Di || r === Lo)
          break;
        if (r === yr) {
          var s = e.data;
          if (s === Fg || s === $m || s === zm)
            break;
          if (s === Ug)
            return null;
        }
      }
      return e;
    }
    function jm(e) {
      return Bg(e.nextSibling);
    }
    function FM(e) {
      return Bg(e.firstChild);
    }
    function UM(e) {
      return Bg(e.firstChild);
    }
    function BM(e) {
      return Bg(e.nextSibling);
    }
    function HM(e, r, s, c, h, y, x) {
      Fm(y, e), q1(e, s);
      var C;
      {
        var T = h;
        C = T.namespace;
      }
      var M = (y.mode & Bt) !== ht;
      return KD(e, r, s, C, c, M, x);
    }
    function VM(e, r, s, c) {
      return Fm(s, e), s.mode & Bt, JD(e, r);
    }
    function WM(e, r) {
      Fm(r, e);
    }
    function YM(e) {
      for (var r = e.nextSibling, s = 0; r; ) {
        if (r.nodeType === yr) {
          var c = r.data;
          if (c === Ug) {
            if (s === 0)
              return jm(r);
            s--;
          } else
            (c === Fg || c === $m || c === zm) && s++;
        }
        r = r.nextSibling;
      }
      return null;
    }
    function rk(e) {
      for (var r = e.previousSibling, s = 0; r; ) {
        if (r.nodeType === yr) {
          var c = r.data;
          if (c === Fg || c === $m || c === zm) {
            if (s === 0)
              return r;
            s--;
          } else
            c === Ug && s++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function ZM(e) {
      Gt(e);
    }
    function qM(e) {
      Gt(e);
    }
    function GM(e) {
      return e !== "head" && e !== "body";
    }
    function XM(e, r, s, c) {
      var h = !0;
      $g(r.nodeValue, s, c, h);
    }
    function QM(e, r, s, c, h, y) {
      if (r[Ig] !== !0) {
        var x = !0;
        $g(c.nodeValue, h, y, x);
      }
    }
    function KM(e, r) {
      r.nodeType === Di ? P1(e, r) : r.nodeType === yr || z1(e, r);
    }
    function JM(e, r) {
      {
        var s = e.parentNode;
        s !== null && (r.nodeType === Di ? P1(s, r) : r.nodeType === yr || z1(s, r));
      }
    }
    function eN(e, r, s, c, h) {
      (h || r[Ig] !== !0) && (c.nodeType === Di ? P1(s, c) : c.nodeType === yr || z1(s, c));
    }
    function tN(e, r, s) {
      $1(e, r);
    }
    function nN(e, r) {
      j1(e, r);
    }
    function rN(e, r, s) {
      {
        var c = e.parentNode;
        c !== null && $1(c, r);
      }
    }
    function iN(e, r) {
      {
        var s = e.parentNode;
        s !== null && j1(s, r);
      }
    }
    function aN(e, r, s, c, h, y) {
      (y || r[Ig] !== !0) && $1(s, c);
    }
    function oN(e, r, s, c, h) {
      (h || r[Ig] !== !0) && j1(s, c);
    }
    function lN(e) {
      p("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function sN(e) {
      Am(e);
    }
    var dp = Math.random().toString(36).slice(2), pp = "__reactFiber$" + dp, Y1 = "__reactProps$" + dp, Im = "__reactContainer$" + dp, Z1 = "__reactEvents$" + dp, uN = "__reactListeners$" + dp, cN = "__reactHandles$" + dp;
    function fN(e) {
      delete e[pp], delete e[Y1], delete e[Z1], delete e[uN], delete e[cN];
    }
    function Fm(e, r) {
      r[pp] = e;
    }
    function Hg(e, r) {
      r[Im] = e;
    }
    function ik(e) {
      e[Im] = null;
    }
    function Um(e) {
      return !!e[Im];
    }
    function _f(e) {
      var r = e[pp];
      if (r)
        return r;
      for (var s = e.parentNode; s; ) {
        if (r = s[Im] || s[pp], r) {
          var c = r.alternate;
          if (r.child !== null || c !== null && c.child !== null)
            for (var h = rk(e); h !== null; ) {
              var y = h[pp];
              if (y)
                return y;
              h = rk(h);
            }
          return r;
        }
        e = s, s = e.parentNode;
      }
      return null;
    }
    function ac(e) {
      var r = e[pp] || e[Im];
      return r && (r.tag === k || r.tag === N || r.tag === ee || r.tag === w) ? r : null;
    }
    function hp(e) {
      if (e.tag === k || e.tag === N)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Vg(e) {
      return e[Y1] || null;
    }
    function q1(e, r) {
      e[Y1] = r;
    }
    function dN(e) {
      var r = e[Z1];
      return r === void 0 && (r = e[Z1] = /* @__PURE__ */ new Set()), r;
    }
    var ak = {}, ok = i.ReactDebugCurrentFrame;
    function Wg(e) {
      if (e) {
        var r = e._owner, s = so(e.type, e._source, r ? r.type : null);
        ok.setExtraStackFrame(s);
      } else
        ok.setExtraStackFrame(null);
    }
    function qo(e, r, s, c, h) {
      {
        var y = Function.call.bind(sr);
        for (var x in e)
          if (y(e, x)) {
            var C = void 0;
            try {
              if (typeof e[x] != "function") {
                var T = Error((c || "React class") + ": " + s + " type `" + x + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[x] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw T.name = "Invariant Violation", T;
              }
              C = e[x](r, x, c, s, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (M) {
              C = M;
            }
            C && !(C instanceof Error) && (Wg(h), p("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", c || "React class", s, x, typeof C), Wg(null)), C instanceof Error && !(C.message in ak) && (ak[C.message] = !0, Wg(h), p("Failed %s type: %s", s, C.message), Wg(null));
          }
      }
    }
    var G1 = [], Yg;
    Yg = [];
    var Ys = -1;
    function oc(e) {
      return {
        current: e
      };
    }
    function Fi(e, r) {
      if (Ys < 0) {
        p("Unexpected pop.");
        return;
      }
      r !== Yg[Ys] && p("Unexpected Fiber popped."), e.current = G1[Ys], G1[Ys] = null, Yg[Ys] = null, Ys--;
    }
    function Ui(e, r, s) {
      Ys++, G1[Ys] = e.current, Yg[Ys] = s, e.current = r;
    }
    var X1;
    X1 = {};
    var qa = {};
    Object.freeze(qa);
    var Zs = oc(qa), ql = oc(!1), Q1 = qa;
    function mp(e, r, s) {
      return s && Gl(r) ? Q1 : Zs.current;
    }
    function lk(e, r, s) {
      {
        var c = e.stateNode;
        c.__reactInternalMemoizedUnmaskedChildContext = r, c.__reactInternalMemoizedMaskedChildContext = s;
      }
    }
    function vp(e, r) {
      {
        var s = e.type, c = s.contextTypes;
        if (!c)
          return qa;
        var h = e.stateNode;
        if (h && h.__reactInternalMemoizedUnmaskedChildContext === r)
          return h.__reactInternalMemoizedMaskedChildContext;
        var y = {};
        for (var x in c)
          y[x] = r[x];
        {
          var C = kt(e) || "Unknown";
          qo(c, y, "context", C);
        }
        return h && lk(e, r, y), y;
      }
    }
    function Zg() {
      return ql.current;
    }
    function Gl(e) {
      {
        var r = e.childContextTypes;
        return r != null;
      }
    }
    function qg(e) {
      Fi(ql, e), Fi(Zs, e);
    }
    function K1(e) {
      Fi(ql, e), Fi(Zs, e);
    }
    function sk(e, r, s) {
      {
        if (Zs.current !== qa)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Ui(Zs, r, e), Ui(ql, s, e);
      }
    }
    function uk(e, r, s) {
      {
        var c = e.stateNode, h = r.childContextTypes;
        if (typeof c.getChildContext != "function") {
          {
            var y = kt(e) || "Unknown";
            X1[y] || (X1[y] = !0, p("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", y, y));
          }
          return s;
        }
        var x = c.getChildContext();
        for (var C in x)
          if (!(C in h))
            throw new Error((kt(e) || "Unknown") + '.getChildContext(): key "' + C + '" is not defined in childContextTypes.');
        {
          var T = kt(e) || "Unknown";
          qo(h, x, "child context", T);
        }
        return Ft({}, s, x);
      }
    }
    function Gg(e) {
      {
        var r = e.stateNode, s = r && r.__reactInternalMemoizedMergedChildContext || qa;
        return Q1 = Zs.current, Ui(Zs, s, e), Ui(ql, ql.current, e), !0;
      }
    }
    function ck(e, r, s) {
      {
        var c = e.stateNode;
        if (!c)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (s) {
          var h = uk(e, r, Q1);
          c.__reactInternalMemoizedMergedChildContext = h, Fi(ql, e), Fi(Zs, e), Ui(Zs, h, e), Ui(ql, s, e);
        } else
          Fi(ql, e), Ui(ql, s, e);
      }
    }
    function pN(e) {
      {
        if (!Vh(e) || e.tag !== S)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var r = e;
        do {
          switch (r.tag) {
            case w:
              return r.stateNode.context;
            case S: {
              var s = r.type;
              if (Gl(s))
                return r.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          r = r.return;
        } while (r !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var lc = 0, Xg = 1, qs = null, J1 = !1, ex = !1;
    function fk(e) {
      qs === null ? qs = [e] : qs.push(e);
    }
    function hN(e) {
      J1 = !0, fk(e);
    }
    function dk() {
      J1 && sc();
    }
    function sc() {
      if (!ex && qs !== null) {
        ex = !0;
        var e = 0, r = Ea();
        try {
          var s = !0, c = qs;
          for (_r(ri); e < c.length; e++) {
            var h = c[e];
            do
              h = h(s);
            while (h !== null);
          }
          qs = null, J1 = !1;
        } catch (y) {
          throw qs !== null && (qs = qs.slice(e + 1)), yd(bd, sc), y;
        } finally {
          _r(r), ex = !1;
        }
      }
      return null;
    }
    var yp = [], gp = 0, Qg = null, Kg = 0, go = [], bo = 0, Ef = null, Gs = 1, Xs = "";
    function mN(e) {
      return kf(), (e.flags & Uh) !== ct;
    }
    function vN(e) {
      return kf(), Kg;
    }
    function yN() {
      var e = Xs, r = Gs, s = r & ~gN(r);
      return s.toString(32) + e;
    }
    function Cf(e, r) {
      kf(), yp[gp++] = Kg, yp[gp++] = Qg, Qg = e, Kg = r;
    }
    function pk(e, r, s) {
      kf(), go[bo++] = Gs, go[bo++] = Xs, go[bo++] = Ef, Ef = e;
      var c = Gs, h = Xs, y = Jg(c) - 1, x = c & ~(1 << y), C = s + 1, T = Jg(r) + y;
      if (T > 30) {
        var M = y - y % 5, P = (1 << M) - 1, Z = (x & P).toString(32), W = x >> M, ne = y - M, ie = Jg(r) + ne, fe = C << ne, Ze = fe | W, dt = Z + h;
        Gs = 1 << ie | Ze, Xs = dt;
      } else {
        var st = C << y, tn = st | x, Xt = h;
        Gs = 1 << T | tn, Xs = Xt;
      }
    }
    function tx(e) {
      kf();
      var r = e.return;
      if (r !== null) {
        var s = 1, c = 0;
        Cf(e, s), pk(e, s, c);
      }
    }
    function Jg(e) {
      return 32 - Cd(e);
    }
    function gN(e) {
      return 1 << Jg(e) - 1;
    }
    function nx(e) {
      for (; e === Qg; )
        Qg = yp[--gp], yp[gp] = null, Kg = yp[--gp], yp[gp] = null;
      for (; e === Ef; )
        Ef = go[--bo], go[bo] = null, Xs = go[--bo], go[bo] = null, Gs = go[--bo], go[bo] = null;
    }
    function bN() {
      return kf(), Ef !== null ? {
        id: Gs,
        overflow: Xs
      } : null;
    }
    function SN(e, r) {
      kf(), go[bo++] = Gs, go[bo++] = Xs, go[bo++] = Ef, Gs = r.id, Xs = r.overflow, Ef = e;
    }
    function kf() {
      gi() || p("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var yi = null, So = null, Go = !1, Tf = !1, uc = null;
    function xN() {
      Go && p("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function hk() {
      Tf = !0;
    }
    function wN() {
      return Tf;
    }
    function _N(e) {
      var r = e.stateNode.containerInfo;
      return So = UM(r), yi = e, Go = !0, uc = null, Tf = !1, !0;
    }
    function EN(e, r, s) {
      return So = BM(r), yi = e, Go = !0, uc = null, Tf = !1, s !== null && SN(e, s), !0;
    }
    function mk(e, r) {
      switch (e.tag) {
        case w: {
          KM(e.stateNode.containerInfo, r);
          break;
        }
        case k: {
          var s = (e.mode & Bt) !== ht;
          eN(
            e.type,
            e.memoizedProps,
            e.stateNode,
            r,
            // TODO: Delete this argument when we remove the legacy root API.
            s
          );
          break;
        }
        case ee: {
          var c = e.memoizedState;
          c.dehydrated !== null && JM(c.dehydrated, r);
          break;
        }
      }
    }
    function vk(e, r) {
      mk(e, r);
      var s = TP();
      s.stateNode = r, s.return = e;
      var c = e.deletions;
      c === null ? (e.deletions = [s], e.flags |= hn) : c.push(s);
    }
    function rx(e, r) {
      {
        if (Tf)
          return;
        switch (e.tag) {
          case w: {
            var s = e.stateNode.containerInfo;
            switch (r.tag) {
              case k:
                var c = r.type;
                r.pendingProps, tN(s, c);
                break;
              case N:
                var h = r.pendingProps;
                nN(s, h);
                break;
            }
            break;
          }
          case k: {
            var y = e.type, x = e.memoizedProps, C = e.stateNode;
            switch (r.tag) {
              case k: {
                var T = r.type, M = r.pendingProps, P = (e.mode & Bt) !== ht;
                aN(
                  y,
                  x,
                  C,
                  T,
                  M,
                  // TODO: Delete this argument when we remove the legacy root API.
                  P
                );
                break;
              }
              case N: {
                var Z = r.pendingProps, W = (e.mode & Bt) !== ht;
                oN(
                  y,
                  x,
                  C,
                  Z,
                  // TODO: Delete this argument when we remove the legacy root API.
                  W
                );
                break;
              }
            }
            break;
          }
          case ee: {
            var ne = e.memoizedState, ie = ne.dehydrated;
            if (ie !== null)
              switch (r.tag) {
                case k:
                  var fe = r.type;
                  r.pendingProps, rN(ie, fe);
                  break;
                case N:
                  var Ze = r.pendingProps;
                  iN(ie, Ze);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function yk(e, r) {
      r.flags = r.flags & ~ba | jn, rx(e, r);
    }
    function gk(e, r) {
      switch (e.tag) {
        case k: {
          var s = e.type;
          e.pendingProps;
          var c = PM(r, s);
          return c !== null ? (e.stateNode = c, yi = e, So = FM(c), !0) : !1;
        }
        case N: {
          var h = e.pendingProps, y = zM(r, h);
          return y !== null ? (e.stateNode = y, yi = e, So = null, !0) : !1;
        }
        case ee: {
          var x = $M(r);
          if (x !== null) {
            var C = {
              dehydrated: x,
              treeContext: bN(),
              retryLane: ji
            };
            e.memoizedState = C;
            var T = RP(x);
            return T.return = e, e.child = T, yi = e, So = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function ix(e) {
      return (e.mode & Bt) !== ht && (e.flags & _t) === ct;
    }
    function ax(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function ox(e) {
      if (Go) {
        var r = So;
        if (!r) {
          ix(e) && (rx(yi, e), ax()), yk(yi, e), Go = !1, yi = e;
          return;
        }
        var s = r;
        if (!gk(e, r)) {
          ix(e) && (rx(yi, e), ax()), r = jm(s);
          var c = yi;
          if (!r || !gk(e, r)) {
            yk(yi, e), Go = !1, yi = e;
            return;
          }
          vk(c, s);
        }
      }
    }
    function CN(e, r, s) {
      var c = e.stateNode, h = !Tf, y = HM(c, e.type, e.memoizedProps, r, s, e, h);
      return e.updateQueue = y, y !== null;
    }
    function kN(e) {
      var r = e.stateNode, s = e.memoizedProps, c = VM(r, s, e);
      if (c) {
        var h = yi;
        if (h !== null)
          switch (h.tag) {
            case w: {
              var y = h.stateNode.containerInfo, x = (h.mode & Bt) !== ht;
              XM(
                y,
                r,
                s,
                // TODO: Delete this argument when we remove the legacy root API.
                x
              );
              break;
            }
            case k: {
              var C = h.type, T = h.memoizedProps, M = h.stateNode, P = (h.mode & Bt) !== ht;
              QM(
                C,
                T,
                M,
                r,
                s,
                // TODO: Delete this argument when we remove the legacy root API.
                P
              );
              break;
            }
          }
      }
      return c;
    }
    function TN(e) {
      var r = e.memoizedState, s = r !== null ? r.dehydrated : null;
      if (!s)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      WM(s, e);
    }
    function RN(e) {
      var r = e.memoizedState, s = r !== null ? r.dehydrated : null;
      if (!s)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return YM(s);
    }
    function bk(e) {
      for (var r = e.return; r !== null && r.tag !== k && r.tag !== w && r.tag !== ee; )
        r = r.return;
      yi = r;
    }
    function e0(e) {
      if (e !== yi)
        return !1;
      if (!Go)
        return bk(e), Go = !0, !1;
      if (e.tag !== w && (e.tag !== k || GM(e.type) && !U1(e.type, e.memoizedProps))) {
        var r = So;
        if (r)
          if (ix(e))
            Sk(e), ax();
          else
            for (; r; )
              vk(e, r), r = jm(r);
      }
      return bk(e), e.tag === ee ? So = RN(e) : So = yi ? jm(e.stateNode) : null, !0;
    }
    function ON() {
      return Go && So !== null;
    }
    function Sk(e) {
      for (var r = So; r; )
        mk(e, r), r = jm(r);
    }
    function bp() {
      yi = null, So = null, Go = !1, Tf = !1;
    }
    function xk() {
      uc !== null && (m2(uc), uc = null);
    }
    function gi() {
      return Go;
    }
    function lx(e) {
      uc === null ? uc = [e] : uc.push(e);
    }
    var AN = i.ReactCurrentBatchConfig, DN = null;
    function MN() {
      return AN.transition;
    }
    var Xo = {
      recordUnsafeLifecycleWarnings: function(e, r) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, r) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var NN = function(e) {
        for (var r = null, s = e; s !== null; )
          s.mode & Xn && (r = s), s = s.return;
        return r;
      }, Rf = function(e) {
        var r = [];
        return e.forEach(function(s) {
          r.push(s);
        }), r.sort().join(", ");
      }, Bm = [], Hm = [], Vm = [], Wm = [], Ym = [], Zm = [], Of = /* @__PURE__ */ new Set();
      Xo.recordUnsafeLifecycleWarnings = function(e, r) {
        Of.has(e.type) || (typeof r.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        r.componentWillMount.__suppressDeprecationWarning !== !0 && Bm.push(e), e.mode & Xn && typeof r.UNSAFE_componentWillMount == "function" && Hm.push(e), typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Vm.push(e), e.mode & Xn && typeof r.UNSAFE_componentWillReceiveProps == "function" && Wm.push(e), typeof r.componentWillUpdate == "function" && r.componentWillUpdate.__suppressDeprecationWarning !== !0 && Ym.push(e), e.mode & Xn && typeof r.UNSAFE_componentWillUpdate == "function" && Zm.push(e));
      }, Xo.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        Bm.length > 0 && (Bm.forEach(function(W) {
          e.add(kt(W) || "Component"), Of.add(W.type);
        }), Bm = []);
        var r = /* @__PURE__ */ new Set();
        Hm.length > 0 && (Hm.forEach(function(W) {
          r.add(kt(W) || "Component"), Of.add(W.type);
        }), Hm = []);
        var s = /* @__PURE__ */ new Set();
        Vm.length > 0 && (Vm.forEach(function(W) {
          s.add(kt(W) || "Component"), Of.add(W.type);
        }), Vm = []);
        var c = /* @__PURE__ */ new Set();
        Wm.length > 0 && (Wm.forEach(function(W) {
          c.add(kt(W) || "Component"), Of.add(W.type);
        }), Wm = []);
        var h = /* @__PURE__ */ new Set();
        Ym.length > 0 && (Ym.forEach(function(W) {
          h.add(kt(W) || "Component"), Of.add(W.type);
        }), Ym = []);
        var y = /* @__PURE__ */ new Set();
        if (Zm.length > 0 && (Zm.forEach(function(W) {
          y.add(kt(W) || "Component"), Of.add(W.type);
        }), Zm = []), r.size > 0) {
          var x = Rf(r);
          p(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, x);
        }
        if (c.size > 0) {
          var C = Rf(c);
          p(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, C);
        }
        if (y.size > 0) {
          var T = Rf(y);
          p(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, T);
        }
        if (e.size > 0) {
          var M = Rf(e);
          f(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, M);
        }
        if (s.size > 0) {
          var P = Rf(s);
          f(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, P);
        }
        if (h.size > 0) {
          var Z = Rf(h);
          f(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Z);
        }
      };
      var t0 = /* @__PURE__ */ new Map(), wk = /* @__PURE__ */ new Set();
      Xo.recordLegacyContextWarning = function(e, r) {
        var s = NN(e);
        if (s === null) {
          p("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!wk.has(e.type)) {
          var c = t0.get(s);
          (e.type.contextTypes != null || e.type.childContextTypes != null || r !== null && typeof r.getChildContext == "function") && (c === void 0 && (c = [], t0.set(s, c)), c.push(e));
        }
      }, Xo.flushLegacyContextWarning = function() {
        t0.forEach(function(e, r) {
          if (e.length !== 0) {
            var s = e[0], c = /* @__PURE__ */ new Set();
            e.forEach(function(y) {
              c.add(kt(y) || "Component"), wk.add(y.type);
            });
            var h = Rf(c);
            try {
              yn(s), p(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, h);
            } finally {
              rr();
            }
          }
        });
      }, Xo.discardPendingWarnings = function() {
        Bm = [], Hm = [], Vm = [], Wm = [], Ym = [], Zm = [], t0 = /* @__PURE__ */ new Map();
      };
    }
    function Qo(e, r) {
      if (e && e.defaultProps) {
        var s = Ft({}, r), c = e.defaultProps;
        for (var h in c)
          s[h] === void 0 && (s[h] = c[h]);
        return s;
      }
      return r;
    }
    var sx = oc(null), ux;
    ux = {};
    var n0 = null, Sp = null, cx = null, r0 = !1;
    function i0() {
      n0 = null, Sp = null, cx = null, r0 = !1;
    }
    function _k() {
      r0 = !0;
    }
    function Ek() {
      r0 = !1;
    }
    function Ck(e, r, s) {
      Ui(sx, r._currentValue, e), r._currentValue = s, r._currentRenderer !== void 0 && r._currentRenderer !== null && r._currentRenderer !== ux && p("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), r._currentRenderer = ux;
    }
    function fx(e, r) {
      var s = sx.current;
      Fi(sx, r), e._currentValue = s;
    }
    function dx(e, r, s) {
      for (var c = e; c !== null; ) {
        var h = c.alternate;
        if (Ps(c.childLanes, r) ? h !== null && !Ps(h.childLanes, r) && (h.childLanes = zt(h.childLanes, r)) : (c.childLanes = zt(c.childLanes, r), h !== null && (h.childLanes = zt(h.childLanes, r))), c === s)
          break;
        c = c.return;
      }
      c !== s && p("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function LN(e, r, s) {
      PN(e, r, s);
    }
    function PN(e, r, s) {
      var c = e.child;
      for (c !== null && (c.return = e); c !== null; ) {
        var h = void 0, y = c.dependencies;
        if (y !== null) {
          h = c.child;
          for (var x = y.firstContext; x !== null; ) {
            if (x.context === r) {
              if (c.tag === S) {
                var C = wr(s), T = Qs(Dn, C);
                T.tag = o0;
                var M = c.updateQueue;
                if (M !== null) {
                  var P = M.shared, Z = P.pending;
                  Z === null ? T.next = T : (T.next = Z.next, Z.next = T), P.pending = T;
                }
              }
              c.lanes = zt(c.lanes, s);
              var W = c.alternate;
              W !== null && (W.lanes = zt(W.lanes, s)), dx(c.return, s, e), y.lanes = zt(y.lanes, s);
              break;
            }
            x = x.next;
          }
        } else if (c.tag === q)
          h = c.type === e.type ? null : c.child;
        else if (c.tag === Le) {
          var ne = c.return;
          if (ne === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ne.lanes = zt(ne.lanes, s);
          var ie = ne.alternate;
          ie !== null && (ie.lanes = zt(ie.lanes, s)), dx(ne, s, e), h = c.sibling;
        } else
          h = c.child;
        if (h !== null)
          h.return = c;
        else
          for (h = c; h !== null; ) {
            if (h === e) {
              h = null;
              break;
            }
            var fe = h.sibling;
            if (fe !== null) {
              fe.return = h.return, h = fe;
              break;
            }
            h = h.return;
          }
        c = h;
      }
    }
    function xp(e, r) {
      n0 = e, Sp = null, cx = null;
      var s = e.dependencies;
      if (s !== null) {
        var c = s.firstContext;
        c !== null && (Ii(s.lanes, r) && lv(), s.firstContext = null);
      }
    }
    function zr(e) {
      r0 && p("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var r = e._currentValue;
      if (cx !== e) {
        var s = {
          context: e,
          memoizedValue: r,
          next: null
        };
        if (Sp === null) {
          if (n0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Sp = s, n0.dependencies = {
            lanes: pe,
            firstContext: s
          };
        } else
          Sp = Sp.next = s;
      }
      return r;
    }
    var Af = null;
    function px(e) {
      Af === null ? Af = [e] : Af.push(e);
    }
    function zN() {
      if (Af !== null) {
        for (var e = 0; e < Af.length; e++) {
          var r = Af[e], s = r.interleaved;
          if (s !== null) {
            r.interleaved = null;
            var c = s.next, h = r.pending;
            if (h !== null) {
              var y = h.next;
              h.next = c, s.next = y;
            }
            r.pending = s;
          }
        }
        Af = null;
      }
    }
    function kk(e, r, s, c) {
      var h = r.interleaved;
      return h === null ? (s.next = s, px(r)) : (s.next = h.next, h.next = s), r.interleaved = s, a0(e, c);
    }
    function $N(e, r, s, c) {
      var h = r.interleaved;
      h === null ? (s.next = s, px(r)) : (s.next = h.next, h.next = s), r.interleaved = s;
    }
    function jN(e, r, s, c) {
      var h = r.interleaved;
      return h === null ? (s.next = s, px(r)) : (s.next = h.next, h.next = s), r.interleaved = s, a0(e, c);
    }
    function Oa(e, r) {
      return a0(e, r);
    }
    var IN = a0;
    function a0(e, r) {
      e.lanes = zt(e.lanes, r);
      var s = e.alternate;
      s !== null && (s.lanes = zt(s.lanes, r)), s === null && (e.flags & (jn | ba)) !== ct && T2(e);
      for (var c = e, h = e.return; h !== null; )
        h.childLanes = zt(h.childLanes, r), s = h.alternate, s !== null ? s.childLanes = zt(s.childLanes, r) : (h.flags & (jn | ba)) !== ct && T2(e), c = h, h = h.return;
      if (c.tag === w) {
        var y = c.stateNode;
        return y;
      } else
        return null;
    }
    var Tk = 0, Rk = 1, o0 = 2, hx = 3, l0 = !1, mx, s0;
    mx = !1, s0 = null;
    function vx(e) {
      var r = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: pe
        },
        effects: null
      };
      e.updateQueue = r;
    }
    function Ok(e, r) {
      var s = r.updateQueue, c = e.updateQueue;
      if (s === c) {
        var h = {
          baseState: c.baseState,
          firstBaseUpdate: c.firstBaseUpdate,
          lastBaseUpdate: c.lastBaseUpdate,
          shared: c.shared,
          effects: c.effects
        };
        r.updateQueue = h;
      }
    }
    function Qs(e, r) {
      var s = {
        eventTime: e,
        lane: r,
        tag: Tk,
        payload: null,
        callback: null,
        next: null
      };
      return s;
    }
    function cc(e, r, s) {
      var c = e.updateQueue;
      if (c === null)
        return null;
      var h = c.shared;
      if (s0 === h && !mx && (p("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), mx = !0), I6()) {
        var y = h.pending;
        return y === null ? r.next = r : (r.next = y.next, y.next = r), h.pending = r, IN(e, s);
      } else
        return jN(e, h, r, s);
    }
    function u0(e, r, s) {
      var c = r.updateQueue;
      if (c !== null) {
        var h = c.shared;
        if (rm(s)) {
          var y = h.lanes;
          y = am(y, e.pendingLanes);
          var x = zt(y, s);
          h.lanes = x, Vu(e, x);
        }
      }
    }
    function yx(e, r) {
      var s = e.updateQueue, c = e.alternate;
      if (c !== null) {
        var h = c.updateQueue;
        if (s === h) {
          var y = null, x = null, C = s.firstBaseUpdate;
          if (C !== null) {
            var T = C;
            do {
              var M = {
                eventTime: T.eventTime,
                lane: T.lane,
                tag: T.tag,
                payload: T.payload,
                callback: T.callback,
                next: null
              };
              x === null ? y = x = M : (x.next = M, x = M), T = T.next;
            } while (T !== null);
            x === null ? y = x = r : (x.next = r, x = r);
          } else
            y = x = r;
          s = {
            baseState: h.baseState,
            firstBaseUpdate: y,
            lastBaseUpdate: x,
            shared: h.shared,
            effects: h.effects
          }, e.updateQueue = s;
          return;
        }
      }
      var P = s.lastBaseUpdate;
      P === null ? s.firstBaseUpdate = r : P.next = r, s.lastBaseUpdate = r;
    }
    function FN(e, r, s, c, h, y) {
      switch (s.tag) {
        case Rk: {
          var x = s.payload;
          if (typeof x == "function") {
            _k();
            var C = x.call(y, c, h);
            {
              if (e.mode & Xn) {
                xr(!0);
                try {
                  x.call(y, c, h);
                } finally {
                  xr(!1);
                }
              }
              Ek();
            }
            return C;
          }
          return x;
        }
        case hx:
          e.flags = e.flags & ~Dr | _t;
        case Tk: {
          var T = s.payload, M;
          if (typeof T == "function") {
            _k(), M = T.call(y, c, h);
            {
              if (e.mode & Xn) {
                xr(!0);
                try {
                  T.call(y, c, h);
                } finally {
                  xr(!1);
                }
              }
              Ek();
            }
          } else
            M = T;
          return M == null ? c : Ft({}, c, M);
        }
        case o0:
          return l0 = !0, c;
      }
      return c;
    }
    function c0(e, r, s, c) {
      var h = e.updateQueue;
      l0 = !1, s0 = h.shared;
      var y = h.firstBaseUpdate, x = h.lastBaseUpdate, C = h.shared.pending;
      if (C !== null) {
        h.shared.pending = null;
        var T = C, M = T.next;
        T.next = null, x === null ? y = M : x.next = M, x = T;
        var P = e.alternate;
        if (P !== null) {
          var Z = P.updateQueue, W = Z.lastBaseUpdate;
          W !== x && (W === null ? Z.firstBaseUpdate = M : W.next = M, Z.lastBaseUpdate = T);
        }
      }
      if (y !== null) {
        var ne = h.baseState, ie = pe, fe = null, Ze = null, dt = null, st = y;
        do {
          var tn = st.lane, Xt = st.eventTime;
          if (Ps(c, tn)) {
            if (dt !== null) {
              var de = {
                eventTime: Xt,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Jt,
                tag: st.tag,
                payload: st.payload,
                callback: st.callback,
                next: null
              };
              dt = dt.next = de;
            }
            ne = FN(e, h, st, ne, r, s);
            var K = st.callback;
            if (K !== null && // If the update was already committed, we should not queue its
            // callback again.
            st.lane !== Jt) {
              e.flags |= fo;
              var Ee = h.effects;
              Ee === null ? h.effects = [st] : Ee.push(st);
            }
          } else {
            var Q = {
              eventTime: Xt,
              lane: tn,
              tag: st.tag,
              payload: st.payload,
              callback: st.callback,
              next: null
            };
            dt === null ? (Ze = dt = Q, fe = ne) : dt = dt.next = Q, ie = zt(ie, tn);
          }
          if (st = st.next, st === null) {
            if (C = h.shared.pending, C === null)
              break;
            var qe = C, Be = qe.next;
            qe.next = null, st = Be, h.lastBaseUpdate = qe, h.shared.pending = null;
          }
        } while (!0);
        dt === null && (fe = ne), h.baseState = fe, h.firstBaseUpdate = Ze, h.lastBaseUpdate = dt;
        var wt = h.shared.interleaved;
        if (wt !== null) {
          var Rt = wt;
          do
            ie = zt(ie, Rt.lane), Rt = Rt.next;
          while (Rt !== wt);
        } else
          y === null && (h.shared.lanes = pe);
        bv(ie), e.lanes = ie, e.memoizedState = ne;
      }
      s0 = null;
    }
    function UN(e, r) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(r);
    }
    function Ak() {
      l0 = !1;
    }
    function f0() {
      return l0;
    }
    function Dk(e, r, s) {
      var c = r.effects;
      if (r.effects = null, c !== null)
        for (var h = 0; h < c.length; h++) {
          var y = c[h], x = y.callback;
          x !== null && (y.callback = null, UN(x, s));
        }
    }
    var gx = {}, Mk = new t.Component().refs, bx, Sx, xx, wx, _x, Nk, d0, Ex, Cx, kx;
    {
      bx = /* @__PURE__ */ new Set(), Sx = /* @__PURE__ */ new Set(), xx = /* @__PURE__ */ new Set(), wx = /* @__PURE__ */ new Set(), Ex = /* @__PURE__ */ new Set(), _x = /* @__PURE__ */ new Set(), Cx = /* @__PURE__ */ new Set(), kx = /* @__PURE__ */ new Set();
      var Lk = /* @__PURE__ */ new Set();
      d0 = function(e, r) {
        if (!(e === null || typeof e == "function")) {
          var s = r + "_" + e;
          Lk.has(s) || (Lk.add(s), p("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e));
        }
      }, Nk = function(e, r) {
        if (r === void 0) {
          var s = on(e) || "Component";
          _x.has(s) || (_x.add(s), p("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", s));
        }
      }, Object.defineProperty(gx, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(gx);
    }
    function Tx(e, r, s, c) {
      var h = e.memoizedState, y = s(c, h);
      {
        if (e.mode & Xn) {
          xr(!0);
          try {
            y = s(c, h);
          } finally {
            xr(!1);
          }
        }
        Nk(r, y);
      }
      var x = y == null ? h : Ft({}, h, y);
      if (e.memoizedState = x, e.lanes === pe) {
        var C = e.updateQueue;
        C.baseState = x;
      }
    }
    var Rx = {
      isMounted: ta,
      enqueueSetState: function(e, r, s) {
        var c = ya(e), h = la(), y = gc(c), x = Qs(h, y);
        x.payload = r, s != null && (d0(s, "setState"), x.callback = s);
        var C = cc(c, x, y);
        C !== null && (Qr(C, c, y, h), u0(C, c, y)), Il(c, y);
      },
      enqueueReplaceState: function(e, r, s) {
        var c = ya(e), h = la(), y = gc(c), x = Qs(h, y);
        x.tag = Rk, x.payload = r, s != null && (d0(s, "replaceState"), x.callback = s);
        var C = cc(c, x, y);
        C !== null && (Qr(C, c, y, h), u0(C, c, y)), Il(c, y);
      },
      enqueueForceUpdate: function(e, r) {
        var s = ya(e), c = la(), h = gc(s), y = Qs(c, h);
        y.tag = o0, r != null && (d0(r, "forceUpdate"), y.callback = r);
        var x = cc(s, y, h);
        x !== null && (Qr(x, s, h, c), u0(x, s, h)), Jh(s, h);
      }
    };
    function Pk(e, r, s, c, h, y, x) {
      var C = e.stateNode;
      if (typeof C.shouldComponentUpdate == "function") {
        var T = C.shouldComponentUpdate(c, y, x);
        {
          if (e.mode & Xn) {
            xr(!0);
            try {
              T = C.shouldComponentUpdate(c, y, x);
            } finally {
              xr(!1);
            }
          }
          T === void 0 && p("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", on(r) || "Component");
        }
        return T;
      }
      return r.prototype && r.prototype.isPureReactComponent ? !ut(s, c) || !ut(h, y) : !0;
    }
    function BN(e, r, s) {
      var c = e.stateNode;
      {
        var h = on(r) || "Component", y = c.render;
        y || (r.prototype && typeof r.prototype.render == "function" ? p("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", h) : p("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", h)), c.getInitialState && !c.getInitialState.isReactClassApproved && !c.state && p("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", h), c.getDefaultProps && !c.getDefaultProps.isReactClassApproved && p("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", h), c.propTypes && p("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", h), c.contextType && p("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", h), c.contextTypes && p("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", h), r.contextType && r.contextTypes && !Cx.has(r) && (Cx.add(r), p("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", h)), typeof c.componentShouldUpdate == "function" && p("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", h), r.prototype && r.prototype.isPureReactComponent && typeof c.shouldComponentUpdate < "u" && p("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", on(r) || "A pure component"), typeof c.componentDidUnmount == "function" && p("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", h), typeof c.componentDidReceiveProps == "function" && p("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", h), typeof c.componentWillRecieveProps == "function" && p("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", h), typeof c.UNSAFE_componentWillRecieveProps == "function" && p("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", h);
        var x = c.props !== s;
        c.props !== void 0 && x && p("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", h, h), c.defaultProps && p("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", h, h), typeof c.getSnapshotBeforeUpdate == "function" && typeof c.componentDidUpdate != "function" && !xx.has(r) && (xx.add(r), p("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", on(r))), typeof c.getDerivedStateFromProps == "function" && p("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", h), typeof c.getDerivedStateFromError == "function" && p("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", h), typeof r.getSnapshotBeforeUpdate == "function" && p("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", h);
        var C = c.state;
        C && (typeof C != "object" || Qt(C)) && p("%s.state: must be set to an object or null", h), typeof c.getChildContext == "function" && typeof r.childContextTypes != "object" && p("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", h);
      }
    }
    function zk(e, r) {
      r.updater = Rx, e.stateNode = r, Lu(r, e), r._reactInternalInstance = gx;
    }
    function $k(e, r, s) {
      var c = !1, h = qa, y = qa, x = r.contextType;
      if ("contextType" in r) {
        var C = (
          // Allow null for conditional declaration
          x === null || x !== void 0 && x.$$typeof === ze && x._context === void 0
        );
        if (!C && !kx.has(r)) {
          kx.add(r);
          var T = "";
          x === void 0 ? T = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof x != "object" ? T = " However, it is set to a " + typeof x + "." : x.$$typeof === ge ? T = " Did you accidentally pass the Context.Provider instead?" : x._context !== void 0 ? T = " Did you accidentally pass the Context.Consumer instead?" : T = " However, it is set to an object with keys {" + Object.keys(x).join(", ") + "}.", p("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", on(r) || "Component", T);
        }
      }
      if (typeof x == "object" && x !== null)
        y = zr(x);
      else {
        h = mp(e, r, !0);
        var M = r.contextTypes;
        c = M != null, y = c ? vp(e, h) : qa;
      }
      var P = new r(s, y);
      if (e.mode & Xn) {
        xr(!0);
        try {
          P = new r(s, y);
        } finally {
          xr(!1);
        }
      }
      var Z = e.memoizedState = P.state !== null && P.state !== void 0 ? P.state : null;
      zk(e, P);
      {
        if (typeof r.getDerivedStateFromProps == "function" && Z === null) {
          var W = on(r) || "Component";
          Sx.has(W) || (Sx.add(W), p("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", W, P.state === null ? "null" : "undefined", W));
        }
        if (typeof r.getDerivedStateFromProps == "function" || typeof P.getSnapshotBeforeUpdate == "function") {
          var ne = null, ie = null, fe = null;
          if (typeof P.componentWillMount == "function" && P.componentWillMount.__suppressDeprecationWarning !== !0 ? ne = "componentWillMount" : typeof P.UNSAFE_componentWillMount == "function" && (ne = "UNSAFE_componentWillMount"), typeof P.componentWillReceiveProps == "function" && P.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ie = "componentWillReceiveProps" : typeof P.UNSAFE_componentWillReceiveProps == "function" && (ie = "UNSAFE_componentWillReceiveProps"), typeof P.componentWillUpdate == "function" && P.componentWillUpdate.__suppressDeprecationWarning !== !0 ? fe = "componentWillUpdate" : typeof P.UNSAFE_componentWillUpdate == "function" && (fe = "UNSAFE_componentWillUpdate"), ne !== null || ie !== null || fe !== null) {
            var Ze = on(r) || "Component", dt = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            wx.has(Ze) || (wx.add(Ze), p(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ze, dt, ne !== null ? `
  ` + ne : "", ie !== null ? `
  ` + ie : "", fe !== null ? `
  ` + fe : ""));
          }
        }
      }
      return c && lk(e, h, y), P;
    }
    function HN(e, r) {
      var s = r.state;
      typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), s !== r.state && (p("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", kt(e) || "Component"), Rx.enqueueReplaceState(r, r.state, null));
    }
    function jk(e, r, s, c) {
      var h = r.state;
      if (typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(s, c), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(s, c), r.state !== h) {
        {
          var y = kt(e) || "Component";
          bx.has(y) || (bx.add(y), p("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", y));
        }
        Rx.enqueueReplaceState(r, r.state, null);
      }
    }
    function Ox(e, r, s, c) {
      BN(e, r, s);
      var h = e.stateNode;
      h.props = s, h.state = e.memoizedState, h.refs = Mk, vx(e);
      var y = r.contextType;
      if (typeof y == "object" && y !== null)
        h.context = zr(y);
      else {
        var x = mp(e, r, !0);
        h.context = vp(e, x);
      }
      {
        if (h.state === s) {
          var C = on(r) || "Component";
          Ex.has(C) || (Ex.add(C), p("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", C));
        }
        e.mode & Xn && Xo.recordLegacyContextWarning(e, h), Xo.recordUnsafeLifecycleWarnings(e, h);
      }
      h.state = e.memoizedState;
      var T = r.getDerivedStateFromProps;
      if (typeof T == "function" && (Tx(e, r, T, s), h.state = e.memoizedState), typeof r.getDerivedStateFromProps != "function" && typeof h.getSnapshotBeforeUpdate != "function" && (typeof h.UNSAFE_componentWillMount == "function" || typeof h.componentWillMount == "function") && (HN(e, h), c0(e, s, h, c), h.state = e.memoizedState), typeof h.componentDidMount == "function") {
        var M = Pt;
        M |= Ni, (e.mode & wa) !== ht && (M |= Li), e.flags |= M;
      }
    }
    function VN(e, r, s, c) {
      var h = e.stateNode, y = e.memoizedProps;
      h.props = y;
      var x = h.context, C = r.contextType, T = qa;
      if (typeof C == "object" && C !== null)
        T = zr(C);
      else {
        var M = mp(e, r, !0);
        T = vp(e, M);
      }
      var P = r.getDerivedStateFromProps, Z = typeof P == "function" || typeof h.getSnapshotBeforeUpdate == "function";
      !Z && (typeof h.UNSAFE_componentWillReceiveProps == "function" || typeof h.componentWillReceiveProps == "function") && (y !== s || x !== T) && jk(e, h, s, T), Ak();
      var W = e.memoizedState, ne = h.state = W;
      if (c0(e, s, h, c), ne = e.memoizedState, y === s && W === ne && !Zg() && !f0()) {
        if (typeof h.componentDidMount == "function") {
          var ie = Pt;
          ie |= Ni, (e.mode & wa) !== ht && (ie |= Li), e.flags |= ie;
        }
        return !1;
      }
      typeof P == "function" && (Tx(e, r, P, s), ne = e.memoizedState);
      var fe = f0() || Pk(e, r, y, s, W, ne, T);
      if (fe) {
        if (!Z && (typeof h.UNSAFE_componentWillMount == "function" || typeof h.componentWillMount == "function") && (typeof h.componentWillMount == "function" && h.componentWillMount(), typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount()), typeof h.componentDidMount == "function") {
          var Ze = Pt;
          Ze |= Ni, (e.mode & wa) !== ht && (Ze |= Li), e.flags |= Ze;
        }
      } else {
        if (typeof h.componentDidMount == "function") {
          var dt = Pt;
          dt |= Ni, (e.mode & wa) !== ht && (dt |= Li), e.flags |= dt;
        }
        e.memoizedProps = s, e.memoizedState = ne;
      }
      return h.props = s, h.state = ne, h.context = T, fe;
    }
    function WN(e, r, s, c, h) {
      var y = r.stateNode;
      Ok(e, r);
      var x = r.memoizedProps, C = r.type === r.elementType ? x : Qo(r.type, x);
      y.props = C;
      var T = r.pendingProps, M = y.context, P = s.contextType, Z = qa;
      if (typeof P == "object" && P !== null)
        Z = zr(P);
      else {
        var W = mp(r, s, !0);
        Z = vp(r, W);
      }
      var ne = s.getDerivedStateFromProps, ie = typeof ne == "function" || typeof y.getSnapshotBeforeUpdate == "function";
      !ie && (typeof y.UNSAFE_componentWillReceiveProps == "function" || typeof y.componentWillReceiveProps == "function") && (x !== T || M !== Z) && jk(r, y, c, Z), Ak();
      var fe = r.memoizedState, Ze = y.state = fe;
      if (c0(r, c, y, h), Ze = r.memoizedState, x === T && fe === Ze && !Zg() && !f0() && !Fe)
        return typeof y.componentDidUpdate == "function" && (x !== e.memoizedProps || fe !== e.memoizedState) && (r.flags |= Pt), typeof y.getSnapshotBeforeUpdate == "function" && (x !== e.memoizedProps || fe !== e.memoizedState) && (r.flags |= ga), !1;
      typeof ne == "function" && (Tx(r, s, ne, c), Ze = r.memoizedState);
      var dt = f0() || Pk(r, s, C, c, fe, Ze, Z) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      Fe;
      return dt ? (!ie && (typeof y.UNSAFE_componentWillUpdate == "function" || typeof y.componentWillUpdate == "function") && (typeof y.componentWillUpdate == "function" && y.componentWillUpdate(c, Ze, Z), typeof y.UNSAFE_componentWillUpdate == "function" && y.UNSAFE_componentWillUpdate(c, Ze, Z)), typeof y.componentDidUpdate == "function" && (r.flags |= Pt), typeof y.getSnapshotBeforeUpdate == "function" && (r.flags |= ga)) : (typeof y.componentDidUpdate == "function" && (x !== e.memoizedProps || fe !== e.memoizedState) && (r.flags |= Pt), typeof y.getSnapshotBeforeUpdate == "function" && (x !== e.memoizedProps || fe !== e.memoizedState) && (r.flags |= ga), r.memoizedProps = c, r.memoizedState = Ze), y.props = c, y.state = Ze, y.context = Z, dt;
    }
    var Ax, Dx, Mx, Nx, Lx, Ik = function(e, r) {
    };
    Ax = !1, Dx = !1, Mx = {}, Nx = {}, Lx = {}, Ik = function(e, r) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var s = kt(r) || "Component";
        Nx[s] || (Nx[s] = !0, p('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function qm(e, r, s) {
      var c = s.ref;
      if (c !== null && typeof c != "function" && typeof c != "object") {
        if ((e.mode & Xn || rt) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(s._owner && s._self && s._owner.stateNode !== s._self)) {
          var h = kt(e) || "Component";
          Mx[h] || (p('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', c), Mx[h] = !0);
        }
        if (s._owner) {
          var y = s._owner, x;
          if (y) {
            var C = y;
            if (C.tag !== S)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            x = C.stateNode;
          }
          if (!x)
            throw new Error("Missing owner for string ref " + c + ". This error is likely caused by a bug in React. Please file an issue.");
          var T = x;
          mr(c, "ref");
          var M = "" + c;
          if (r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === M)
            return r.ref;
          var P = function(Z) {
            var W = T.refs;
            W === Mk && (W = T.refs = {}), Z === null ? delete W[M] : W[M] = Z;
          };
          return P._stringRef = M, P;
        } else {
          if (typeof c != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!s._owner)
            throw new Error("Element ref was specified as a string (" + c + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return c;
    }
    function p0(e, r) {
      var s = Object.prototype.toString.call(r);
      throw new Error("Objects are not valid as a React child (found: " + (s === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : s) + "). If you meant to render a collection of children, use an array instead.");
    }
    function h0(e) {
      {
        var r = kt(e) || "Component";
        if (Lx[r])
          return;
        Lx[r] = !0, p("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Fk(e) {
      var r = e._payload, s = e._init;
      return s(r);
    }
    function Uk(e) {
      function r(Q, de) {
        if (e) {
          var K = Q.deletions;
          K === null ? (Q.deletions = [de], Q.flags |= hn) : K.push(de);
        }
      }
      function s(Q, de) {
        if (!e)
          return null;
        for (var K = de; K !== null; )
          r(Q, K), K = K.sibling;
        return null;
      }
      function c(Q, de) {
        for (var K = /* @__PURE__ */ new Map(), Ee = de; Ee !== null; )
          Ee.key !== null ? K.set(Ee.key, Ee) : K.set(Ee.index, Ee), Ee = Ee.sibling;
        return K;
      }
      function h(Q, de) {
        var K = jf(Q, de);
        return K.index = 0, K.sibling = null, K;
      }
      function y(Q, de, K) {
        if (Q.index = K, !e)
          return Q.flags |= Uh, de;
        var Ee = Q.alternate;
        if (Ee !== null) {
          var qe = Ee.index;
          return qe < de ? (Q.flags |= jn, de) : qe;
        } else
          return Q.flags |= jn, de;
      }
      function x(Q) {
        return e && Q.alternate === null && (Q.flags |= jn), Q;
      }
      function C(Q, de, K, Ee) {
        if (de === null || de.tag !== N) {
          var qe = l_(K, Q.mode, Ee);
          return qe.return = Q, qe;
        } else {
          var Be = h(de, K);
          return Be.return = Q, Be;
        }
      }
      function T(Q, de, K, Ee) {
        var qe = K.type;
        if (qe === Ki)
          return P(Q, de, K.props.children, Ee, K.key);
        if (de !== null && (de.elementType === qe || // Keep this check inline so it only runs on the false path:
        D2(de, K) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof qe == "object" && qe !== null && qe.$$typeof === ft && Fk(qe) === de.type)) {
          var Be = h(de, K.props);
          return Be.ref = qm(Q, de, K), Be.return = Q, Be._debugSource = K._source, Be._debugOwner = K._owner, Be;
        }
        var wt = o_(K, Q.mode, Ee);
        return wt.ref = qm(Q, de, K), wt.return = Q, wt;
      }
      function M(Q, de, K, Ee) {
        if (de === null || de.tag !== R || de.stateNode.containerInfo !== K.containerInfo || de.stateNode.implementation !== K.implementation) {
          var qe = s_(K, Q.mode, Ee);
          return qe.return = Q, qe;
        } else {
          var Be = h(de, K.children || []);
          return Be.return = Q, Be;
        }
      }
      function P(Q, de, K, Ee, qe) {
        if (de === null || de.tag !== z) {
          var Be = Sc(K, Q.mode, Ee, qe);
          return Be.return = Q, Be;
        } else {
          var wt = h(de, K);
          return wt.return = Q, wt;
        }
      }
      function Z(Q, de, K) {
        if (typeof de == "string" && de !== "" || typeof de == "number") {
          var Ee = l_("" + de, Q.mode, K);
          return Ee.return = Q, Ee;
        }
        if (typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case io: {
              var qe = o_(de, Q.mode, K);
              return qe.ref = qm(Q, null, de), qe.return = Q, qe;
            }
            case di: {
              var Be = s_(de, Q.mode, K);
              return Be.return = Q, Be;
            }
            case ft: {
              var wt = de._payload, Rt = de._init;
              return Z(Q, Rt(wt), K);
            }
          }
          if (Qt(de) || Ia(de)) {
            var Tn = Sc(de, Q.mode, K, null);
            return Tn.return = Q, Tn;
          }
          p0(Q, de);
        }
        return typeof de == "function" && h0(Q), null;
      }
      function W(Q, de, K, Ee) {
        var qe = de !== null ? de.key : null;
        if (typeof K == "string" && K !== "" || typeof K == "number")
          return qe !== null ? null : C(Q, de, "" + K, Ee);
        if (typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case io:
              return K.key === qe ? T(Q, de, K, Ee) : null;
            case di:
              return K.key === qe ? M(Q, de, K, Ee) : null;
            case ft: {
              var Be = K._payload, wt = K._init;
              return W(Q, de, wt(Be), Ee);
            }
          }
          if (Qt(K) || Ia(K))
            return qe !== null ? null : P(Q, de, K, Ee, null);
          p0(Q, K);
        }
        return typeof K == "function" && h0(Q), null;
      }
      function ne(Q, de, K, Ee, qe) {
        if (typeof Ee == "string" && Ee !== "" || typeof Ee == "number") {
          var Be = Q.get(K) || null;
          return C(de, Be, "" + Ee, qe);
        }
        if (typeof Ee == "object" && Ee !== null) {
          switch (Ee.$$typeof) {
            case io: {
              var wt = Q.get(Ee.key === null ? K : Ee.key) || null;
              return T(de, wt, Ee, qe);
            }
            case di: {
              var Rt = Q.get(Ee.key === null ? K : Ee.key) || null;
              return M(de, Rt, Ee, qe);
            }
            case ft:
              var Tn = Ee._payload, fn = Ee._init;
              return ne(Q, de, K, fn(Tn), qe);
          }
          if (Qt(Ee) || Ia(Ee)) {
            var kr = Q.get(K) || null;
            return P(de, kr, Ee, qe, null);
          }
          p0(de, Ee);
        }
        return typeof Ee == "function" && h0(de), null;
      }
      function ie(Q, de, K) {
        {
          if (typeof Q != "object" || Q === null)
            return de;
          switch (Q.$$typeof) {
            case io:
            case di:
              Ik(Q, K);
              var Ee = Q.key;
              if (typeof Ee != "string")
                break;
              if (de === null) {
                de = /* @__PURE__ */ new Set(), de.add(Ee);
                break;
              }
              if (!de.has(Ee)) {
                de.add(Ee);
                break;
              }
              p("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Ee);
              break;
            case ft:
              var qe = Q._payload, Be = Q._init;
              ie(Be(qe), de, K);
              break;
          }
        }
        return de;
      }
      function fe(Q, de, K, Ee) {
        for (var qe = null, Be = 0; Be < K.length; Be++) {
          var wt = K[Be];
          qe = ie(wt, qe, Q);
        }
        for (var Rt = null, Tn = null, fn = de, kr = 0, dn = 0, Sr = null; fn !== null && dn < K.length; dn++) {
          fn.index > dn ? (Sr = fn, fn = null) : Sr = fn.sibling;
          var Hi = W(Q, fn, K[dn], Ee);
          if (Hi === null) {
            fn === null && (fn = Sr);
            break;
          }
          e && fn && Hi.alternate === null && r(Q, fn), kr = y(Hi, kr, dn), Tn === null ? Rt = Hi : Tn.sibling = Hi, Tn = Hi, fn = Sr;
        }
        if (dn === K.length) {
          if (s(Q, fn), gi()) {
            var Ci = dn;
            Cf(Q, Ci);
          }
          return Rt;
        }
        if (fn === null) {
          for (; dn < K.length; dn++) {
            var Xa = Z(Q, K[dn], Ee);
            Xa !== null && (kr = y(Xa, kr, dn), Tn === null ? Rt = Xa : Tn.sibling = Xa, Tn = Xa);
          }
          if (gi()) {
            var sa = dn;
            Cf(Q, sa);
          }
          return Rt;
        }
        for (var ua = c(Q, fn); dn < K.length; dn++) {
          var Vi = ne(ua, Q, dn, K[dn], Ee);
          Vi !== null && (e && Vi.alternate !== null && ua.delete(Vi.key === null ? dn : Vi.key), kr = y(Vi, kr, dn), Tn === null ? Rt = Vi : Tn.sibling = Vi, Tn = Vi);
        }
        if (e && ua.forEach(function(jp) {
          return r(Q, jp);
        }), gi()) {
          var ru = dn;
          Cf(Q, ru);
        }
        return Rt;
      }
      function Ze(Q, de, K, Ee) {
        var qe = Ia(K);
        if (typeof qe != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          K[Symbol.toStringTag] === "Generator" && (Dx || p("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Dx = !0), K.entries === qe && (Ax || p("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ax = !0);
          var Be = qe.call(K);
          if (Be)
            for (var wt = null, Rt = Be.next(); !Rt.done; Rt = Be.next()) {
              var Tn = Rt.value;
              wt = ie(Tn, wt, Q);
            }
        }
        var fn = qe.call(K);
        if (fn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var kr = null, dn = null, Sr = de, Hi = 0, Ci = 0, Xa = null, sa = fn.next(); Sr !== null && !sa.done; Ci++, sa = fn.next()) {
          Sr.index > Ci ? (Xa = Sr, Sr = null) : Xa = Sr.sibling;
          var ua = W(Q, Sr, sa.value, Ee);
          if (ua === null) {
            Sr === null && (Sr = Xa);
            break;
          }
          e && Sr && ua.alternate === null && r(Q, Sr), Hi = y(ua, Hi, Ci), dn === null ? kr = ua : dn.sibling = ua, dn = ua, Sr = Xa;
        }
        if (sa.done) {
          if (s(Q, Sr), gi()) {
            var Vi = Ci;
            Cf(Q, Vi);
          }
          return kr;
        }
        if (Sr === null) {
          for (; !sa.done; Ci++, sa = fn.next()) {
            var ru = Z(Q, sa.value, Ee);
            ru !== null && (Hi = y(ru, Hi, Ci), dn === null ? kr = ru : dn.sibling = ru, dn = ru);
          }
          if (gi()) {
            var jp = Ci;
            Cf(Q, jp);
          }
          return kr;
        }
        for (var Ev = c(Q, Sr); !sa.done; Ci++, sa = fn.next()) {
          var rs = ne(Ev, Q, Ci, sa.value, Ee);
          rs !== null && (e && rs.alternate !== null && Ev.delete(rs.key === null ? Ci : rs.key), Hi = y(rs, Hi, Ci), dn === null ? kr = rs : dn.sibling = rs, dn = rs);
        }
        if (e && Ev.forEach(function(a5) {
          return r(Q, a5);
        }), gi()) {
          var i5 = Ci;
          Cf(Q, i5);
        }
        return kr;
      }
      function dt(Q, de, K, Ee) {
        if (de !== null && de.tag === N) {
          s(Q, de.sibling);
          var qe = h(de, K);
          return qe.return = Q, qe;
        }
        s(Q, de);
        var Be = l_(K, Q.mode, Ee);
        return Be.return = Q, Be;
      }
      function st(Q, de, K, Ee) {
        for (var qe = K.key, Be = de; Be !== null; ) {
          if (Be.key === qe) {
            var wt = K.type;
            if (wt === Ki) {
              if (Be.tag === z) {
                s(Q, Be.sibling);
                var Rt = h(Be, K.props.children);
                return Rt.return = Q, Rt._debugSource = K._source, Rt._debugOwner = K._owner, Rt;
              }
            } else if (Be.elementType === wt || // Keep this check inline so it only runs on the false path:
            D2(Be, K) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof wt == "object" && wt !== null && wt.$$typeof === ft && Fk(wt) === Be.type) {
              s(Q, Be.sibling);
              var Tn = h(Be, K.props);
              return Tn.ref = qm(Q, Be, K), Tn.return = Q, Tn._debugSource = K._source, Tn._debugOwner = K._owner, Tn;
            }
            s(Q, Be);
            break;
          } else
            r(Q, Be);
          Be = Be.sibling;
        }
        if (K.type === Ki) {
          var fn = Sc(K.props.children, Q.mode, Ee, K.key);
          return fn.return = Q, fn;
        } else {
          var kr = o_(K, Q.mode, Ee);
          return kr.ref = qm(Q, de, K), kr.return = Q, kr;
        }
      }
      function tn(Q, de, K, Ee) {
        for (var qe = K.key, Be = de; Be !== null; ) {
          if (Be.key === qe)
            if (Be.tag === R && Be.stateNode.containerInfo === K.containerInfo && Be.stateNode.implementation === K.implementation) {
              s(Q, Be.sibling);
              var wt = h(Be, K.children || []);
              return wt.return = Q, wt;
            } else {
              s(Q, Be);
              break;
            }
          else
            r(Q, Be);
          Be = Be.sibling;
        }
        var Rt = s_(K, Q.mode, Ee);
        return Rt.return = Q, Rt;
      }
      function Xt(Q, de, K, Ee) {
        var qe = typeof K == "object" && K !== null && K.type === Ki && K.key === null;
        if (qe && (K = K.props.children), typeof K == "object" && K !== null) {
          switch (K.$$typeof) {
            case io:
              return x(st(Q, de, K, Ee));
            case di:
              return x(tn(Q, de, K, Ee));
            case ft:
              var Be = K._payload, wt = K._init;
              return Xt(Q, de, wt(Be), Ee);
          }
          if (Qt(K))
            return fe(Q, de, K, Ee);
          if (Ia(K))
            return Ze(Q, de, K, Ee);
          p0(Q, K);
        }
        return typeof K == "string" && K !== "" || typeof K == "number" ? x(dt(Q, de, "" + K, Ee)) : (typeof K == "function" && h0(Q), s(Q, de));
      }
      return Xt;
    }
    var wp = Uk(!0), Bk = Uk(!1);
    function YN(e, r) {
      if (e !== null && r.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (r.child !== null) {
        var s = r.child, c = jf(s, s.pendingProps);
        for (r.child = c, c.return = r; s.sibling !== null; )
          s = s.sibling, c = c.sibling = jf(s, s.pendingProps), c.return = r;
        c.sibling = null;
      }
    }
    function ZN(e, r) {
      for (var s = e.child; s !== null; )
        wP(s, r), s = s.sibling;
    }
    var Gm = {}, fc = oc(Gm), Xm = oc(Gm), m0 = oc(Gm);
    function v0(e) {
      if (e === Gm)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Hk() {
      var e = v0(m0.current);
      return e;
    }
    function Px(e, r) {
      Ui(m0, r, e), Ui(Xm, e, e), Ui(fc, Gm, e);
      var s = lM(r);
      Fi(fc, e), Ui(fc, s, e);
    }
    function _p(e) {
      Fi(fc, e), Fi(Xm, e), Fi(m0, e);
    }
    function zx() {
      var e = v0(fc.current);
      return e;
    }
    function Vk(e) {
      v0(m0.current);
      var r = v0(fc.current), s = sM(r, e.type);
      r !== s && (Ui(Xm, e, e), Ui(fc, s, e));
    }
    function $x(e) {
      Xm.current === e && (Fi(fc, e), Fi(Xm, e));
    }
    var qN = 0, Wk = 1, Yk = 1, Qm = 2, Ko = oc(qN);
    function jx(e, r) {
      return (e & r) !== 0;
    }
    function Ep(e) {
      return e & Wk;
    }
    function Ix(e, r) {
      return e & Wk | r;
    }
    function GN(e, r) {
      return e | r;
    }
    function dc(e, r) {
      Ui(Ko, r, e);
    }
    function Cp(e) {
      Fi(Ko, e);
    }
    function XN(e, r) {
      var s = e.memoizedState;
      return s !== null ? s.dehydrated !== null : (e.memoizedProps, !0);
    }
    function y0(e) {
      for (var r = e; r !== null; ) {
        if (r.tag === ee) {
          var s = r.memoizedState;
          if (s !== null) {
            var c = s.dehydrated;
            if (c === null || nk(c) || W1(c))
              return r;
          }
        } else if (r.tag === xe && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        r.memoizedProps.revealOrder !== void 0) {
          var h = (r.flags & _t) !== ct;
          if (h)
            return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === e)
          return null;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    var Aa = (
      /*   */
      0
    ), Vr = (
      /* */
      1
    ), Xl = (
      /*  */
      2
    ), Wr = (
      /*    */
      4
    ), bi = (
      /*   */
      8
    ), Fx = [];
    function Ux() {
      for (var e = 0; e < Fx.length; e++) {
        var r = Fx[e];
        r._workInProgressVersionPrimary = null;
      }
      Fx.length = 0;
    }
    function QN(e, r) {
      var s = r._getVersion, c = s(r._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, c] : e.mutableSourceEagerHydrationData.push(r, c);
    }
    var Ve = i.ReactCurrentDispatcher, Km = i.ReactCurrentBatchConfig, Bx, kp;
    Bx = /* @__PURE__ */ new Set();
    var Df = pe, kn = null, Yr = null, Zr = null, g0 = !1, Jm = !1, ev = 0, KN = 0, JN = 25, he = null, xo = null, pc = -1, Hx = !1;
    function bn() {
      {
        var e = he;
        xo === null ? xo = [e] : xo.push(e);
      }
    }
    function je() {
      {
        var e = he;
        xo !== null && (pc++, xo[pc] !== e && eL(e));
      }
    }
    function Tp(e) {
      e != null && !Qt(e) && p("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", he, typeof e);
    }
    function eL(e) {
      {
        var r = kt(kn);
        if (!Bx.has(r) && (Bx.add(r), xo !== null)) {
          for (var s = "", c = 30, h = 0; h <= pc; h++) {
            for (var y = xo[h], x = h === pc ? e : y, C = h + 1 + ". " + y; C.length < c; )
              C += " ";
            C += x + `
`, s += C;
          }
          p(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, r, s);
        }
      }
    }
    function Bi() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function Vx(e, r) {
      if (Hx)
        return !1;
      if (r === null)
        return p("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", he), !1;
      e.length !== r.length && p(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, he, "[" + r.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var s = 0; s < r.length && s < e.length; s++)
        if (!tt(e[s], r[s]))
          return !1;
      return !0;
    }
    function Rp(e, r, s, c, h, y) {
      Df = y, kn = r, xo = e !== null ? e._debugHookTypes : null, pc = -1, Hx = e !== null && e.type !== r.type, r.memoizedState = null, r.updateQueue = null, r.lanes = pe, e !== null && e.memoizedState !== null ? Ve.current = hT : xo !== null ? Ve.current = pT : Ve.current = dT;
      var x = s(c, h);
      if (Jm) {
        var C = 0;
        do {
          if (Jm = !1, ev = 0, C >= JN)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          C += 1, Hx = !1, Yr = null, Zr = null, r.updateQueue = null, pc = -1, Ve.current = mT, x = s(c, h);
        } while (Jm);
      }
      Ve.current = D0, r._debugHookTypes = xo;
      var T = Yr !== null && Yr.next !== null;
      if (Df = pe, kn = null, Yr = null, Zr = null, he = null, xo = null, pc = -1, e !== null && (e.flags & Ur) !== (r.flags & Ur) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & Bt) !== ht && p("Internal React error: Expected static flag was missing. Please notify the React team."), g0 = !1, T)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return x;
    }
    function Op() {
      var e = ev !== 0;
      return ev = 0, e;
    }
    function Zk(e, r, s) {
      r.updateQueue = e.updateQueue, (r.mode & wa) !== ht ? r.flags &= ~(Cs | Li | Hn | Pt) : r.flags &= ~(Hn | Pt), e.lanes = Hu(e.lanes, s);
    }
    function qk() {
      if (Ve.current = D0, g0) {
        for (var e = kn.memoizedState; e !== null; ) {
          var r = e.queue;
          r !== null && (r.pending = null), e = e.next;
        }
        g0 = !1;
      }
      Df = pe, kn = null, Yr = null, Zr = null, xo = null, pc = -1, he = null, lT = !1, Jm = !1, ev = 0;
    }
    function Ql() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Zr === null ? kn.memoizedState = Zr = e : Zr = Zr.next = e, Zr;
    }
    function wo() {
      var e;
      if (Yr === null) {
        var r = kn.alternate;
        r !== null ? e = r.memoizedState : e = null;
      } else
        e = Yr.next;
      var s;
      if (Zr === null ? s = kn.memoizedState : s = Zr.next, s !== null)
        Zr = s, s = Zr.next, Yr = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Yr = e;
        var c = {
          memoizedState: Yr.memoizedState,
          baseState: Yr.baseState,
          baseQueue: Yr.baseQueue,
          queue: Yr.queue,
          next: null
        };
        Zr === null ? kn.memoizedState = Zr = c : Zr = Zr.next = c;
      }
      return Zr;
    }
    function Gk() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Wx(e, r) {
      return typeof r == "function" ? r(e) : r;
    }
    function Yx(e, r, s) {
      var c = Ql(), h;
      s !== void 0 ? h = s(r) : h = r, c.memoizedState = c.baseState = h;
      var y = {
        pending: null,
        interleaved: null,
        lanes: pe,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: h
      };
      c.queue = y;
      var x = y.dispatch = iL.bind(null, kn, y);
      return [c.memoizedState, x];
    }
    function Zx(e, r, s) {
      var c = wo(), h = c.queue;
      if (h === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      h.lastRenderedReducer = e;
      var y = Yr, x = y.baseQueue, C = h.pending;
      if (C !== null) {
        if (x !== null) {
          var T = x.next, M = C.next;
          x.next = M, C.next = T;
        }
        y.baseQueue !== x && p("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), y.baseQueue = x = C, h.pending = null;
      }
      if (x !== null) {
        var P = x.next, Z = y.baseState, W = null, ne = null, ie = null, fe = P;
        do {
          var Ze = fe.lane;
          if (Ps(Df, Ze)) {
            if (ie !== null) {
              var st = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Jt,
                action: fe.action,
                hasEagerState: fe.hasEagerState,
                eagerState: fe.eagerState,
                next: null
              };
              ie = ie.next = st;
            }
            if (fe.hasEagerState)
              Z = fe.eagerState;
            else {
              var tn = fe.action;
              Z = e(Z, tn);
            }
          } else {
            var dt = {
              lane: Ze,
              action: fe.action,
              hasEagerState: fe.hasEagerState,
              eagerState: fe.eagerState,
              next: null
            };
            ie === null ? (ne = ie = dt, W = Z) : ie = ie.next = dt, kn.lanes = zt(kn.lanes, Ze), bv(Ze);
          }
          fe = fe.next;
        } while (fe !== null && fe !== P);
        ie === null ? W = Z : ie.next = ne, tt(Z, c.memoizedState) || lv(), c.memoizedState = Z, c.baseState = W, c.baseQueue = ie, h.lastRenderedState = Z;
      }
      var Xt = h.interleaved;
      if (Xt !== null) {
        var Q = Xt;
        do {
          var de = Q.lane;
          kn.lanes = zt(kn.lanes, de), bv(de), Q = Q.next;
        } while (Q !== Xt);
      } else
        x === null && (h.lanes = pe);
      var K = h.dispatch;
      return [c.memoizedState, K];
    }
    function qx(e, r, s) {
      var c = wo(), h = c.queue;
      if (h === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      h.lastRenderedReducer = e;
      var y = h.dispatch, x = h.pending, C = c.memoizedState;
      if (x !== null) {
        h.pending = null;
        var T = x.next, M = T;
        do {
          var P = M.action;
          C = e(C, P), M = M.next;
        } while (M !== T);
        tt(C, c.memoizedState) || lv(), c.memoizedState = C, c.baseQueue === null && (c.baseState = C), h.lastRenderedState = C;
      }
      return [C, y];
    }
    function tV(e, r, s) {
    }
    function nV(e, r, s) {
    }
    function Gx(e, r, s) {
      var c = kn, h = Ql(), y, x = gi();
      if (x) {
        if (s === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        y = s(), kp || y !== s() && (p("The result of getServerSnapshot should be cached to avoid an infinite loop"), kp = !0);
      } else {
        if (y = r(), !kp) {
          var C = r();
          tt(y, C) || (p("The result of getSnapshot should be cached to avoid an infinite loop"), kp = !0);
        }
        var T = G0();
        if (T === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        sf(T, Df) || Xk(c, r, y);
      }
      h.memoizedState = y;
      var M = {
        value: y,
        getSnapshot: r
      };
      return h.queue = M, _0(Kk.bind(null, c, M, e), [e]), c.flags |= Hn, tv(Vr | bi, Qk.bind(null, c, M, y, r), void 0, null), y;
    }
    function b0(e, r, s) {
      var c = kn, h = wo(), y = r();
      if (!kp) {
        var x = r();
        tt(y, x) || (p("The result of getSnapshot should be cached to avoid an infinite loop"), kp = !0);
      }
      var C = h.memoizedState, T = !tt(C, y);
      T && (h.memoizedState = y, lv());
      var M = h.queue;
      if (rv(Kk.bind(null, c, M, e), [e]), M.getSnapshot !== r || T || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Zr !== null && Zr.memoizedState.tag & Vr) {
        c.flags |= Hn, tv(Vr | bi, Qk.bind(null, c, M, y, r), void 0, null);
        var P = G0();
        if (P === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        sf(P, Df) || Xk(c, r, y);
      }
      return y;
    }
    function Xk(e, r, s) {
      e.flags |= Kc;
      var c = {
        getSnapshot: r,
        value: s
      }, h = kn.updateQueue;
      if (h === null)
        h = Gk(), kn.updateQueue = h, h.stores = [c];
      else {
        var y = h.stores;
        y === null ? h.stores = [c] : y.push(c);
      }
    }
    function Qk(e, r, s, c) {
      r.value = s, r.getSnapshot = c, Jk(r) && eT(e);
    }
    function Kk(e, r, s) {
      var c = function() {
        Jk(r) && eT(e);
      };
      return s(c);
    }
    function Jk(e) {
      var r = e.getSnapshot, s = e.value;
      try {
        var c = r();
        return !tt(s, c);
      } catch {
        return !0;
      }
    }
    function eT(e) {
      var r = Oa(e, bt);
      r !== null && Qr(r, e, bt, Dn);
    }
    function S0(e) {
      var r = Ql();
      typeof e == "function" && (e = e()), r.memoizedState = r.baseState = e;
      var s = {
        pending: null,
        interleaved: null,
        lanes: pe,
        dispatch: null,
        lastRenderedReducer: Wx,
        lastRenderedState: e
      };
      r.queue = s;
      var c = s.dispatch = aL.bind(null, kn, s);
      return [r.memoizedState, c];
    }
    function Xx(e) {
      return Zx(Wx);
    }
    function Qx(e) {
      return qx(Wx);
    }
    function tv(e, r, s, c) {
      var h = {
        tag: e,
        create: r,
        destroy: s,
        deps: c,
        // Circular
        next: null
      }, y = kn.updateQueue;
      if (y === null)
        y = Gk(), kn.updateQueue = y, y.lastEffect = h.next = h;
      else {
        var x = y.lastEffect;
        if (x === null)
          y.lastEffect = h.next = h;
        else {
          var C = x.next;
          x.next = h, h.next = C, y.lastEffect = h;
        }
      }
      return h;
    }
    function Kx(e) {
      var r = Ql();
      {
        var s = {
          current: e
        };
        return r.memoizedState = s, s;
      }
    }
    function x0(e) {
      var r = wo();
      return r.memoizedState;
    }
    function nv(e, r, s, c) {
      var h = Ql(), y = c === void 0 ? null : c;
      kn.flags |= e, h.memoizedState = tv(Vr | r, s, void 0, y);
    }
    function w0(e, r, s, c) {
      var h = wo(), y = c === void 0 ? null : c, x = void 0;
      if (Yr !== null) {
        var C = Yr.memoizedState;
        if (x = C.destroy, y !== null) {
          var T = C.deps;
          if (Vx(y, T)) {
            h.memoizedState = tv(r, s, x, y);
            return;
          }
        }
      }
      kn.flags |= e, h.memoizedState = tv(Vr | r, s, x, y);
    }
    function _0(e, r) {
      return (kn.mode & wa) !== ht ? nv(Cs | Hn | Nl, bi, e, r) : nv(Hn | Nl, bi, e, r);
    }
    function rv(e, r) {
      return w0(Hn, bi, e, r);
    }
    function Jx(e, r) {
      return nv(Pt, Xl, e, r);
    }
    function E0(e, r) {
      return w0(Pt, Xl, e, r);
    }
    function ew(e, r) {
      var s = Pt;
      return s |= Ni, (kn.mode & wa) !== ht && (s |= Li), nv(s, Wr, e, r);
    }
    function C0(e, r) {
      return w0(Pt, Wr, e, r);
    }
    function tT(e, r) {
      if (typeof r == "function") {
        var s = r, c = e();
        return s(c), function() {
          s(null);
        };
      } else if (r != null) {
        var h = r;
        h.hasOwnProperty("current") || p("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(h).join(", ") + "}");
        var y = e();
        return h.current = y, function() {
          h.current = null;
        };
      }
    }
    function tw(e, r, s) {
      typeof r != "function" && p("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var c = s != null ? s.concat([e]) : null, h = Pt;
      return h |= Ni, (kn.mode & wa) !== ht && (h |= Li), nv(h, Wr, tT.bind(null, r, e), c);
    }
    function k0(e, r, s) {
      typeof r != "function" && p("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var c = s != null ? s.concat([e]) : null;
      return w0(Pt, Wr, tT.bind(null, r, e), c);
    }
    function tL(e, r) {
    }
    var T0 = tL;
    function nw(e, r) {
      var s = Ql(), c = r === void 0 ? null : r;
      return s.memoizedState = [e, c], e;
    }
    function R0(e, r) {
      var s = wo(), c = r === void 0 ? null : r, h = s.memoizedState;
      if (h !== null && c !== null) {
        var y = h[1];
        if (Vx(c, y))
          return h[0];
      }
      return s.memoizedState = [e, c], e;
    }
    function rw(e, r) {
      var s = Ql(), c = r === void 0 ? null : r, h = e();
      return s.memoizedState = [h, c], h;
    }
    function O0(e, r) {
      var s = wo(), c = r === void 0 ? null : r, h = s.memoizedState;
      if (h !== null && c !== null) {
        var y = h[1];
        if (Vx(c, y))
          return h[0];
      }
      var x = e();
      return s.memoizedState = [x, c], x;
    }
    function iw(e) {
      var r = Ql();
      return r.memoizedState = e, e;
    }
    function nT(e) {
      var r = wo(), s = Yr, c = s.memoizedState;
      return iT(r, c, e);
    }
    function rT(e) {
      var r = wo();
      if (Yr === null)
        return r.memoizedState = e, e;
      var s = Yr.memoizedState;
      return iT(r, s, e);
    }
    function iT(e, r, s) {
      var c = !c1(Df);
      if (c) {
        if (!tt(s, r)) {
          var h = im();
          kn.lanes = zt(kn.lanes, h), bv(h), e.baseState = !0;
        }
        return r;
      } else
        return e.baseState && (e.baseState = !1, lv()), e.memoizedState = s, s;
    }
    function nL(e, r, s) {
      var c = Ea();
      _r(ii(c, Hr)), e(!0);
      var h = Km.transition;
      Km.transition = {};
      var y = Km.transition;
      Km.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), r();
      } finally {
        if (_r(c), Km.transition = h, h === null && y._updatedFibers) {
          var x = y._updatedFibers.size;
          x > 10 && f("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), y._updatedFibers.clear();
        }
      }
    }
    function aw() {
      var e = S0(!1), r = e[0], s = e[1], c = nL.bind(null, s), h = Ql();
      return h.memoizedState = c, [r, c];
    }
    function aT() {
      var e = Xx(), r = e[0], s = wo(), c = s.memoizedState;
      return [r, c];
    }
    function oT() {
      var e = Qx(), r = e[0], s = wo(), c = s.memoizedState;
      return [r, c];
    }
    var lT = !1;
    function rL() {
      return lT;
    }
    function ow() {
      var e = Ql(), r = G0(), s = r.identifierPrefix, c;
      if (gi()) {
        var h = yN();
        c = ":" + s + "R" + h;
        var y = ev++;
        y > 0 && (c += "H" + y.toString(32)), c += ":";
      } else {
        var x = KN++;
        c = ":" + s + "r" + x.toString(32) + ":";
      }
      return e.memoizedState = c, c;
    }
    function A0() {
      var e = wo(), r = e.memoizedState;
      return r;
    }
    function iL(e, r, s) {
      typeof arguments[3] == "function" && p("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var c = gc(e), h = {
        lane: c,
        action: s,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (sT(e))
        uT(r, h);
      else {
        var y = kk(e, r, h, c);
        if (y !== null) {
          var x = la();
          Qr(y, e, c, x), cT(y, r, c);
        }
      }
      fT(e, c);
    }
    function aL(e, r, s) {
      typeof arguments[3] == "function" && p("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var c = gc(e), h = {
        lane: c,
        action: s,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (sT(e))
        uT(r, h);
      else {
        var y = e.alternate;
        if (e.lanes === pe && (y === null || y.lanes === pe)) {
          var x = r.lastRenderedReducer;
          if (x !== null) {
            var C;
            C = Ve.current, Ve.current = Jo;
            try {
              var T = r.lastRenderedState, M = x(T, s);
              if (h.hasEagerState = !0, h.eagerState = M, tt(M, T)) {
                $N(e, r, h, c);
                return;
              }
            } catch {
            } finally {
              Ve.current = C;
            }
          }
        }
        var P = kk(e, r, h, c);
        if (P !== null) {
          var Z = la();
          Qr(P, e, c, Z), cT(P, r, c);
        }
      }
      fT(e, c);
    }
    function sT(e) {
      var r = e.alternate;
      return e === kn || r !== null && r === kn;
    }
    function uT(e, r) {
      Jm = g0 = !0;
      var s = e.pending;
      s === null ? r.next = r : (r.next = s.next, s.next = r), e.pending = r;
    }
    function cT(e, r, s) {
      if (rm(s)) {
        var c = r.lanes;
        c = am(c, e.pendingLanes);
        var h = zt(c, s);
        r.lanes = h, Vu(e, h);
      }
    }
    function fT(e, r, s) {
      Il(e, r);
    }
    var D0 = {
      readContext: zr,
      useCallback: Bi,
      useContext: Bi,
      useEffect: Bi,
      useImperativeHandle: Bi,
      useInsertionEffect: Bi,
      useLayoutEffect: Bi,
      useMemo: Bi,
      useReducer: Bi,
      useRef: Bi,
      useState: Bi,
      useDebugValue: Bi,
      useDeferredValue: Bi,
      useTransition: Bi,
      useMutableSource: Bi,
      useSyncExternalStore: Bi,
      useId: Bi,
      unstable_isNewReconciler: ye
    }, dT = null, pT = null, hT = null, mT = null, Kl = null, Jo = null, M0 = null;
    {
      var lw = function() {
        p("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Tt = function() {
        p("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      dT = {
        readContext: function(e) {
          return zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", bn(), Tp(r), nw(e, r);
        },
        useContext: function(e) {
          return he = "useContext", bn(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", bn(), Tp(r), _0(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", bn(), Tp(s), tw(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", bn(), Tp(r), Jx(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", bn(), Tp(r), ew(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", bn(), Tp(r);
          var s = Ve.current;
          Ve.current = Kl;
          try {
            return rw(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", bn();
          var c = Ve.current;
          Ve.current = Kl;
          try {
            return Yx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", bn(), Kx(e);
        },
        useState: function(e) {
          he = "useState", bn();
          var r = Ve.current;
          Ve.current = Kl;
          try {
            return S0(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", bn(), void 0;
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", bn(), iw(e);
        },
        useTransition: function() {
          return he = "useTransition", bn(), aw();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", bn(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", bn(), Gx(e, r, s);
        },
        useId: function() {
          return he = "useId", bn(), ow();
        },
        unstable_isNewReconciler: ye
      }, pT = {
        readContext: function(e) {
          return zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", je(), nw(e, r);
        },
        useContext: function(e) {
          return he = "useContext", je(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", je(), _0(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", je(), tw(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", je(), Jx(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", je(), ew(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", je();
          var s = Ve.current;
          Ve.current = Kl;
          try {
            return rw(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", je();
          var c = Ve.current;
          Ve.current = Kl;
          try {
            return Yx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", je(), Kx(e);
        },
        useState: function(e) {
          he = "useState", je();
          var r = Ve.current;
          Ve.current = Kl;
          try {
            return S0(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", je(), void 0;
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", je(), iw(e);
        },
        useTransition: function() {
          return he = "useTransition", je(), aw();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", je(), Gx(e, r, s);
        },
        useId: function() {
          return he = "useId", je(), ow();
        },
        unstable_isNewReconciler: ye
      }, hT = {
        readContext: function(e) {
          return zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", je(), R0(e, r);
        },
        useContext: function(e) {
          return he = "useContext", je(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", je(), rv(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", je(), k0(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", je(), E0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", je(), C0(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", je();
          var s = Ve.current;
          Ve.current = Jo;
          try {
            return O0(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", je();
          var c = Ve.current;
          Ve.current = Jo;
          try {
            return Zx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", je(), x0();
        },
        useState: function(e) {
          he = "useState", je();
          var r = Ve.current;
          Ve.current = Jo;
          try {
            return Xx(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", je(), T0();
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", je(), nT(e);
        },
        useTransition: function() {
          return he = "useTransition", je(), aT();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", je(), b0(e, r);
        },
        useId: function() {
          return he = "useId", je(), A0();
        },
        unstable_isNewReconciler: ye
      }, mT = {
        readContext: function(e) {
          return zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", je(), R0(e, r);
        },
        useContext: function(e) {
          return he = "useContext", je(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", je(), rv(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", je(), k0(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", je(), E0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", je(), C0(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", je();
          var s = Ve.current;
          Ve.current = M0;
          try {
            return O0(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", je();
          var c = Ve.current;
          Ve.current = M0;
          try {
            return qx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", je(), x0();
        },
        useState: function(e) {
          he = "useState", je();
          var r = Ve.current;
          Ve.current = M0;
          try {
            return Qx(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", je(), T0();
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", je(), rT(e);
        },
        useTransition: function() {
          return he = "useTransition", je(), oT();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", je(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", je(), b0(e, r);
        },
        useId: function() {
          return he = "useId", je(), A0();
        },
        unstable_isNewReconciler: ye
      }, Kl = {
        readContext: function(e) {
          return lw(), zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", Tt(), bn(), nw(e, r);
        },
        useContext: function(e) {
          return he = "useContext", Tt(), bn(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", Tt(), bn(), _0(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", Tt(), bn(), tw(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", Tt(), bn(), Jx(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", Tt(), bn(), ew(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", Tt(), bn();
          var s = Ve.current;
          Ve.current = Kl;
          try {
            return rw(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", Tt(), bn();
          var c = Ve.current;
          Ve.current = Kl;
          try {
            return Yx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", Tt(), bn(), Kx(e);
        },
        useState: function(e) {
          he = "useState", Tt(), bn();
          var r = Ve.current;
          Ve.current = Kl;
          try {
            return S0(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", Tt(), bn(), void 0;
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", Tt(), bn(), iw(e);
        },
        useTransition: function() {
          return he = "useTransition", Tt(), bn(), aw();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", Tt(), bn(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", Tt(), bn(), Gx(e, r, s);
        },
        useId: function() {
          return he = "useId", Tt(), bn(), ow();
        },
        unstable_isNewReconciler: ye
      }, Jo = {
        readContext: function(e) {
          return lw(), zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", Tt(), je(), R0(e, r);
        },
        useContext: function(e) {
          return he = "useContext", Tt(), je(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", Tt(), je(), rv(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", Tt(), je(), k0(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", Tt(), je(), E0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", Tt(), je(), C0(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", Tt(), je();
          var s = Ve.current;
          Ve.current = Jo;
          try {
            return O0(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", Tt(), je();
          var c = Ve.current;
          Ve.current = Jo;
          try {
            return Zx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", Tt(), je(), x0();
        },
        useState: function(e) {
          he = "useState", Tt(), je();
          var r = Ve.current;
          Ve.current = Jo;
          try {
            return Xx(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", Tt(), je(), T0();
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", Tt(), je(), nT(e);
        },
        useTransition: function() {
          return he = "useTransition", Tt(), je(), aT();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", Tt(), je(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", Tt(), je(), b0(e, r);
        },
        useId: function() {
          return he = "useId", Tt(), je(), A0();
        },
        unstable_isNewReconciler: ye
      }, M0 = {
        readContext: function(e) {
          return lw(), zr(e);
        },
        useCallback: function(e, r) {
          return he = "useCallback", Tt(), je(), R0(e, r);
        },
        useContext: function(e) {
          return he = "useContext", Tt(), je(), zr(e);
        },
        useEffect: function(e, r) {
          return he = "useEffect", Tt(), je(), rv(e, r);
        },
        useImperativeHandle: function(e, r, s) {
          return he = "useImperativeHandle", Tt(), je(), k0(e, r, s);
        },
        useInsertionEffect: function(e, r) {
          return he = "useInsertionEffect", Tt(), je(), E0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return he = "useLayoutEffect", Tt(), je(), C0(e, r);
        },
        useMemo: function(e, r) {
          he = "useMemo", Tt(), je();
          var s = Ve.current;
          Ve.current = Jo;
          try {
            return O0(e, r);
          } finally {
            Ve.current = s;
          }
        },
        useReducer: function(e, r, s) {
          he = "useReducer", Tt(), je();
          var c = Ve.current;
          Ve.current = Jo;
          try {
            return qx(e, r, s);
          } finally {
            Ve.current = c;
          }
        },
        useRef: function(e) {
          return he = "useRef", Tt(), je(), x0();
        },
        useState: function(e) {
          he = "useState", Tt(), je();
          var r = Ve.current;
          Ve.current = Jo;
          try {
            return Qx(e);
          } finally {
            Ve.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return he = "useDebugValue", Tt(), je(), T0();
        },
        useDeferredValue: function(e) {
          return he = "useDeferredValue", Tt(), je(), rT(e);
        },
        useTransition: function() {
          return he = "useTransition", Tt(), je(), oT();
        },
        useMutableSource: function(e, r, s) {
          return he = "useMutableSource", Tt(), je(), void 0;
        },
        useSyncExternalStore: function(e, r, s) {
          return he = "useSyncExternalStore", Tt(), je(), b0(e, r);
        },
        useId: function() {
          return he = "useId", Tt(), je(), A0();
        },
        unstable_isNewReconciler: ye
      };
    }
    var hc = n.unstable_now, vT = 0, N0 = -1, iv = -1, L0 = -1, sw = !1, P0 = !1;
    function yT() {
      return sw;
    }
    function oL() {
      P0 = !0;
    }
    function lL() {
      sw = !1, P0 = !1;
    }
    function sL() {
      sw = P0, P0 = !1;
    }
    function gT() {
      return vT;
    }
    function bT() {
      vT = hc();
    }
    function uw(e) {
      iv = hc(), e.actualStartTime < 0 && (e.actualStartTime = hc());
    }
    function ST(e) {
      iv = -1;
    }
    function z0(e, r) {
      if (iv >= 0) {
        var s = hc() - iv;
        e.actualDuration += s, r && (e.selfBaseDuration = s), iv = -1;
      }
    }
    function Jl(e) {
      if (N0 >= 0) {
        var r = hc() - N0;
        N0 = -1;
        for (var s = e.return; s !== null; ) {
          switch (s.tag) {
            case w:
              var c = s.stateNode;
              c.effectDuration += r;
              return;
            case te:
              var h = s.stateNode;
              h.effectDuration += r;
              return;
          }
          s = s.return;
        }
      }
    }
    function cw(e) {
      if (L0 >= 0) {
        var r = hc() - L0;
        L0 = -1;
        for (var s = e.return; s !== null; ) {
          switch (s.tag) {
            case w:
              var c = s.stateNode;
              c !== null && (c.passiveEffectDuration += r);
              return;
            case te:
              var h = s.stateNode;
              h !== null && (h.passiveEffectDuration += r);
              return;
          }
          s = s.return;
        }
      }
    }
    function es() {
      N0 = hc();
    }
    function fw() {
      L0 = hc();
    }
    function dw(e) {
      for (var r = e.child; r; )
        e.actualDuration += r.actualDuration, r = r.sibling;
    }
    function Mf(e, r) {
      return {
        value: e,
        source: r,
        stack: xu(r),
        digest: null
      };
    }
    function pw(e, r, s) {
      return {
        value: e,
        source: null,
        stack: s ?? null,
        digest: r ?? null
      };
    }
    function uL(e, r) {
      return !0;
    }
    function hw(e, r) {
      try {
        var s = uL(e, r);
        if (s === !1)
          return;
        var c = r.value, h = r.source, y = r.stack, x = y !== null ? y : "";
        if (c != null && c._suppressLogging) {
          if (e.tag === S)
            return;
          console.error(c);
        }
        var C = h ? kt(h) : null, T = C ? "The above error occurred in the <" + C + "> component:" : "The above error occurred in one of your React components:", M;
        if (e.tag === w)
          M = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var P = kt(e) || "Anonymous";
          M = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + P + ".");
        }
        var Z = T + `
` + x + `

` + ("" + M);
        console.error(Z);
      } catch (W) {
        setTimeout(function() {
          throw W;
        });
      }
    }
    var cL = typeof WeakMap == "function" ? WeakMap : Map;
    function xT(e, r, s) {
      var c = Qs(Dn, s);
      c.tag = hx, c.payload = {
        element: null
      };
      var h = r.value;
      return c.callback = function() {
        nP(h), hw(e, r);
      }, c;
    }
    function mw(e, r, s) {
      var c = Qs(Dn, s);
      c.tag = hx;
      var h = e.type.getDerivedStateFromError;
      if (typeof h == "function") {
        var y = r.value;
        c.payload = function() {
          return h(y);
        }, c.callback = function() {
          M2(e), hw(e, r);
        };
      }
      var x = e.stateNode;
      return x !== null && typeof x.componentDidCatch == "function" && (c.callback = function() {
        M2(e), hw(e, r), typeof h != "function" && eP(this);
        var T = r.value, M = r.stack;
        this.componentDidCatch(T, {
          componentStack: M !== null ? M : ""
        }), typeof h != "function" && (Ii(e.lanes, bt) || p("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", kt(e) || "Unknown"));
      }), c;
    }
    function wT(e, r, s) {
      var c = e.pingCache, h;
      if (c === null ? (c = e.pingCache = new cL(), h = /* @__PURE__ */ new Set(), c.set(r, h)) : (h = c.get(r), h === void 0 && (h = /* @__PURE__ */ new Set(), c.set(r, h))), !h.has(s)) {
        h.add(s);
        var y = rP.bind(null, e, r, s);
        Br && Sv(e, s), r.then(y, y);
      }
    }
    function fL(e, r, s, c) {
      var h = e.updateQueue;
      if (h === null) {
        var y = /* @__PURE__ */ new Set();
        y.add(s), e.updateQueue = y;
      } else
        h.add(s);
    }
    function dL(e, r) {
      var s = e.tag;
      if ((e.mode & Bt) === ht && (s === b || s === G || s === ue)) {
        var c = e.alternate;
        c ? (e.updateQueue = c.updateQueue, e.memoizedState = c.memoizedState, e.lanes = c.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function _T(e) {
      var r = e;
      do {
        if (r.tag === ee && XN(r))
          return r;
        r = r.return;
      } while (r !== null);
      return null;
    }
    function ET(e, r, s, c, h) {
      if ((e.mode & Bt) === ht) {
        if (e === r)
          e.flags |= Dr;
        else {
          if (e.flags |= _t, s.flags |= Jc, s.flags &= ~(hd | Ji), s.tag === S) {
            var y = s.alternate;
            if (y === null)
              s.tag = me;
            else {
              var x = Qs(Dn, bt);
              x.tag = o0, cc(s, x, bt);
            }
          }
          s.lanes = zt(s.lanes, bt);
        }
        return e;
      }
      return e.flags |= Dr, e.lanes = h, e;
    }
    function pL(e, r, s, c, h) {
      if (s.flags |= Ji, Br && Sv(e, h), c !== null && typeof c == "object" && typeof c.then == "function") {
        var y = c;
        dL(s), gi() && s.mode & Bt && hk();
        var x = _T(r);
        if (x !== null) {
          x.flags &= ~ir, ET(x, r, s, e, h), x.mode & Bt && wT(e, y, h), fL(x, e, y);
          return;
        } else {
          if (!Bu(h)) {
            wT(e, y, h), qw();
            return;
          }
          var C = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          c = C;
        }
      } else if (gi() && s.mode & Bt) {
        hk();
        var T = _T(r);
        if (T !== null) {
          (T.flags & Dr) === ct && (T.flags |= ir), ET(T, r, s, e, h), lx(Mf(c, s));
          return;
        }
      }
      c = Mf(c, s), Y6(c);
      var M = r;
      do {
        switch (M.tag) {
          case w: {
            var P = c;
            M.flags |= Dr;
            var Z = wr(h);
            M.lanes = zt(M.lanes, Z);
            var W = xT(M, P, Z);
            yx(M, W);
            return;
          }
          case S:
            var ne = c, ie = M.type, fe = M.stateNode;
            if ((M.flags & _t) === ct && (typeof ie.getDerivedStateFromError == "function" || fe !== null && typeof fe.componentDidCatch == "function" && !_2(fe))) {
              M.flags |= Dr;
              var Ze = wr(h);
              M.lanes = zt(M.lanes, Ze);
              var dt = mw(M, ne, Ze);
              yx(M, dt);
              return;
            }
            break;
        }
        M = M.return;
      } while (M !== null);
    }
    function hL() {
      return null;
    }
    var av = i.ReactCurrentOwner, el = !1, vw, ov, yw, gw, bw, Nf, Sw, $0;
    vw = {}, ov = {}, yw = {}, gw = {}, bw = {}, Nf = !1, Sw = {}, $0 = {};
    function aa(e, r, s, c) {
      e === null ? r.child = Bk(r, null, s, c) : r.child = wp(r, e.child, s, c);
    }
    function mL(e, r, s, c) {
      r.child = wp(r, e.child, null, c), r.child = wp(r, null, s, c);
    }
    function CT(e, r, s, c, h) {
      if (r.type !== r.elementType) {
        var y = s.propTypes;
        y && qo(
          y,
          c,
          // Resolved props
          "prop",
          on(s)
        );
      }
      var x = s.render, C = r.ref, T, M;
      xp(r, h), jl(r);
      {
        if (av.current = r, Ai(!0), T = Rp(e, r, x, c, C, h), M = Op(), r.mode & Xn) {
          xr(!0);
          try {
            T = Rp(e, r, x, c, C, h), M = Op();
          } finally {
            xr(!1);
          }
        }
        Ai(!1);
      }
      return ks(), e !== null && !el ? (Zk(e, r, h), Ks(e, r, h)) : (gi() && M && tx(r), r.flags |= Dl, aa(e, r, T, h), r.child);
    }
    function kT(e, r, s, c, h) {
      if (e === null) {
        var y = s.type;
        if (SP(y) && s.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        s.defaultProps === void 0) {
          var x = y;
          return x = $p(y), r.tag = ue, r.type = x, _w(r, y), TT(e, r, x, c, h);
        }
        {
          var C = y.propTypes;
          C && qo(
            C,
            c,
            // Resolved props
            "prop",
            on(y)
          );
        }
        var T = a_(s.type, null, c, r, r.mode, h);
        return T.ref = r.ref, T.return = r, r.child = T, T;
      }
      {
        var M = s.type, P = M.propTypes;
        P && qo(
          P,
          c,
          // Resolved props
          "prop",
          on(M)
        );
      }
      var Z = e.child, W = Ow(e, h);
      if (!W) {
        var ne = Z.memoizedProps, ie = s.compare;
        if (ie = ie !== null ? ie : ut, ie(ne, c) && e.ref === r.ref)
          return Ks(e, r, h);
      }
      r.flags |= Dl;
      var fe = jf(Z, c);
      return fe.ref = r.ref, fe.return = r, r.child = fe, fe;
    }
    function TT(e, r, s, c, h) {
      if (r.type !== r.elementType) {
        var y = r.elementType;
        if (y.$$typeof === ft) {
          var x = y, C = x._payload, T = x._init;
          try {
            y = T(C);
          } catch {
            y = null;
          }
          var M = y && y.propTypes;
          M && qo(
            M,
            c,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            on(y)
          );
        }
      }
      if (e !== null) {
        var P = e.memoizedProps;
        if (ut(P, c) && e.ref === r.ref && // Prevent bailout if the implementation changed due to hot reload.
        r.type === e.type)
          if (el = !1, r.pendingProps = c = P, Ow(e, h))
            (e.flags & Jc) !== ct && (el = !0);
          else
            return r.lanes = e.lanes, Ks(e, r, h);
      }
      return xw(e, r, s, c, h);
    }
    function RT(e, r, s) {
      var c = r.pendingProps, h = c.children, y = e !== null ? e.memoizedState : null;
      if (c.mode === "hidden" || O)
        if ((r.mode & Bt) === ht) {
          var x = {
            baseLanes: pe,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = x, X0(r, s);
        } else if (Ii(s, ji)) {
          var Z = {
            baseLanes: pe,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = Z;
          var W = y !== null ? y.baseLanes : s;
          X0(r, W);
        } else {
          var C = null, T;
          if (y !== null) {
            var M = y.baseLanes;
            T = zt(M, s);
          } else
            T = s;
          r.lanes = r.childLanes = ji;
          var P = {
            baseLanes: T,
            cachePool: C,
            transitions: null
          };
          return r.memoizedState = P, r.updateQueue = null, X0(r, T), null;
        }
      else {
        var ne;
        y !== null ? (ne = zt(y.baseLanes, s), r.memoizedState = null) : ne = s, X0(r, ne);
      }
      return aa(e, r, h, s), r.child;
    }
    function vL(e, r, s) {
      var c = r.pendingProps;
      return aa(e, r, c, s), r.child;
    }
    function yL(e, r, s) {
      var c = r.pendingProps.children;
      return aa(e, r, c, s), r.child;
    }
    function gL(e, r, s) {
      {
        r.flags |= Pt;
        {
          var c = r.stateNode;
          c.effectDuration = 0, c.passiveEffectDuration = 0;
        }
      }
      var h = r.pendingProps, y = h.children;
      return aa(e, r, y, s), r.child;
    }
    function OT(e, r) {
      var s = r.ref;
      (e === null && s !== null || e !== null && e.ref !== s) && (r.flags |= Mi, r.flags |= Bh);
    }
    function xw(e, r, s, c, h) {
      if (r.type !== r.elementType) {
        var y = s.propTypes;
        y && qo(
          y,
          c,
          // Resolved props
          "prop",
          on(s)
        );
      }
      var x;
      {
        var C = mp(r, s, !0);
        x = vp(r, C);
      }
      var T, M;
      xp(r, h), jl(r);
      {
        if (av.current = r, Ai(!0), T = Rp(e, r, s, c, x, h), M = Op(), r.mode & Xn) {
          xr(!0);
          try {
            T = Rp(e, r, s, c, x, h), M = Op();
          } finally {
            xr(!1);
          }
        }
        Ai(!1);
      }
      return ks(), e !== null && !el ? (Zk(e, r, h), Ks(e, r, h)) : (gi() && M && tx(r), r.flags |= Dl, aa(e, r, T, h), r.child);
    }
    function AT(e, r, s, c, h) {
      {
        switch (PP(r)) {
          case !1: {
            var y = r.stateNode, x = r.type, C = new x(r.memoizedProps, y.context), T = C.state;
            y.updater.enqueueSetState(y, T, null);
            break;
          }
          case !0: {
            r.flags |= _t, r.flags |= Dr;
            var M = new Error("Simulated error coming from DevTools"), P = wr(h);
            r.lanes = zt(r.lanes, P);
            var Z = mw(r, Mf(M, r), P);
            yx(r, Z);
            break;
          }
        }
        if (r.type !== r.elementType) {
          var W = s.propTypes;
          W && qo(
            W,
            c,
            // Resolved props
            "prop",
            on(s)
          );
        }
      }
      var ne;
      Gl(s) ? (ne = !0, Gg(r)) : ne = !1, xp(r, h);
      var ie = r.stateNode, fe;
      ie === null ? (I0(e, r), $k(r, s, c), Ox(r, s, c, h), fe = !0) : e === null ? fe = VN(r, s, c, h) : fe = WN(e, r, s, c, h);
      var Ze = ww(e, r, s, fe, ne, h);
      {
        var dt = r.stateNode;
        fe && dt.props !== c && (Nf || p("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", kt(r) || "a component"), Nf = !0);
      }
      return Ze;
    }
    function ww(e, r, s, c, h, y) {
      OT(e, r);
      var x = (r.flags & _t) !== ct;
      if (!c && !x)
        return h && ck(r, s, !1), Ks(e, r, y);
      var C = r.stateNode;
      av.current = r;
      var T;
      if (x && typeof s.getDerivedStateFromError != "function")
        T = null, ST();
      else {
        jl(r);
        {
          if (Ai(!0), T = C.render(), r.mode & Xn) {
            xr(!0);
            try {
              C.render();
            } finally {
              xr(!1);
            }
          }
          Ai(!1);
        }
        ks();
      }
      return r.flags |= Dl, e !== null && x ? mL(e, r, T, y) : aa(e, r, T, y), r.memoizedState = C.state, h && ck(r, s, !0), r.child;
    }
    function DT(e) {
      var r = e.stateNode;
      r.pendingContext ? sk(e, r.pendingContext, r.pendingContext !== r.context) : r.context && sk(e, r.context, !1), Px(e, r.containerInfo);
    }
    function bL(e, r, s) {
      if (DT(r), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var c = r.pendingProps, h = r.memoizedState, y = h.element;
      Ok(e, r), c0(r, c, null, s);
      var x = r.memoizedState;
      r.stateNode;
      var C = x.element;
      if (h.isDehydrated) {
        var T = {
          element: C,
          isDehydrated: !1,
          cache: x.cache,
          pendingSuspenseBoundaries: x.pendingSuspenseBoundaries,
          transitions: x.transitions
        }, M = r.updateQueue;
        if (M.baseState = T, r.memoizedState = T, r.flags & ir) {
          var P = Mf(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), r);
          return MT(e, r, C, s, P);
        } else if (C !== y) {
          var Z = Mf(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), r);
          return MT(e, r, C, s, Z);
        } else {
          _N(r);
          var W = Bk(r, null, C, s);
          r.child = W;
          for (var ne = W; ne; )
            ne.flags = ne.flags & ~jn | ba, ne = ne.sibling;
        }
      } else {
        if (bp(), C === y)
          return Ks(e, r, s);
        aa(e, r, C, s);
      }
      return r.child;
    }
    function MT(e, r, s, c, h) {
      return bp(), lx(h), r.flags |= ir, aa(e, r, s, c), r.child;
    }
    function SL(e, r, s) {
      Vk(r), e === null && ox(r);
      var c = r.type, h = r.pendingProps, y = e !== null ? e.memoizedProps : null, x = h.children, C = U1(c, h);
      return C ? x = null : y !== null && U1(c, y) && (r.flags |= gn), OT(e, r), aa(e, r, x, s), r.child;
    }
    function xL(e, r) {
      return e === null && ox(r), null;
    }
    function wL(e, r, s, c) {
      I0(e, r);
      var h = r.pendingProps, y = s, x = y._payload, C = y._init, T = C(x);
      r.type = T;
      var M = r.tag = xP(T), P = Qo(T, h), Z;
      switch (M) {
        case b:
          return _w(r, T), r.type = T = $p(T), Z = xw(null, r, T, P, c), Z;
        case S:
          return r.type = T = Jw(T), Z = AT(null, r, T, P, c), Z;
        case G:
          return r.type = T = e_(T), Z = CT(null, r, T, P, c), Z;
        case V: {
          if (r.type !== r.elementType) {
            var W = T.propTypes;
            W && qo(
              W,
              P,
              // Resolved for outer only
              "prop",
              on(T)
            );
          }
          return Z = kT(
            null,
            r,
            T,
            Qo(T.type, P),
            // The inner type can have defaults too
            c
          ), Z;
        }
      }
      var ne = "";
      throw T !== null && typeof T == "object" && T.$$typeof === ft && (ne = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + T + ". " + ("Lazy element type must resolve to a class or function." + ne));
    }
    function _L(e, r, s, c, h) {
      I0(e, r), r.tag = S;
      var y;
      return Gl(s) ? (y = !0, Gg(r)) : y = !1, xp(r, h), $k(r, s, c), Ox(r, s, c, h), ww(null, r, s, !0, y, h);
    }
    function EL(e, r, s, c) {
      I0(e, r);
      var h = r.pendingProps, y;
      {
        var x = mp(r, s, !1);
        y = vp(r, x);
      }
      xp(r, c);
      var C, T;
      jl(r);
      {
        if (s.prototype && typeof s.prototype.render == "function") {
          var M = on(s) || "Unknown";
          vw[M] || (p("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", M, M), vw[M] = !0);
        }
        r.mode & Xn && Xo.recordLegacyContextWarning(r, null), Ai(!0), av.current = r, C = Rp(null, r, s, h, y, c), T = Op(), Ai(!1);
      }
      if (ks(), r.flags |= Dl, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0) {
        var P = on(s) || "Unknown";
        ov[P] || (p("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", P, P, P), ov[P] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0
      ) {
        {
          var Z = on(s) || "Unknown";
          ov[Z] || (p("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Z, Z, Z), ov[Z] = !0);
        }
        r.tag = S, r.memoizedState = null, r.updateQueue = null;
        var W = !1;
        return Gl(s) ? (W = !0, Gg(r)) : W = !1, r.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, vx(r), zk(r, C), Ox(r, s, h, c), ww(null, r, s, !0, W, c);
      } else {
        if (r.tag = b, r.mode & Xn) {
          xr(!0);
          try {
            C = Rp(null, r, s, h, y, c), T = Op();
          } finally {
            xr(!1);
          }
        }
        return gi() && T && tx(r), aa(null, r, C, c), _w(r, s), r.child;
      }
    }
    function _w(e, r) {
      {
        if (r && r.childContextTypes && p("%s(...): childContextTypes cannot be defined on a function component.", r.displayName || r.name || "Component"), e.ref !== null) {
          var s = "", c = mi();
          c && (s += `

Check the render method of \`` + c + "`.");
          var h = c || "", y = e._debugSource;
          y && (h = y.fileName + ":" + y.lineNumber), bw[h] || (bw[h] = !0, p("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", s));
        }
        if (typeof r.getDerivedStateFromProps == "function") {
          var x = on(r) || "Unknown";
          gw[x] || (p("%s: Function components do not support getDerivedStateFromProps.", x), gw[x] = !0);
        }
        if (typeof r.contextType == "object" && r.contextType !== null) {
          var C = on(r) || "Unknown";
          yw[C] || (p("%s: Function components do not support contextType.", C), yw[C] = !0);
        }
      }
    }
    var Ew = {
      dehydrated: null,
      treeContext: null,
      retryLane: Jt
    };
    function Cw(e) {
      return {
        baseLanes: e,
        cachePool: hL(),
        transitions: null
      };
    }
    function CL(e, r) {
      var s = null;
      return {
        baseLanes: zt(e.baseLanes, r),
        cachePool: s,
        transitions: e.transitions
      };
    }
    function kL(e, r, s, c) {
      if (r !== null) {
        var h = r.memoizedState;
        if (h === null)
          return !1;
      }
      return jx(e, Qm);
    }
    function TL(e, r) {
      return Hu(e.childLanes, r);
    }
    function NT(e, r, s) {
      var c = r.pendingProps;
      zP(r) && (r.flags |= _t);
      var h = Ko.current, y = !1, x = (r.flags & _t) !== ct;
      if (x || kL(h, e) ? (y = !0, r.flags &= ~_t) : (e === null || e.memoizedState !== null) && (h = GN(h, Yk)), h = Ep(h), dc(r, h), e === null) {
        ox(r);
        var C = r.memoizedState;
        if (C !== null) {
          var T = C.dehydrated;
          if (T !== null)
            return ML(r, T);
        }
        var M = c.children, P = c.fallback;
        if (y) {
          var Z = RL(r, M, P, s), W = r.child;
          return W.memoizedState = Cw(s), r.memoizedState = Ew, Z;
        } else
          return kw(r, M);
      } else {
        var ne = e.memoizedState;
        if (ne !== null) {
          var ie = ne.dehydrated;
          if (ie !== null)
            return NL(e, r, x, c, ie, ne, s);
        }
        if (y) {
          var fe = c.fallback, Ze = c.children, dt = AL(e, r, Ze, fe, s), st = r.child, tn = e.child.memoizedState;
          return st.memoizedState = tn === null ? Cw(s) : CL(tn, s), st.childLanes = TL(e, s), r.memoizedState = Ew, dt;
        } else {
          var Xt = c.children, Q = OL(e, r, Xt, s);
          return r.memoizedState = null, Q;
        }
      }
    }
    function kw(e, r, s) {
      var c = e.mode, h = {
        mode: "visible",
        children: r
      }, y = Tw(h, c);
      return y.return = e, e.child = y, y;
    }
    function RL(e, r, s, c) {
      var h = e.mode, y = e.child, x = {
        mode: "hidden",
        children: r
      }, C, T;
      return (h & Bt) === ht && y !== null ? (C = y, C.childLanes = pe, C.pendingProps = x, e.mode & vt && (C.actualDuration = 0, C.actualStartTime = -1, C.selfBaseDuration = 0, C.treeBaseDuration = 0), T = Sc(s, h, c, null)) : (C = Tw(x, h), T = Sc(s, h, c, null)), C.return = e, T.return = e, C.sibling = T, e.child = C, T;
    }
    function Tw(e, r, s) {
      return L2(e, r, pe, null);
    }
    function LT(e, r) {
      return jf(e, r);
    }
    function OL(e, r, s, c) {
      var h = e.child, y = h.sibling, x = LT(h, {
        mode: "visible",
        children: s
      });
      if ((r.mode & Bt) === ht && (x.lanes = c), x.return = r, x.sibling = null, y !== null) {
        var C = r.deletions;
        C === null ? (r.deletions = [y], r.flags |= hn) : C.push(y);
      }
      return r.child = x, x;
    }
    function AL(e, r, s, c, h) {
      var y = r.mode, x = e.child, C = x.sibling, T = {
        mode: "hidden",
        children: s
      }, M;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (y & Bt) === ht && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        r.child !== x
      ) {
        var P = r.child;
        M = P, M.childLanes = pe, M.pendingProps = T, r.mode & vt && (M.actualDuration = 0, M.actualStartTime = -1, M.selfBaseDuration = x.selfBaseDuration, M.treeBaseDuration = x.treeBaseDuration), r.deletions = null;
      } else
        M = LT(x, T), M.subtreeFlags = x.subtreeFlags & Ur;
      var Z;
      return C !== null ? Z = jf(C, c) : (Z = Sc(c, y, h, null), Z.flags |= jn), Z.return = r, M.return = r, M.sibling = Z, r.child = M, Z;
    }
    function j0(e, r, s, c) {
      c !== null && lx(c), wp(r, e.child, null, s);
      var h = r.pendingProps, y = h.children, x = kw(r, y);
      return x.flags |= jn, r.memoizedState = null, x;
    }
    function DL(e, r, s, c, h) {
      var y = r.mode, x = {
        mode: "visible",
        children: s
      }, C = Tw(x, y), T = Sc(c, y, h, null);
      return T.flags |= jn, C.return = r, T.return = r, C.sibling = T, r.child = C, (r.mode & Bt) !== ht && wp(r, e.child, null, h), T;
    }
    function ML(e, r, s) {
      return (e.mode & Bt) === ht ? (p("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = bt) : W1(r) ? e.lanes = Os : e.lanes = ji, null;
    }
    function NL(e, r, s, c, h, y, x) {
      if (s)
        if (r.flags & ir) {
          r.flags &= ~ir;
          var Q = pw(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return j0(e, r, x, Q);
        } else {
          if (r.memoizedState !== null)
            return r.child = e.child, r.flags |= _t, null;
          var de = c.children, K = c.fallback, Ee = DL(e, r, de, K, x), qe = r.child;
          return qe.memoizedState = Cw(x), r.memoizedState = Ew, Ee;
        }
      else {
        if (xN(), (r.mode & Bt) === ht)
          return j0(
            e,
            r,
            x,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (W1(h)) {
          var C, T, M;
          {
            var P = jM(h);
            C = P.digest, T = P.message, M = P.stack;
          }
          var Z;
          T ? Z = new Error(T) : Z = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var W = pw(Z, C, M);
          return j0(e, r, x, W);
        }
        var ne = Ii(x, e.childLanes);
        if (el || ne) {
          var ie = G0();
          if (ie !== null) {
            var fe = d1(ie, x);
            if (fe !== Jt && fe !== y.retryLane) {
              y.retryLane = fe;
              var Ze = Dn;
              Oa(e, fe), Qr(ie, e, fe, Ze);
            }
          }
          qw();
          var dt = pw(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return j0(e, r, x, dt);
        } else if (nk(h)) {
          r.flags |= _t, r.child = e.child;
          var st = iP.bind(null, e);
          return IM(h, st), null;
        } else {
          EN(r, h, y.treeContext);
          var tn = c.children, Xt = kw(r, tn);
          return Xt.flags |= ba, Xt;
        }
      }
    }
    function PT(e, r, s) {
      e.lanes = zt(e.lanes, r);
      var c = e.alternate;
      c !== null && (c.lanes = zt(c.lanes, r)), dx(e.return, r, s);
    }
    function LL(e, r, s) {
      for (var c = r; c !== null; ) {
        if (c.tag === ee) {
          var h = c.memoizedState;
          h !== null && PT(c, s, e);
        } else if (c.tag === xe)
          PT(c, s, e);
        else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === e)
          return;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === e)
            return;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    }
    function PL(e) {
      for (var r = e, s = null; r !== null; ) {
        var c = r.alternate;
        c !== null && y0(c) === null && (s = r), r = r.sibling;
      }
      return s;
    }
    function zL(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !Sw[e])
        if (Sw[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              p('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              p('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              p('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          p('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function $L(e, r) {
      e !== void 0 && !$0[e] && (e !== "collapsed" && e !== "hidden" ? ($0[e] = !0, p('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : r !== "forwards" && r !== "backwards" && ($0[e] = !0, p('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function zT(e, r) {
      {
        var s = Qt(e), c = !s && typeof Ia(e) == "function";
        if (s || c) {
          var h = s ? "array" : "iterable";
          return p("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", h, r, h), !1;
        }
      }
      return !0;
    }
    function jL(e, r) {
      if ((r === "forwards" || r === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (Qt(e)) {
          for (var s = 0; s < e.length; s++)
            if (!zT(e[s], s))
              return;
        } else {
          var c = Ia(e);
          if (typeof c == "function") {
            var h = c.call(e);
            if (h)
              for (var y = h.next(), x = 0; !y.done; y = h.next()) {
                if (!zT(y.value, x))
                  return;
                x++;
              }
          } else
            p('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', r);
        }
    }
    function Rw(e, r, s, c, h) {
      var y = e.memoizedState;
      y === null ? e.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: c,
        tail: s,
        tailMode: h
      } : (y.isBackwards = r, y.rendering = null, y.renderingStartTime = 0, y.last = c, y.tail = s, y.tailMode = h);
    }
    function $T(e, r, s) {
      var c = r.pendingProps, h = c.revealOrder, y = c.tail, x = c.children;
      zL(h), $L(y, h), jL(x, h), aa(e, r, x, s);
      var C = Ko.current, T = jx(C, Qm);
      if (T)
        C = Ix(C, Qm), r.flags |= _t;
      else {
        var M = e !== null && (e.flags & _t) !== ct;
        M && LL(r, r.child, s), C = Ep(C);
      }
      if (dc(r, C), (r.mode & Bt) === ht)
        r.memoizedState = null;
      else
        switch (h) {
          case "forwards": {
            var P = PL(r.child), Z;
            P === null ? (Z = r.child, r.child = null) : (Z = P.sibling, P.sibling = null), Rw(
              r,
              !1,
              // isBackwards
              Z,
              P,
              y
            );
            break;
          }
          case "backwards": {
            var W = null, ne = r.child;
            for (r.child = null; ne !== null; ) {
              var ie = ne.alternate;
              if (ie !== null && y0(ie) === null) {
                r.child = ne;
                break;
              }
              var fe = ne.sibling;
              ne.sibling = W, W = ne, ne = fe;
            }
            Rw(
              r,
              !0,
              // isBackwards
              W,
              null,
              // last
              y
            );
            break;
          }
          case "together": {
            Rw(
              r,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            r.memoizedState = null;
        }
      return r.child;
    }
    function IL(e, r, s) {
      Px(r, r.stateNode.containerInfo);
      var c = r.pendingProps;
      return e === null ? r.child = wp(r, null, c, s) : aa(e, r, c, s), r.child;
    }
    var jT = !1;
    function FL(e, r, s) {
      var c = r.type, h = c._context, y = r.pendingProps, x = r.memoizedProps, C = y.value;
      {
        "value" in y || jT || (jT = !0, p("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var T = r.type.propTypes;
        T && qo(T, y, "prop", "Context.Provider");
      }
      if (Ck(r, h, C), x !== null) {
        var M = x.value;
        if (tt(M, C)) {
          if (x.children === y.children && !Zg())
            return Ks(e, r, s);
        } else
          LN(r, h, s);
      }
      var P = y.children;
      return aa(e, r, P, s), r.child;
    }
    var IT = !1;
    function UL(e, r, s) {
      var c = r.type;
      c._context === void 0 ? c !== c.Consumer && (IT || (IT = !0, p("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : c = c._context;
      var h = r.pendingProps, y = h.children;
      typeof y != "function" && p("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), xp(r, s);
      var x = zr(c);
      jl(r);
      var C;
      return av.current = r, Ai(!0), C = y(x), Ai(!1), ks(), r.flags |= Dl, aa(e, r, C, s), r.child;
    }
    function lv() {
      el = !0;
    }
    function I0(e, r) {
      (r.mode & Bt) === ht && e !== null && (e.alternate = null, r.alternate = null, r.flags |= jn);
    }
    function Ks(e, r, s) {
      return e !== null && (r.dependencies = e.dependencies), ST(), bv(r.lanes), Ii(s, r.childLanes) ? (YN(e, r), r.child) : null;
    }
    function BL(e, r, s) {
      {
        var c = r.return;
        if (c === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, r.alternate = null, s.index = r.index, s.sibling = r.sibling, s.return = r.return, s.ref = r.ref, r === c.child)
          c.child = s;
        else {
          var h = c.child;
          if (h === null)
            throw new Error("Expected parent to have a child.");
          for (; h.sibling !== r; )
            if (h = h.sibling, h === null)
              throw new Error("Expected to find the previous sibling.");
          h.sibling = s;
        }
        var y = c.deletions;
        return y === null ? (c.deletions = [e], c.flags |= hn) : y.push(e), s.flags |= jn, s;
      }
    }
    function Ow(e, r) {
      var s = e.lanes;
      return !!Ii(s, r);
    }
    function HL(e, r, s) {
      switch (r.tag) {
        case w:
          DT(r), r.stateNode, bp();
          break;
        case k:
          Vk(r);
          break;
        case S: {
          var c = r.type;
          Gl(c) && Gg(r);
          break;
        }
        case R:
          Px(r, r.stateNode.containerInfo);
          break;
        case q: {
          var h = r.memoizedProps.value, y = r.type._context;
          Ck(r, y, h);
          break;
        }
        case te:
          {
            var x = Ii(s, r.childLanes);
            x && (r.flags |= Pt);
            {
              var C = r.stateNode;
              C.effectDuration = 0, C.passiveEffectDuration = 0;
            }
          }
          break;
        case ee: {
          var T = r.memoizedState;
          if (T !== null) {
            if (T.dehydrated !== null)
              return dc(r, Ep(Ko.current)), r.flags |= _t, null;
            var M = r.child, P = M.childLanes;
            if (Ii(s, P))
              return NT(e, r, s);
            dc(r, Ep(Ko.current));
            var Z = Ks(e, r, s);
            return Z !== null ? Z.sibling : null;
          } else
            dc(r, Ep(Ko.current));
          break;
        }
        case xe: {
          var W = (e.flags & _t) !== ct, ne = Ii(s, r.childLanes);
          if (W) {
            if (ne)
              return $T(e, r, s);
            r.flags |= _t;
          }
          var ie = r.memoizedState;
          if (ie !== null && (ie.rendering = null, ie.tail = null, ie.lastEffect = null), dc(r, Ko.current), ne)
            break;
          return null;
        }
        case Pe:
        case Ue:
          return r.lanes = pe, RT(e, r, s);
      }
      return Ks(e, r, s);
    }
    function FT(e, r, s) {
      if (r._debugNeedsRemount && e !== null)
        return BL(e, r, a_(r.type, r.key, r.pendingProps, r._debugOwner || null, r.mode, r.lanes));
      if (e !== null) {
        var c = e.memoizedProps, h = r.pendingProps;
        if (c !== h || Zg() || // Force a re-render if the implementation changed due to hot reload:
        r.type !== e.type)
          el = !0;
        else {
          var y = Ow(e, s);
          if (!y && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (r.flags & _t) === ct)
            return el = !1, HL(e, r, s);
          (e.flags & Jc) !== ct ? el = !0 : el = !1;
        }
      } else if (el = !1, gi() && mN(r)) {
        var x = r.index, C = vN();
        pk(r, C, x);
      }
      switch (r.lanes = pe, r.tag) {
        case E:
          return EL(e, r, r.type, s);
        case we: {
          var T = r.elementType;
          return wL(e, r, T, s);
        }
        case b: {
          var M = r.type, P = r.pendingProps, Z = r.elementType === M ? P : Qo(M, P);
          return xw(e, r, M, Z, s);
        }
        case S: {
          var W = r.type, ne = r.pendingProps, ie = r.elementType === W ? ne : Qo(W, ne);
          return AT(e, r, W, ie, s);
        }
        case w:
          return bL(e, r, s);
        case k:
          return SL(e, r, s);
        case N:
          return xL(e, r);
        case ee:
          return NT(e, r, s);
        case R:
          return IL(e, r, s);
        case G: {
          var fe = r.type, Ze = r.pendingProps, dt = r.elementType === fe ? Ze : Qo(fe, Ze);
          return CT(e, r, fe, dt, s);
        }
        case z:
          return vL(e, r, s);
        case I:
          return yL(e, r, s);
        case te:
          return gL(e, r, s);
        case q:
          return FL(e, r, s);
        case H:
          return UL(e, r, s);
        case V: {
          var st = r.type, tn = r.pendingProps, Xt = Qo(st, tn);
          if (r.type !== r.elementType) {
            var Q = st.propTypes;
            Q && qo(
              Q,
              Xt,
              // Resolved for outer only
              "prop",
              on(st)
            );
          }
          return Xt = Qo(st.type, Xt), kT(e, r, st, Xt, s);
        }
        case ue:
          return TT(e, r, r.type, r.pendingProps, s);
        case me: {
          var de = r.type, K = r.pendingProps, Ee = r.elementType === de ? K : Qo(de, K);
          return _L(e, r, de, Ee, s);
        }
        case xe:
          return $T(e, r, s);
        case ve:
          break;
        case Pe:
          return RT(e, r, s);
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ap(e) {
      e.flags |= Pt;
    }
    function UT(e) {
      e.flags |= Mi, e.flags |= Bh;
    }
    var BT, Aw, HT, VT;
    BT = function(e, r, s, c) {
      for (var h = r.child; h !== null; ) {
        if (h.tag === k || h.tag === N)
          dM(e, h.stateNode);
        else if (h.tag !== R) {
          if (h.child !== null) {
            h.child.return = h, h = h.child;
            continue;
          }
        }
        if (h === r)
          return;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === r)
            return;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }, Aw = function(e, r) {
    }, HT = function(e, r, s, c, h) {
      var y = e.memoizedProps;
      if (y !== c) {
        var x = r.stateNode, C = zx(), T = hM(x, s, y, c, h, C);
        r.updateQueue = T, T && Ap(r);
      }
    }, VT = function(e, r, s, c) {
      s !== c && Ap(r);
    };
    function sv(e, r) {
      if (!gi())
        switch (e.tailMode) {
          case "hidden": {
            for (var s = e.tail, c = null; s !== null; )
              s.alternate !== null && (c = s), s = s.sibling;
            c === null ? e.tail = null : c.sibling = null;
            break;
          }
          case "collapsed": {
            for (var h = e.tail, y = null; h !== null; )
              h.alternate !== null && (y = h), h = h.sibling;
            y === null ? !r && e.tail !== null ? e.tail.sibling = null : e.tail = null : y.sibling = null;
            break;
          }
        }
    }
    function Si(e) {
      var r = e.alternate !== null && e.alternate.child === e.child, s = pe, c = ct;
      if (r) {
        if ((e.mode & vt) !== ht) {
          for (var T = e.selfBaseDuration, M = e.child; M !== null; )
            s = zt(s, zt(M.lanes, M.childLanes)), c |= M.subtreeFlags & Ur, c |= M.flags & Ur, T += M.treeBaseDuration, M = M.sibling;
          e.treeBaseDuration = T;
        } else
          for (var P = e.child; P !== null; )
            s = zt(s, zt(P.lanes, P.childLanes)), c |= P.subtreeFlags & Ur, c |= P.flags & Ur, P.return = e, P = P.sibling;
        e.subtreeFlags |= c;
      } else {
        if ((e.mode & vt) !== ht) {
          for (var h = e.actualDuration, y = e.selfBaseDuration, x = e.child; x !== null; )
            s = zt(s, zt(x.lanes, x.childLanes)), c |= x.subtreeFlags, c |= x.flags, h += x.actualDuration, y += x.treeBaseDuration, x = x.sibling;
          e.actualDuration = h, e.treeBaseDuration = y;
        } else
          for (var C = e.child; C !== null; )
            s = zt(s, zt(C.lanes, C.childLanes)), c |= C.subtreeFlags, c |= C.flags, C.return = e, C = C.sibling;
        e.subtreeFlags |= c;
      }
      return e.childLanes = s, r;
    }
    function VL(e, r, s) {
      if (ON() && (r.mode & Bt) !== ht && (r.flags & _t) === ct)
        return Sk(r), bp(), r.flags |= ir | Ji | Dr, !1;
      var c = e0(r);
      if (s !== null && s.dehydrated !== null)
        if (e === null) {
          if (!c)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (TN(r), Si(r), (r.mode & vt) !== ht) {
            var h = s !== null;
            if (h) {
              var y = r.child;
              y !== null && (r.treeBaseDuration -= y.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (bp(), (r.flags & _t) === ct && (r.memoizedState = null), r.flags |= Pt, Si(r), (r.mode & vt) !== ht) {
            var x = s !== null;
            if (x) {
              var C = r.child;
              C !== null && (r.treeBaseDuration -= C.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return xk(), !0;
    }
    function WT(e, r, s) {
      var c = r.pendingProps;
      switch (nx(r), r.tag) {
        case E:
        case we:
        case ue:
        case b:
        case G:
        case z:
        case I:
        case te:
        case H:
        case V:
          return Si(r), null;
        case S: {
          var h = r.type;
          return Gl(h) && qg(r), Si(r), null;
        }
        case w: {
          var y = r.stateNode;
          if (_p(r), K1(r), Ux(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), e === null || e.child === null) {
            var x = e0(r);
            if (x)
              Ap(r);
            else if (e !== null) {
              var C = e.memoizedState;
              // Check if this is a client root
              (!C.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (r.flags & ir) !== ct) && (r.flags |= ga, xk());
            }
          }
          return Aw(e, r), Si(r), null;
        }
        case k: {
          $x(r);
          var T = Hk(), M = r.type;
          if (e !== null && r.stateNode != null)
            HT(e, r, M, c, T), e.ref !== r.ref && UT(r);
          else {
            if (!c) {
              if (r.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Si(r), null;
            }
            var P = zx(), Z = e0(r);
            if (Z)
              CN(r, T, P) && Ap(r);
            else {
              var W = fM(M, c, T, P, r);
              BT(W, r, !1, !1), r.stateNode = W, pM(W, M, c, T) && Ap(r);
            }
            r.ref !== null && UT(r);
          }
          return Si(r), null;
        }
        case N: {
          var ne = c;
          if (e && r.stateNode != null) {
            var ie = e.memoizedProps;
            VT(e, r, ie, ne);
          } else {
            if (typeof ne != "string" && r.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var fe = Hk(), Ze = zx(), dt = e0(r);
            dt ? kN(r) && Ap(r) : r.stateNode = mM(ne, fe, Ze, r);
          }
          return Si(r), null;
        }
        case ee: {
          Cp(r);
          var st = r.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var tn = VL(e, r, st);
            if (!tn)
              return r.flags & Dr ? r : null;
          }
          if ((r.flags & _t) !== ct)
            return r.lanes = s, (r.mode & vt) !== ht && dw(r), r;
          var Xt = st !== null, Q = e !== null && e.memoizedState !== null;
          if (Xt !== Q && Xt) {
            var de = r.child;
            if (de.flags |= Ml, (r.mode & Bt) !== ht) {
              var K = e === null && (r.memoizedProps.unstable_avoidThisFallback !== !0 || !ce);
              K || jx(Ko.current, Yk) ? W6() : qw();
            }
          }
          var Ee = r.updateQueue;
          if (Ee !== null && (r.flags |= Pt), Si(r), (r.mode & vt) !== ht && Xt) {
            var qe = r.child;
            qe !== null && (r.treeBaseDuration -= qe.treeBaseDuration);
          }
          return null;
        }
        case R:
          return _p(r), Aw(e, r), e === null && sN(r.stateNode.containerInfo), Si(r), null;
        case q:
          var Be = r.type._context;
          return fx(Be, r), Si(r), null;
        case me: {
          var wt = r.type;
          return Gl(wt) && qg(r), Si(r), null;
        }
        case xe: {
          Cp(r);
          var Rt = r.memoizedState;
          if (Rt === null)
            return Si(r), null;
          var Tn = (r.flags & _t) !== ct, fn = Rt.rendering;
          if (fn === null)
            if (Tn)
              sv(Rt, !1);
            else {
              var kr = Z6() && (e === null || (e.flags & _t) === ct);
              if (!kr)
                for (var dn = r.child; dn !== null; ) {
                  var Sr = y0(dn);
                  if (Sr !== null) {
                    Tn = !0, r.flags |= _t, sv(Rt, !1);
                    var Hi = Sr.updateQueue;
                    return Hi !== null && (r.updateQueue = Hi, r.flags |= Pt), r.subtreeFlags = ct, ZN(r, s), dc(r, Ix(Ko.current, Qm)), r.child;
                  }
                  dn = dn.sibling;
                }
              Rt.tail !== null && Gn() > d2() && (r.flags |= _t, Tn = !0, sv(Rt, !1), r.lanes = tm);
            }
          else {
            if (!Tn) {
              var Ci = y0(fn);
              if (Ci !== null) {
                r.flags |= _t, Tn = !0;
                var Xa = Ci.updateQueue;
                if (Xa !== null && (r.updateQueue = Xa, r.flags |= Pt), sv(Rt, !0), Rt.tail === null && Rt.tailMode === "hidden" && !fn.alternate && !gi())
                  return Si(r), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Gn() * 2 - Rt.renderingStartTime > d2() && s !== ji && (r.flags |= _t, Tn = !0, sv(Rt, !1), r.lanes = tm);
            }
            if (Rt.isBackwards)
              fn.sibling = r.child, r.child = fn;
            else {
              var sa = Rt.last;
              sa !== null ? sa.sibling = fn : r.child = fn, Rt.last = fn;
            }
          }
          if (Rt.tail !== null) {
            var ua = Rt.tail;
            Rt.rendering = ua, Rt.tail = ua.sibling, Rt.renderingStartTime = Gn(), ua.sibling = null;
            var Vi = Ko.current;
            return Tn ? Vi = Ix(Vi, Qm) : Vi = Ep(Vi), dc(r, Vi), ua;
          }
          return Si(r), null;
        }
        case ve:
          break;
        case Pe:
        case Ue: {
          Zw(r);
          var ru = r.memoizedState, jp = ru !== null;
          if (e !== null) {
            var Ev = e.memoizedState, rs = Ev !== null;
            rs !== jp && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !O && (r.flags |= Ml);
          }
          return !jp || (r.mode & Bt) === ht ? Si(r) : Ii(ns, ji) && (Si(r), r.subtreeFlags & (jn | Pt) && (r.flags |= Ml)), null;
        }
        case We:
          return null;
        case at:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function WL(e, r, s) {
      switch (nx(r), r.tag) {
        case S: {
          var c = r.type;
          Gl(c) && qg(r);
          var h = r.flags;
          return h & Dr ? (r.flags = h & ~Dr | _t, (r.mode & vt) !== ht && dw(r), r) : null;
        }
        case w: {
          r.stateNode, _p(r), K1(r), Ux();
          var y = r.flags;
          return (y & Dr) !== ct && (y & _t) === ct ? (r.flags = y & ~Dr | _t, r) : null;
        }
        case k:
          return $x(r), null;
        case ee: {
          Cp(r);
          var x = r.memoizedState;
          if (x !== null && x.dehydrated !== null) {
            if (r.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            bp();
          }
          var C = r.flags;
          return C & Dr ? (r.flags = C & ~Dr | _t, (r.mode & vt) !== ht && dw(r), r) : null;
        }
        case xe:
          return Cp(r), null;
        case R:
          return _p(r), null;
        case q:
          var T = r.type._context;
          return fx(T, r), null;
        case Pe:
        case Ue:
          return Zw(r), null;
        case We:
          return null;
        default:
          return null;
      }
    }
    function YT(e, r, s) {
      switch (nx(r), r.tag) {
        case S: {
          var c = r.type.childContextTypes;
          c != null && qg(r);
          break;
        }
        case w: {
          r.stateNode, _p(r), K1(r), Ux();
          break;
        }
        case k: {
          $x(r);
          break;
        }
        case R:
          _p(r);
          break;
        case ee:
          Cp(r);
          break;
        case xe:
          Cp(r);
          break;
        case q:
          var h = r.type._context;
          fx(h, r);
          break;
        case Pe:
        case Ue:
          Zw(r);
          break;
      }
    }
    var ZT = null;
    ZT = /* @__PURE__ */ new Set();
    var F0 = !1, xi = !1, YL = typeof WeakSet == "function" ? WeakSet : Set, nt = null, Dp = null, Mp = null;
    function ZL(e) {
      Es(null, function() {
        throw e;
      }), Fh();
    }
    var qL = function(e, r) {
      if (r.props = e.memoizedProps, r.state = e.memoizedState, e.mode & vt)
        try {
          es(), r.componentWillUnmount();
        } finally {
          Jl(e);
        }
      else
        r.componentWillUnmount();
    };
    function qT(e, r) {
      try {
        mc(Wr, e);
      } catch (s) {
        Bn(e, r, s);
      }
    }
    function Dw(e, r, s) {
      try {
        qL(e, s);
      } catch (c) {
        Bn(e, r, c);
      }
    }
    function GL(e, r, s) {
      try {
        s.componentDidMount();
      } catch (c) {
        Bn(e, r, c);
      }
    }
    function GT(e, r) {
      try {
        QT(e);
      } catch (s) {
        Bn(e, r, s);
      }
    }
    function Np(e, r) {
      var s = e.ref;
      if (s !== null)
        if (typeof s == "function") {
          var c;
          try {
            if (lt && Nt && e.mode & vt)
              try {
                es(), c = s(null);
              } finally {
                Jl(e);
              }
            else
              c = s(null);
          } catch (h) {
            Bn(e, r, h);
          }
          typeof c == "function" && p("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", kt(e));
        } else
          s.current = null;
    }
    function U0(e, r, s) {
      try {
        s();
      } catch (c) {
        Bn(e, r, c);
      }
    }
    var XT = !1;
    function XL(e, r) {
      uM(e.containerInfo), nt = r, QL();
      var s = XT;
      return XT = !1, s;
    }
    function QL() {
      for (; nt !== null; ) {
        var e = nt, r = e.child;
        (e.subtreeFlags & Pu) !== ct && r !== null ? (r.return = e, nt = r) : KL();
      }
    }
    function KL() {
      for (; nt !== null; ) {
        var e = nt;
        yn(e);
        try {
          JL(e);
        } catch (s) {
          Bn(e, e.return, s);
        }
        rr();
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, nt = r;
          return;
        }
        nt = e.return;
      }
    }
    function JL(e) {
      var r = e.alternate, s = e.flags;
      if ((s & ga) !== ct) {
        switch (yn(e), e.tag) {
          case b:
          case G:
          case ue:
            break;
          case S: {
            if (r !== null) {
              var c = r.memoizedProps, h = r.memoizedState, y = e.stateNode;
              e.type === e.elementType && !Nf && (y.props !== e.memoizedProps && p("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(e) || "instance"), y.state !== e.memoizedState && p("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(e) || "instance"));
              var x = y.getSnapshotBeforeUpdate(e.elementType === e.type ? c : Qo(e.type, c), h);
              {
                var C = ZT;
                x === void 0 && !C.has(e.type) && (C.add(e.type), p("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", kt(e)));
              }
              y.__reactInternalSnapshotBeforeUpdate = x;
            }
            break;
          }
          case w: {
            {
              var T = e.stateNode;
              LM(T.containerInfo);
            }
            break;
          }
          case k:
          case N:
          case R:
          case me:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        rr();
      }
    }
    function tl(e, r, s) {
      var c = r.updateQueue, h = c !== null ? c.lastEffect : null;
      if (h !== null) {
        var y = h.next, x = y;
        do {
          if ((x.tag & e) === e) {
            var C = x.destroy;
            x.destroy = void 0, C !== void 0 && ((e & bi) !== Aa ? wd(r) : (e & Wr) !== Aa && _d(r), (e & Xl) !== Aa && xv(!0), U0(r, s, C), (e & Xl) !== Aa && xv(!1), (e & bi) !== Aa ? Jy() : (e & Wr) !== Aa && zu());
          }
          x = x.next;
        } while (x !== y);
      }
    }
    function mc(e, r) {
      var s = r.updateQueue, c = s !== null ? s.lastEffect : null;
      if (c !== null) {
        var h = c.next, y = h;
        do {
          if ((y.tag & e) === e) {
            (e & bi) !== Aa ? Ky(r) : (e & Wr) !== Aa && eg(r);
            var x = y.create;
            (e & Xl) !== Aa && xv(!0), y.destroy = x(), (e & Xl) !== Aa && xv(!1), (e & bi) !== Aa ? Kh() : (e & Wr) !== Aa && tg();
            {
              var C = y.destroy;
              if (C !== void 0 && typeof C != "function") {
                var T = void 0;
                (y.tag & Wr) !== ct ? T = "useLayoutEffect" : (y.tag & Xl) !== ct ? T = "useInsertionEffect" : T = "useEffect";
                var M = void 0;
                C === null ? M = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof C.then == "function" ? M = `

It looks like you wrote ` + T + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + T + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : M = " You returned: " + C, p("%s must not return anything besides a function, which is used for clean-up.%s", T, M);
              }
            }
          }
          y = y.next;
        } while (y !== h);
      }
    }
    function e6(e, r) {
      if ((r.flags & Pt) !== ct)
        switch (r.tag) {
          case te: {
            var s = r.stateNode.passiveEffectDuration, c = r.memoizedProps, h = c.id, y = c.onPostCommit, x = gT(), C = r.alternate === null ? "mount" : "update";
            yT() && (C = "nested-update"), typeof y == "function" && y(h, C, s, x);
            var T = r.return;
            e:
              for (; T !== null; ) {
                switch (T.tag) {
                  case w:
                    var M = T.stateNode;
                    M.passiveEffectDuration += s;
                    break e;
                  case te:
                    var P = T.stateNode;
                    P.passiveEffectDuration += s;
                    break e;
                }
                T = T.return;
              }
            break;
          }
        }
    }
    function t6(e, r, s, c) {
      if ((s.flags & ni) !== ct)
        switch (s.tag) {
          case b:
          case G:
          case ue: {
            if (!xi)
              if (s.mode & vt)
                try {
                  es(), mc(Wr | Vr, s);
                } finally {
                  Jl(s);
                }
              else
                mc(Wr | Vr, s);
            break;
          }
          case S: {
            var h = s.stateNode;
            if (s.flags & Pt && !xi)
              if (r === null)
                if (s.type === s.elementType && !Nf && (h.props !== s.memoizedProps && p("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(s) || "instance"), h.state !== s.memoizedState && p("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(s) || "instance")), s.mode & vt)
                  try {
                    es(), h.componentDidMount();
                  } finally {
                    Jl(s);
                  }
                else
                  h.componentDidMount();
              else {
                var y = s.elementType === s.type ? r.memoizedProps : Qo(s.type, r.memoizedProps), x = r.memoizedState;
                if (s.type === s.elementType && !Nf && (h.props !== s.memoizedProps && p("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(s) || "instance"), h.state !== s.memoizedState && p("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(s) || "instance")), s.mode & vt)
                  try {
                    es(), h.componentDidUpdate(y, x, h.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Jl(s);
                  }
                else
                  h.componentDidUpdate(y, x, h.__reactInternalSnapshotBeforeUpdate);
              }
            var C = s.updateQueue;
            C !== null && (s.type === s.elementType && !Nf && (h.props !== s.memoizedProps && p("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", kt(s) || "instance"), h.state !== s.memoizedState && p("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", kt(s) || "instance")), Dk(s, C, h));
            break;
          }
          case w: {
            var T = s.updateQueue;
            if (T !== null) {
              var M = null;
              if (s.child !== null)
                switch (s.child.tag) {
                  case k:
                    M = s.child.stateNode;
                    break;
                  case S:
                    M = s.child.stateNode;
                    break;
                }
              Dk(s, T, M);
            }
            break;
          }
          case k: {
            var P = s.stateNode;
            if (r === null && s.flags & Pt) {
              var Z = s.type, W = s.memoizedProps;
              SM(P, Z, W);
            }
            break;
          }
          case N:
            break;
          case R:
            break;
          case te: {
            {
              var ne = s.memoizedProps, ie = ne.onCommit, fe = ne.onRender, Ze = s.stateNode.effectDuration, dt = gT(), st = r === null ? "mount" : "update";
              yT() && (st = "nested-update"), typeof fe == "function" && fe(s.memoizedProps.id, st, s.actualDuration, s.treeBaseDuration, s.actualStartTime, dt);
              {
                typeof ie == "function" && ie(s.memoizedProps.id, st, Ze, dt), K6(s);
                var tn = s.return;
                e:
                  for (; tn !== null; ) {
                    switch (tn.tag) {
                      case w:
                        var Xt = tn.stateNode;
                        Xt.effectDuration += Ze;
                        break e;
                      case te:
                        var Q = tn.stateNode;
                        Q.effectDuration += Ze;
                        break e;
                    }
                    tn = tn.return;
                  }
              }
            }
            break;
          }
          case ee: {
            u6(e, s);
            break;
          }
          case xe:
          case me:
          case ve:
          case Pe:
          case Ue:
          case at:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      xi || s.flags & Mi && QT(s);
    }
    function n6(e) {
      switch (e.tag) {
        case b:
        case G:
        case ue: {
          if (e.mode & vt)
            try {
              es(), qT(e, e.return);
            } finally {
              Jl(e);
            }
          else
            qT(e, e.return);
          break;
        }
        case S: {
          var r = e.stateNode;
          typeof r.componentDidMount == "function" && GL(e, e.return, r), GT(e, e.return);
          break;
        }
        case k: {
          GT(e, e.return);
          break;
        }
      }
    }
    function r6(e, r) {
      for (var s = null, c = e; ; ) {
        if (c.tag === k) {
          if (s === null) {
            s = c;
            try {
              var h = c.stateNode;
              r ? AM(h) : MM(c.stateNode, c.memoizedProps);
            } catch (x) {
              Bn(e, e.return, x);
            }
          }
        } else if (c.tag === N) {
          if (s === null)
            try {
              var y = c.stateNode;
              r ? DM(y) : NM(y, c.memoizedProps);
            } catch (x) {
              Bn(e, e.return, x);
            }
        } else if (!((c.tag === Pe || c.tag === Ue) && c.memoizedState !== null && c !== e)) {
          if (c.child !== null) {
            c.child.return = c, c = c.child;
            continue;
          }
        }
        if (c === e)
          return;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === e)
            return;
          s === c && (s = null), c = c.return;
        }
        s === c && (s = null), c.sibling.return = c.return, c = c.sibling;
      }
    }
    function QT(e) {
      var r = e.ref;
      if (r !== null) {
        var s = e.stateNode, c;
        switch (e.tag) {
          case k:
            c = s;
            break;
          default:
            c = s;
        }
        if (typeof r == "function") {
          var h;
          if (e.mode & vt)
            try {
              es(), h = r(c);
            } finally {
              Jl(e);
            }
          else
            h = r(c);
          typeof h == "function" && p("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", kt(e));
        } else
          r.hasOwnProperty("current") || p("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", kt(e)), r.current = c;
      }
    }
    function i6(e) {
      var r = e.alternate;
      r !== null && (r.return = null), e.return = null;
    }
    function KT(e) {
      var r = e.alternate;
      r !== null && (e.alternate = null, KT(r));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === k) {
          var s = e.stateNode;
          s !== null && fN(s);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function a6(e) {
      for (var r = e.return; r !== null; ) {
        if (JT(r))
          return r;
        r = r.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function JT(e) {
      return e.tag === k || e.tag === w || e.tag === R;
    }
    function e2(e) {
      var r = e;
      e:
        for (; ; ) {
          for (; r.sibling === null; ) {
            if (r.return === null || JT(r.return))
              return null;
            r = r.return;
          }
          for (r.sibling.return = r.return, r = r.sibling; r.tag !== k && r.tag !== N && r.tag !== Le; ) {
            if (r.flags & jn || r.child === null || r.tag === R)
              continue e;
            r.child.return = r, r = r.child;
          }
          if (!(r.flags & jn))
            return r.stateNode;
        }
    }
    function o6(e) {
      var r = a6(e);
      switch (r.tag) {
        case k: {
          var s = r.stateNode;
          r.flags & gn && (tk(s), r.flags &= ~gn);
          var c = e2(e);
          Nw(e, c, s);
          break;
        }
        case w:
        case R: {
          var h = r.stateNode.containerInfo, y = e2(e);
          Mw(e, y, h);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Mw(e, r, s) {
      var c = e.tag, h = c === k || c === N;
      if (h) {
        var y = e.stateNode;
        r ? kM(s, y, r) : EM(s, y);
      } else if (c !== R) {
        var x = e.child;
        if (x !== null) {
          Mw(x, r, s);
          for (var C = x.sibling; C !== null; )
            Mw(C, r, s), C = C.sibling;
        }
      }
    }
    function Nw(e, r, s) {
      var c = e.tag, h = c === k || c === N;
      if (h) {
        var y = e.stateNode;
        r ? CM(s, y, r) : _M(s, y);
      } else if (c !== R) {
        var x = e.child;
        if (x !== null) {
          Nw(x, r, s);
          for (var C = x.sibling; C !== null; )
            Nw(C, r, s), C = C.sibling;
        }
      }
    }
    var wi = null, nl = !1;
    function l6(e, r, s) {
      {
        var c = r;
        e:
          for (; c !== null; ) {
            switch (c.tag) {
              case k: {
                wi = c.stateNode, nl = !1;
                break e;
              }
              case w: {
                wi = c.stateNode.containerInfo, nl = !0;
                break e;
              }
              case R: {
                wi = c.stateNode.containerInfo, nl = !0;
                break e;
              }
            }
            c = c.return;
          }
        if (wi === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        t2(e, r, s), wi = null, nl = !1;
      }
      i6(s);
    }
    function vc(e, r, s) {
      for (var c = s.child; c !== null; )
        t2(e, r, c), c = c.sibling;
    }
    function t2(e, r, s) {
      switch (Xh(s), s.tag) {
        case k:
          xi || Np(s, r);
        case N: {
          {
            var c = wi, h = nl;
            wi = null, vc(e, r, s), wi = c, nl = h, wi !== null && (nl ? RM(wi, s.stateNode) : TM(wi, s.stateNode));
          }
          return;
        }
        case Le: {
          wi !== null && (nl ? OM(wi, s.stateNode) : V1(wi, s.stateNode));
          return;
        }
        case R: {
          {
            var y = wi, x = nl;
            wi = s.stateNode.containerInfo, nl = !0, vc(e, r, s), wi = y, nl = x;
          }
          return;
        }
        case b:
        case G:
        case V:
        case ue: {
          if (!xi) {
            var C = s.updateQueue;
            if (C !== null) {
              var T = C.lastEffect;
              if (T !== null) {
                var M = T.next, P = M;
                do {
                  var Z = P, W = Z.destroy, ne = Z.tag;
                  W !== void 0 && ((ne & Xl) !== Aa ? U0(s, r, W) : (ne & Wr) !== Aa && (_d(s), s.mode & vt ? (es(), U0(s, r, W), Jl(s)) : U0(s, r, W), zu())), P = P.next;
                } while (P !== M);
              }
            }
          }
          vc(e, r, s);
          return;
        }
        case S: {
          if (!xi) {
            Np(s, r);
            var ie = s.stateNode;
            typeof ie.componentWillUnmount == "function" && Dw(s, r, ie);
          }
          vc(e, r, s);
          return;
        }
        case ve: {
          vc(e, r, s);
          return;
        }
        case Pe: {
          if (
            // TODO: Remove this dead flag
            s.mode & Bt
          ) {
            var fe = xi;
            xi = fe || s.memoizedState !== null, vc(e, r, s), xi = fe;
          } else
            vc(e, r, s);
          break;
        }
        default: {
          vc(e, r, s);
          return;
        }
      }
    }
    function s6(e) {
      e.memoizedState;
    }
    function u6(e, r) {
      var s = r.memoizedState;
      if (s === null) {
        var c = r.alternate;
        if (c !== null) {
          var h = c.memoizedState;
          if (h !== null) {
            var y = h.dehydrated;
            y !== null && qM(y);
          }
        }
      }
    }
    function n2(e) {
      var r = e.updateQueue;
      if (r !== null) {
        e.updateQueue = null;
        var s = e.stateNode;
        s === null && (s = e.stateNode = new YL()), r.forEach(function(c) {
          var h = aP.bind(null, e, c);
          if (!s.has(c)) {
            if (s.add(c), Br)
              if (Dp !== null && Mp !== null)
                Sv(Mp, Dp);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            c.then(h, h);
          }
        });
      }
    }
    function c6(e, r, s) {
      Dp = s, Mp = e, yn(r), r2(r, e), yn(r), Dp = null, Mp = null;
    }
    function rl(e, r, s) {
      var c = r.deletions;
      if (c !== null)
        for (var h = 0; h < c.length; h++) {
          var y = c[h];
          try {
            l6(e, r, y);
          } catch (T) {
            Bn(y, r, T);
          }
        }
      var x = ed();
      if (r.subtreeFlags & Pi)
        for (var C = r.child; C !== null; )
          yn(C), r2(C, e), C = C.sibling;
      yn(x);
    }
    function r2(e, r, s) {
      var c = e.alternate, h = e.flags;
      switch (e.tag) {
        case b:
        case G:
        case V:
        case ue: {
          if (rl(r, e), ts(e), h & Pt) {
            try {
              tl(Xl | Vr, e, e.return), mc(Xl | Vr, e);
            } catch (wt) {
              Bn(e, e.return, wt);
            }
            if (e.mode & vt) {
              try {
                es(), tl(Wr | Vr, e, e.return);
              } catch (wt) {
                Bn(e, e.return, wt);
              }
              Jl(e);
            } else
              try {
                tl(Wr | Vr, e, e.return);
              } catch (wt) {
                Bn(e, e.return, wt);
              }
          }
          return;
        }
        case S: {
          rl(r, e), ts(e), h & Mi && c !== null && Np(c, c.return);
          return;
        }
        case k: {
          rl(r, e), ts(e), h & Mi && c !== null && Np(c, c.return);
          {
            if (e.flags & gn) {
              var y = e.stateNode;
              try {
                tk(y);
              } catch (wt) {
                Bn(e, e.return, wt);
              }
            }
            if (h & Pt) {
              var x = e.stateNode;
              if (x != null) {
                var C = e.memoizedProps, T = c !== null ? c.memoizedProps : C, M = e.type, P = e.updateQueue;
                if (e.updateQueue = null, P !== null)
                  try {
                    xM(x, P, M, T, C, e);
                  } catch (wt) {
                    Bn(e, e.return, wt);
                  }
              }
            }
          }
          return;
        }
        case N: {
          if (rl(r, e), ts(e), h & Pt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var Z = e.stateNode, W = e.memoizedProps, ne = c !== null ? c.memoizedProps : W;
            try {
              wM(Z, ne, W);
            } catch (wt) {
              Bn(e, e.return, wt);
            }
          }
          return;
        }
        case w: {
          if (rl(r, e), ts(e), h & Pt && c !== null) {
            var ie = c.memoizedState;
            if (ie.isDehydrated)
              try {
                ZM(r.containerInfo);
              } catch (wt) {
                Bn(e, e.return, wt);
              }
          }
          return;
        }
        case R: {
          rl(r, e), ts(e);
          return;
        }
        case ee: {
          rl(r, e), ts(e);
          var fe = e.child;
          if (fe.flags & Ml) {
            var Ze = fe.stateNode, dt = fe.memoizedState, st = dt !== null;
            if (Ze.isHidden = st, st) {
              var tn = fe.alternate !== null && fe.alternate.memoizedState !== null;
              tn || V6();
            }
          }
          if (h & Pt) {
            try {
              s6(e);
            } catch (wt) {
              Bn(e, e.return, wt);
            }
            n2(e);
          }
          return;
        }
        case Pe: {
          var Xt = c !== null && c.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & Bt
          ) {
            var Q = xi;
            xi = Q || Xt, rl(r, e), xi = Q;
          } else
            rl(r, e);
          if (ts(e), h & Ml) {
            var de = e.stateNode, K = e.memoizedState, Ee = K !== null, qe = e;
            if (de.isHidden = Ee, Ee && !Xt && (qe.mode & Bt) !== ht) {
              nt = qe;
              for (var Be = qe.child; Be !== null; )
                nt = Be, d6(Be), Be = Be.sibling;
            }
            r6(qe, Ee);
          }
          return;
        }
        case xe: {
          rl(r, e), ts(e), h & Pt && n2(e);
          return;
        }
        case ve:
          return;
        default: {
          rl(r, e), ts(e);
          return;
        }
      }
    }
    function ts(e) {
      var r = e.flags;
      if (r & jn) {
        try {
          o6(e);
        } catch (s) {
          Bn(e, e.return, s);
        }
        e.flags &= ~jn;
      }
      r & ba && (e.flags &= ~ba);
    }
    function f6(e, r, s) {
      Dp = s, Mp = r, nt = e, i2(e, r, s), Dp = null, Mp = null;
    }
    function i2(e, r, s) {
      for (var c = (e.mode & Bt) !== ht; nt !== null; ) {
        var h = nt, y = h.child;
        if (h.tag === Pe && c) {
          var x = h.memoizedState !== null, C = x || F0;
          if (C) {
            Lw(e, r, s);
            continue;
          } else {
            var T = h.alternate, M = T !== null && T.memoizedState !== null, P = M || xi, Z = F0, W = xi;
            F0 = C, xi = P, xi && !W && (nt = h, p6(h));
            for (var ne = y; ne !== null; )
              nt = ne, i2(
                ne,
                // New root; bubble back up to here and stop.
                r,
                s
              ), ne = ne.sibling;
            nt = h, F0 = Z, xi = W, Lw(e, r, s);
            continue;
          }
        }
        (h.subtreeFlags & ni) !== ct && y !== null ? (y.return = h, nt = y) : Lw(e, r, s);
      }
    }
    function Lw(e, r, s) {
      for (; nt !== null; ) {
        var c = nt;
        if ((c.flags & ni) !== ct) {
          var h = c.alternate;
          yn(c);
          try {
            t6(r, h, c, s);
          } catch (x) {
            Bn(c, c.return, x);
          }
          rr();
        }
        if (c === e) {
          nt = null;
          return;
        }
        var y = c.sibling;
        if (y !== null) {
          y.return = c.return, nt = y;
          return;
        }
        nt = c.return;
      }
    }
    function d6(e) {
      for (; nt !== null; ) {
        var r = nt, s = r.child;
        switch (r.tag) {
          case b:
          case G:
          case V:
          case ue: {
            if (r.mode & vt)
              try {
                es(), tl(Wr, r, r.return);
              } finally {
                Jl(r);
              }
            else
              tl(Wr, r, r.return);
            break;
          }
          case S: {
            Np(r, r.return);
            var c = r.stateNode;
            typeof c.componentWillUnmount == "function" && Dw(r, r.return, c);
            break;
          }
          case k: {
            Np(r, r.return);
            break;
          }
          case Pe: {
            var h = r.memoizedState !== null;
            if (h) {
              a2(e);
              continue;
            }
            break;
          }
        }
        s !== null ? (s.return = r, nt = s) : a2(e);
      }
    }
    function a2(e) {
      for (; nt !== null; ) {
        var r = nt;
        if (r === e) {
          nt = null;
          return;
        }
        var s = r.sibling;
        if (s !== null) {
          s.return = r.return, nt = s;
          return;
        }
        nt = r.return;
      }
    }
    function p6(e) {
      for (; nt !== null; ) {
        var r = nt, s = r.child;
        if (r.tag === Pe) {
          var c = r.memoizedState !== null;
          if (c) {
            o2(e);
            continue;
          }
        }
        s !== null ? (s.return = r, nt = s) : o2(e);
      }
    }
    function o2(e) {
      for (; nt !== null; ) {
        var r = nt;
        yn(r);
        try {
          n6(r);
        } catch (c) {
          Bn(r, r.return, c);
        }
        if (rr(), r === e) {
          nt = null;
          return;
        }
        var s = r.sibling;
        if (s !== null) {
          s.return = r.return, nt = s;
          return;
        }
        nt = r.return;
      }
    }
    function h6(e, r, s, c) {
      nt = r, m6(r, e, s, c);
    }
    function m6(e, r, s, c) {
      for (; nt !== null; ) {
        var h = nt, y = h.child;
        (h.subtreeFlags & Sa) !== ct && y !== null ? (y.return = h, nt = y) : v6(e, r, s, c);
      }
    }
    function v6(e, r, s, c) {
      for (; nt !== null; ) {
        var h = nt;
        if ((h.flags & Hn) !== ct) {
          yn(h);
          try {
            y6(r, h, s, c);
          } catch (x) {
            Bn(h, h.return, x);
          }
          rr();
        }
        if (h === e) {
          nt = null;
          return;
        }
        var y = h.sibling;
        if (y !== null) {
          y.return = h.return, nt = y;
          return;
        }
        nt = h.return;
      }
    }
    function y6(e, r, s, c) {
      switch (r.tag) {
        case b:
        case G:
        case ue: {
          if (r.mode & vt) {
            fw();
            try {
              mc(bi | Vr, r);
            } finally {
              cw(r);
            }
          } else
            mc(bi | Vr, r);
          break;
        }
      }
    }
    function g6(e) {
      nt = e, b6();
    }
    function b6() {
      for (; nt !== null; ) {
        var e = nt, r = e.child;
        if ((nt.flags & hn) !== ct) {
          var s = e.deletions;
          if (s !== null) {
            for (var c = 0; c < s.length; c++) {
              var h = s[c];
              nt = h, w6(h, e);
            }
            {
              var y = e.alternate;
              if (y !== null) {
                var x = y.child;
                if (x !== null) {
                  y.child = null;
                  do {
                    var C = x.sibling;
                    x.sibling = null, x = C;
                  } while (x !== null);
                }
              }
            }
            nt = e;
          }
        }
        (e.subtreeFlags & Sa) !== ct && r !== null ? (r.return = e, nt = r) : S6();
      }
    }
    function S6() {
      for (; nt !== null; ) {
        var e = nt;
        (e.flags & Hn) !== ct && (yn(e), x6(e), rr());
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, nt = r;
          return;
        }
        nt = e.return;
      }
    }
    function x6(e) {
      switch (e.tag) {
        case b:
        case G:
        case ue: {
          e.mode & vt ? (fw(), tl(bi | Vr, e, e.return), cw(e)) : tl(bi | Vr, e, e.return);
          break;
        }
      }
    }
    function w6(e, r) {
      for (; nt !== null; ) {
        var s = nt;
        yn(s), E6(s, r), rr();
        var c = s.child;
        c !== null ? (c.return = s, nt = c) : _6(e);
      }
    }
    function _6(e) {
      for (; nt !== null; ) {
        var r = nt, s = r.sibling, c = r.return;
        if (KT(r), r === e) {
          nt = null;
          return;
        }
        if (s !== null) {
          s.return = c, nt = s;
          return;
        }
        nt = c;
      }
    }
    function E6(e, r) {
      switch (e.tag) {
        case b:
        case G:
        case ue: {
          e.mode & vt ? (fw(), tl(bi, e, r), cw(e)) : tl(bi, e, r);
          break;
        }
      }
    }
    function C6(e) {
      switch (e.tag) {
        case b:
        case G:
        case ue: {
          try {
            mc(Wr | Vr, e);
          } catch (s) {
            Bn(e, e.return, s);
          }
          break;
        }
        case S: {
          var r = e.stateNode;
          try {
            r.componentDidMount();
          } catch (s) {
            Bn(e, e.return, s);
          }
          break;
        }
      }
    }
    function k6(e) {
      switch (e.tag) {
        case b:
        case G:
        case ue: {
          try {
            mc(bi | Vr, e);
          } catch (r) {
            Bn(e, e.return, r);
          }
          break;
        }
      }
    }
    function T6(e) {
      switch (e.tag) {
        case b:
        case G:
        case ue: {
          try {
            tl(Wr | Vr, e, e.return);
          } catch (s) {
            Bn(e, e.return, s);
          }
          break;
        }
        case S: {
          var r = e.stateNode;
          typeof r.componentWillUnmount == "function" && Dw(e, e.return, r);
          break;
        }
      }
    }
    function R6(e) {
      switch (e.tag) {
        case b:
        case G:
        case ue:
          try {
            tl(bi | Vr, e, e.return);
          } catch (r) {
            Bn(e, e.return, r);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var uv = Symbol.for;
      uv("selector.component"), uv("selector.has_pseudo_class"), uv("selector.role"), uv("selector.test_id"), uv("selector.text");
    }
    var O6 = [];
    function A6() {
      O6.forEach(function(e) {
        return e();
      });
    }
    var D6 = i.ReactCurrentActQueue;
    function M6(e) {
      {
        var r = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), s = typeof jest < "u";
        return s && r !== !1;
      }
    }
    function l2() {
      {
        var e = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && D6.current !== null && p("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var N6 = Math.ceil, Pw = i.ReactCurrentDispatcher, zw = i.ReactCurrentOwner, _i = i.ReactCurrentBatchConfig, il = i.ReactCurrentActQueue, qr = (
      /*             */
      0
    ), s2 = (
      /*               */
      1
    ), Ei = (
      /*                */
      2
    ), _o = (
      /*                */
      4
    ), Js = 0, cv = 1, Lf = 2, B0 = 3, fv = 4, u2 = 5, $w = 6, en = qr, oa = null, fr = null, Gr = pe, ns = pe, jw = oc(pe), Xr = Js, dv = null, H0 = pe, pv = pe, V0 = pe, hv = null, Da = null, Iw = 0, c2 = 500, f2 = 1 / 0, L6 = 500, eu = null;
    function mv() {
      f2 = Gn() + L6;
    }
    function d2() {
      return f2;
    }
    var W0 = !1, Fw = null, Lp = null, Pf = !1, yc = null, vv = pe, Uw = [], Bw = null, P6 = 50, yv = 0, Hw = null, Vw = !1, Y0 = !1, z6 = 50, Pp = 0, Z0 = null, gv = Dn, q0 = pe, p2 = !1;
    function G0() {
      return oa;
    }
    function la() {
      return (en & (Ei | _o)) !== qr ? Gn() : (gv !== Dn || (gv = Gn()), gv);
    }
    function gc(e) {
      var r = e.mode;
      if ((r & Bt) === ht)
        return bt;
      if ((en & Ei) !== qr && Gr !== pe)
        return wr(Gr);
      var s = MN() !== DN;
      if (s) {
        if (_i.transition !== null) {
          var c = _i.transition;
          c._updatedFibers || (c._updatedFibers = /* @__PURE__ */ new Set()), c._updatedFibers.add(e);
        }
        return q0 === Jt && (q0 = im()), q0;
      }
      var h = Ea();
      if (h !== Jt)
        return h;
      var y = vM();
      return y;
    }
    function $6(e) {
      var r = e.mode;
      return (r & Bt) === ht ? bt : f1();
    }
    function Qr(e, r, s, c) {
      lP(), p2 && p("useInsertionEffect must not schedule updates."), Vw && (Y0 = !0), zs(e, s, c), (en & Ei) !== pe && e === oa ? cP(r) : (Br && um(e, r, s), fP(r), e === oa && ((en & Ei) === qr && (pv = zt(pv, s)), Xr === fv && bc(e, Gr)), Ma(e, c), s === bt && en === qr && (r.mode & Bt) === ht && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !il.isBatchingLegacy && (mv(), dk()));
    }
    function j6(e, r, s) {
      var c = e.current;
      c.lanes = r, zs(e, r, s), Ma(e, s);
    }
    function I6(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (en & Ei) !== qr
      );
    }
    function Ma(e, r) {
      var s = e.callbackNode;
      s1(e, r);
      var c = of(e, e === oa ? Gr : pe);
      if (c === pe) {
        s !== null && O2(s), e.callbackNode = null, e.callbackPriority = Jt;
        return;
      }
      var h = gr(c), y = e.callbackPriority;
      if (y === h && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(il.current !== null && s !== Qw)) {
        s == null && y !== bt && p("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      s != null && O2(s);
      var x;
      if (h === bt)
        e.tag === lc ? (il.isBatchingLegacy !== null && (il.didScheduleLegacyUpdate = !0), hN(v2.bind(null, e))) : fk(v2.bind(null, e)), il.current !== null ? il.current.push(sc) : gM(function() {
          (en & (Ei | _o)) === qr && sc();
        }), x = null;
      else {
        var C;
        switch (ff(c)) {
          case ri:
            C = bd;
            break;
          case Hr:
            C = na;
            break;
          case Ho:
            C = po;
            break;
          case uf:
            C = Ll;
            break;
          default:
            C = po;
            break;
        }
        x = Kw(C, h2.bind(null, e));
      }
      e.callbackPriority = h, e.callbackNode = x;
    }
    function h2(e, r) {
      if (lL(), gv = Dn, q0 = pe, (en & (Ei | _o)) !== qr)
        throw new Error("Should not already be working.");
      var s = e.callbackNode, c = nu();
      if (c && e.callbackNode !== s)
        return null;
      var h = of(e, e === oa ? Gr : pe);
      if (h === pe)
        return null;
      var y = !sf(e, h) && !lg(e, h) && !r, x = y ? G6(e, h) : Q0(e, h);
      if (x !== Js) {
        if (x === Lf) {
          var C = nm(e);
          C !== pe && (h = C, x = Ww(e, C));
        }
        if (x === cv) {
          var T = dv;
          throw zf(e, pe), bc(e, h), Ma(e, Gn()), T;
        }
        if (x === $w)
          bc(e, h);
        else {
          var M = !sf(e, h), P = e.current.alternate;
          if (M && !U6(P)) {
            if (x = Q0(e, h), x === Lf) {
              var Z = nm(e);
              Z !== pe && (h = Z, x = Ww(e, Z));
            }
            if (x === cv) {
              var W = dv;
              throw zf(e, pe), bc(e, h), Ma(e, Gn()), W;
            }
          }
          e.finishedWork = P, e.finishedLanes = h, F6(e, x, h);
        }
      }
      return Ma(e, Gn()), e.callbackNode === s ? h2.bind(null, e) : null;
    }
    function Ww(e, r) {
      var s = hv;
      if (Er(e)) {
        var c = zf(e, r);
        c.flags |= ir, lN(e.containerInfo);
      }
      var h = Q0(e, r);
      if (h !== Lf) {
        var y = Da;
        Da = s, y !== null && m2(y);
      }
      return h;
    }
    function m2(e) {
      Da === null ? Da = e : Da.push.apply(Da, e);
    }
    function F6(e, r, s) {
      switch (r) {
        case Js:
        case cv:
          throw new Error("Root did not complete. This is a bug in React.");
        case Lf: {
          $f(e, Da, eu);
          break;
        }
        case B0: {
          if (bc(e, s), Hd(s) && // do not delay if we're inside an act() scope
          !A2()) {
            var c = Iw + c2 - Gn();
            if (c > 10) {
              var h = of(e, pe);
              if (h !== pe)
                break;
              var y = e.suspendedLanes;
              if (!Ps(y, s)) {
                la(), lm(e, y);
                break;
              }
              e.timeoutHandle = B1($f.bind(null, e, Da, eu), c);
              break;
            }
          }
          $f(e, Da, eu);
          break;
        }
        case fv: {
          if (bc(e, s), og(s))
            break;
          if (!A2()) {
            var x = ag(e, s), C = x, T = Gn() - C, M = oP(T) - T;
            if (M > 10) {
              e.timeoutHandle = B1($f.bind(null, e, Da, eu), M);
              break;
            }
          }
          $f(e, Da, eu);
          break;
        }
        case u2: {
          $f(e, Da, eu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function U6(e) {
      for (var r = e; ; ) {
        if (r.flags & Kc) {
          var s = r.updateQueue;
          if (s !== null) {
            var c = s.stores;
            if (c !== null)
              for (var h = 0; h < c.length; h++) {
                var y = c[h], x = y.getSnapshot, C = y.value;
                try {
                  if (!tt(x(), C))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var T = r.child;
        if (r.subtreeFlags & Kc && T !== null) {
          T.return = r, r = T;
          continue;
        }
        if (r === e)
          return !0;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return !0;
    }
    function bc(e, r) {
      r = Hu(r, V0), r = Hu(r, pv), om(e, r);
    }
    function v2(e) {
      if (sL(), (en & (Ei | _o)) !== qr)
        throw new Error("Should not already be working.");
      nu();
      var r = of(e, pe);
      if (!Ii(r, bt))
        return Ma(e, Gn()), null;
      var s = Q0(e, r);
      if (e.tag !== lc && s === Lf) {
        var c = nm(e);
        c !== pe && (r = c, s = Ww(e, c));
      }
      if (s === cv) {
        var h = dv;
        throw zf(e, pe), bc(e, r), Ma(e, Gn()), h;
      }
      if (s === $w)
        throw new Error("Root did not complete. This is a bug in React.");
      var y = e.current.alternate;
      return e.finishedWork = y, e.finishedLanes = r, $f(e, Da, eu), Ma(e, Gn()), null;
    }
    function B6(e, r) {
      r !== pe && (Vu(e, zt(r, bt)), Ma(e, Gn()), (en & (Ei | _o)) === qr && (mv(), sc()));
    }
    function Yw(e, r) {
      var s = en;
      en |= s2;
      try {
        return e(r);
      } finally {
        en = s, en === qr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !il.isBatchingLegacy && (mv(), dk());
      }
    }
    function H6(e, r, s, c, h) {
      var y = Ea(), x = _i.transition;
      try {
        return _i.transition = null, _r(ri), e(r, s, c, h);
      } finally {
        _r(y), _i.transition = x, en === qr && mv();
      }
    }
    function tu(e) {
      yc !== null && yc.tag === lc && (en & (Ei | _o)) === qr && nu();
      var r = en;
      en |= s2;
      var s = _i.transition, c = Ea();
      try {
        return _i.transition = null, _r(ri), e ? e() : void 0;
      } finally {
        _r(c), _i.transition = s, en = r, (en & (Ei | _o)) === qr && sc();
      }
    }
    function y2() {
      return (en & (Ei | _o)) !== qr;
    }
    function X0(e, r) {
      Ui(jw, ns, e), ns = zt(ns, r);
    }
    function Zw(e) {
      ns = jw.current, Fi(jw, e);
    }
    function zf(e, r) {
      e.finishedWork = null, e.finishedLanes = pe;
      var s = e.timeoutHandle;
      if (s !== H1 && (e.timeoutHandle = H1, yM(s)), fr !== null)
        for (var c = fr.return; c !== null; ) {
          var h = c.alternate;
          YT(h, c), c = c.return;
        }
      oa = e;
      var y = jf(e.current, null);
      return fr = y, Gr = ns = r, Xr = Js, dv = null, H0 = pe, pv = pe, V0 = pe, hv = null, Da = null, zN(), Xo.discardPendingWarnings(), y;
    }
    function g2(e, r) {
      do {
        var s = fr;
        try {
          if (i0(), qk(), rr(), zw.current = null, s === null || s.return === null) {
            Xr = cv, dv = r, fr = null;
            return;
          }
          if (lt && s.mode & vt && z0(s, !0), Mt)
            if (ks(), r !== null && typeof r == "object" && typeof r.then == "function") {
              var c = r;
              ng(s, c, Gr);
            } else
              Ed(s, r, Gr);
          pL(e, s.return, s, r, Gr), w2(s);
        } catch (h) {
          r = h, fr === s && s !== null ? (s = s.return, fr = s) : s = fr;
          continue;
        }
        return;
      } while (!0);
    }
    function b2() {
      var e = Pw.current;
      return Pw.current = D0, e === null ? D0 : e;
    }
    function S2(e) {
      Pw.current = e;
    }
    function V6() {
      Iw = Gn();
    }
    function bv(e) {
      H0 = zt(e, H0);
    }
    function W6() {
      Xr === Js && (Xr = B0);
    }
    function qw() {
      (Xr === Js || Xr === B0 || Xr === Lf) && (Xr = fv), oa !== null && (lf(H0) || lf(pv)) && bc(oa, Gr);
    }
    function Y6(e) {
      Xr !== fv && (Xr = Lf), hv === null ? hv = [e] : hv.push(e);
    }
    function Z6() {
      return Xr === Js;
    }
    function Q0(e, r) {
      var s = en;
      en |= Ei;
      var c = b2();
      if (oa !== e || Gr !== r) {
        if (Br) {
          var h = e.memoizedUpdaters;
          h.size > 0 && (Sv(e, Gr), h.clear()), Yd(e, r);
        }
        eu = cm(), zf(e, r);
      }
      Ya(r);
      do
        try {
          q6();
          break;
        } catch (y) {
          g2(e, y);
        }
      while (!0);
      if (i0(), en = s, S2(c), fr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ju(), oa = null, Gr = pe, Xr;
    }
    function q6() {
      for (; fr !== null; )
        x2(fr);
    }
    function G6(e, r) {
      var s = en;
      en |= Ei;
      var c = b2();
      if (oa !== e || Gr !== r) {
        if (Br) {
          var h = e.memoizedUpdaters;
          h.size > 0 && (Sv(e, Gr), h.clear()), Yd(e, r);
        }
        eu = cm(), mv(), zf(e, r);
      }
      Ya(r);
      do
        try {
          X6();
          break;
        } catch (y) {
          g2(e, y);
        }
      while (!0);
      return i0(), S2(c), en = s, fr !== null ? (tf(), Js) : (ju(), oa = null, Gr = pe, Xr);
    }
    function X6() {
      for (; fr !== null && !gd(); )
        x2(fr);
    }
    function x2(e) {
      var r = e.alternate;
      yn(e);
      var s;
      (e.mode & vt) !== ht ? (uw(e), s = Gw(r, e, ns), z0(e, !0)) : s = Gw(r, e, ns), rr(), e.memoizedProps = e.pendingProps, s === null ? w2(e) : fr = s, zw.current = null;
    }
    function w2(e) {
      var r = e;
      do {
        var s = r.alternate, c = r.return;
        if ((r.flags & Ji) === ct) {
          yn(r);
          var h = void 0;
          if ((r.mode & vt) === ht ? h = WT(s, r, ns) : (uw(r), h = WT(s, r, ns), z0(r, !1)), rr(), h !== null) {
            fr = h;
            return;
          }
        } else {
          var y = WL(s, r);
          if (y !== null) {
            y.flags &= Zy, fr = y;
            return;
          }
          if ((r.mode & vt) !== ht) {
            z0(r, !1);
            for (var x = r.actualDuration, C = r.child; C !== null; )
              x += C.actualDuration, C = C.sibling;
            r.actualDuration = x;
          }
          if (c !== null)
            c.flags |= Ji, c.subtreeFlags = ct, c.deletions = null;
          else {
            Xr = $w, fr = null;
            return;
          }
        }
        var T = r.sibling;
        if (T !== null) {
          fr = T;
          return;
        }
        r = c, fr = r;
      } while (r !== null);
      Xr === Js && (Xr = u2);
    }
    function $f(e, r, s) {
      var c = Ea(), h = _i.transition;
      try {
        _i.transition = null, _r(ri), Q6(e, r, s, c);
      } finally {
        _i.transition = h, _r(c);
      }
      return null;
    }
    function Q6(e, r, s, c) {
      do
        nu();
      while (yc !== null);
      if (sP(), (en & (Ei | _o)) !== qr)
        throw new Error("Should not already be working.");
      var h = e.finishedWork, y = e.finishedLanes;
      if (xd(y), h === null)
        return Qh(), null;
      if (y === pe && p("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = pe, h === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = Jt;
      var x = zt(h.lanes, h.childLanes);
      sm(e, x), e === oa && (oa = null, fr = null, Gr = pe), ((h.subtreeFlags & Sa) !== ct || (h.flags & Sa) !== ct) && (Pf || (Pf = !0, Bw = s, Kw(po, function() {
        return nu(), null;
      })));
      var C = (h.subtreeFlags & (Pu | Pi | ni | Sa)) !== ct, T = (h.flags & (Pu | Pi | ni | Sa)) !== ct;
      if (C || T) {
        var M = _i.transition;
        _i.transition = null;
        var P = Ea();
        _r(ri);
        var Z = en;
        en |= _o, zw.current = null, XL(e, h), bT(), c6(e, h, y), cM(e.containerInfo), e.current = h, rg(y), f6(h, e, y), $u(), Xy(), en = Z, _r(P), _i.transition = M;
      } else
        e.current = h, bT();
      var W = Pf;
      if (Pf ? (Pf = !1, yc = e, vv = y) : (Pp = 0, Z0 = null), x = e.pendingLanes, x === pe && (Lp = null), W || k2(e.current, !1), Fo(h.stateNode, c), Br && e.memoizedUpdaters.clear(), A6(), Ma(e, Gn()), r !== null)
        for (var ne = e.onRecoverableError, ie = 0; ie < r.length; ie++) {
          var fe = r[ie], Ze = fe.stack, dt = fe.digest;
          ne(fe.value, {
            componentStack: Ze,
            digest: dt
          });
        }
      if (W0) {
        W0 = !1;
        var st = Fw;
        throw Fw = null, st;
      }
      return Ii(vv, bt) && e.tag !== lc && nu(), x = e.pendingLanes, Ii(x, bt) ? (oL(), e === Hw ? yv++ : (yv = 0, Hw = e)) : yv = 0, sc(), Qh(), null;
    }
    function nu() {
      if (yc !== null) {
        var e = ff(vv), r = p1(Ho, e), s = _i.transition, c = Ea();
        try {
          return _i.transition = null, _r(r), J6();
        } finally {
          _r(c), _i.transition = s;
        }
      }
      return !1;
    }
    function K6(e) {
      Uw.push(e), Pf || (Pf = !0, Kw(po, function() {
        return nu(), null;
      }));
    }
    function J6() {
      if (yc === null)
        return !1;
      var e = Bw;
      Bw = null;
      var r = yc, s = vv;
      if (yc = null, vv = pe, (en & (Ei | _o)) !== qr)
        throw new Error("Cannot flush passive effects while already rendering.");
      Vw = !0, Y0 = !1, ig(s);
      var c = en;
      en |= _o, g6(r.current), h6(r, r.current, s, e);
      {
        var h = Uw;
        Uw = [];
        for (var y = 0; y < h.length; y++) {
          var x = h[y];
          e6(r, x);
        }
      }
      ef(), k2(r.current, !0), en = c, sc(), Y0 ? r === Z0 ? Pp++ : (Pp = 0, Z0 = r) : Pp = 0, Vw = !1, Y0 = !1, zl(r);
      {
        var C = r.current.stateNode;
        C.effectDuration = 0, C.passiveEffectDuration = 0;
      }
      return !0;
    }
    function _2(e) {
      return Lp !== null && Lp.has(e);
    }
    function eP(e) {
      Lp === null ? Lp = /* @__PURE__ */ new Set([e]) : Lp.add(e);
    }
    function tP(e) {
      W0 || (W0 = !0, Fw = e);
    }
    var nP = tP;
    function E2(e, r, s) {
      var c = Mf(s, r), h = xT(e, c, bt), y = cc(e, h, bt), x = la();
      y !== null && (zs(y, bt, x), Ma(y, x));
    }
    function Bn(e, r, s) {
      if (ZL(s), xv(!1), e.tag === w) {
        E2(e, e, s);
        return;
      }
      var c = null;
      for (c = r; c !== null; ) {
        if (c.tag === w) {
          E2(c, e, s);
          return;
        } else if (c.tag === S) {
          var h = c.type, y = c.stateNode;
          if (typeof h.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && !_2(y)) {
            var x = Mf(s, e), C = mw(c, x, bt), T = cc(c, C, bt), M = la();
            T !== null && (zs(T, bt, M), Ma(T, M));
            return;
          }
        }
        c = c.return;
      }
      p(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, s);
    }
    function rP(e, r, s) {
      var c = e.pingCache;
      c !== null && c.delete(r);
      var h = la();
      lm(e, s), dP(e), oa === e && Ps(Gr, s) && (Xr === fv || Xr === B0 && Hd(Gr) && Gn() - Iw < c2 ? zf(e, pe) : V0 = zt(V0, s)), Ma(e, h);
    }
    function C2(e, r) {
      r === Jt && (r = $6(e));
      var s = la(), c = Oa(e, r);
      c !== null && (zs(c, r, s), Ma(c, s));
    }
    function iP(e) {
      var r = e.memoizedState, s = Jt;
      r !== null && (s = r.retryLane), C2(e, s);
    }
    function aP(e, r) {
      var s = Jt, c;
      switch (e.tag) {
        case ee:
          c = e.stateNode;
          var h = e.memoizedState;
          h !== null && (s = h.retryLane);
          break;
        case xe:
          c = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      c !== null && c.delete(r), C2(e, s);
    }
    function oP(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : N6(e / 1960) * 1960;
    }
    function lP() {
      if (yv > P6)
        throw yv = 0, Hw = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Pp > z6 && (Pp = 0, Z0 = null, p("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function sP() {
      Xo.flushLegacyContextWarning(), Xo.flushPendingUnsafeLifecycleWarnings();
    }
    function k2(e, r) {
      yn(e), K0(e, Li, T6), r && K0(e, Cs, R6), K0(e, Li, C6), r && K0(e, Cs, k6), rr();
    }
    function K0(e, r, s) {
      for (var c = e, h = null; c !== null; ) {
        var y = c.subtreeFlags & r;
        c !== h && c.child !== null && y !== ct ? c = c.child : ((c.flags & r) !== ct && s(c), c.sibling !== null ? c = c.sibling : c = h = c.return);
      }
    }
    var J0 = null;
    function T2(e) {
      {
        if ((en & Ei) !== qr || !(e.mode & Bt))
          return;
        var r = e.tag;
        if (r !== E && r !== w && r !== S && r !== b && r !== G && r !== V && r !== ue)
          return;
        var s = kt(e) || "ReactComponent";
        if (J0 !== null) {
          if (J0.has(s))
            return;
          J0.add(s);
        } else
          J0 = /* @__PURE__ */ new Set([s]);
        var c = qn;
        try {
          yn(e), p("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          c ? yn(e) : rr();
        }
      }
    }
    var Gw;
    {
      var uP = null;
      Gw = function(e, r, s) {
        var c = P2(uP, r);
        try {
          return FT(e, r, s);
        } catch (y) {
          if (wN() || y !== null && typeof y == "object" && typeof y.then == "function")
            throw y;
          if (i0(), qk(), YT(e, r), P2(r, c), r.mode & vt && uw(r), Es(null, FT, null, e, r, s), o1()) {
            var h = Fh();
            typeof h == "object" && h !== null && h._suppressLogging && typeof y == "object" && y !== null && !y._suppressLogging && (y._suppressLogging = !0);
          }
          throw y;
        }
      };
    }
    var R2 = !1, Xw;
    Xw = /* @__PURE__ */ new Set();
    function cP(e) {
      if (Oi && !rL())
        switch (e.tag) {
          case b:
          case G:
          case ue: {
            var r = fr && kt(fr) || "Unknown", s = r;
            if (!Xw.has(s)) {
              Xw.add(s);
              var c = kt(e) || "Unknown";
              p("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", c, r, r);
            }
            break;
          }
          case S: {
            R2 || (p("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), R2 = !0);
            break;
          }
        }
    }
    function Sv(e, r) {
      if (Br) {
        var s = e.memoizedUpdaters;
        s.forEach(function(c) {
          um(e, c, r);
        });
      }
    }
    var Qw = {};
    function Kw(e, r) {
      {
        var s = il.current;
        return s !== null ? (s.push(r), Qw) : yd(e, r);
      }
    }
    function O2(e) {
      if (e !== Qw)
        return Gy(e);
    }
    function A2() {
      return il.current !== null;
    }
    function fP(e) {
      {
        if (e.mode & Bt) {
          if (!l2())
            return;
        } else if (!M6() || en !== qr || e.tag !== b && e.tag !== G && e.tag !== ue)
          return;
        if (il.current === null) {
          var r = qn;
          try {
            yn(e), p(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, kt(e));
          } finally {
            r ? yn(e) : rr();
          }
        }
      }
    }
    function dP(e) {
      e.tag !== lc && l2() && il.current === null && p(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function xv(e) {
      p2 = e;
    }
    var Eo = null, zp = null, pP = function(e) {
      Eo = e;
    };
    function $p(e) {
      {
        if (Eo === null)
          return e;
        var r = Eo(e);
        return r === void 0 ? e : r.current;
      }
    }
    function Jw(e) {
      return $p(e);
    }
    function e_(e) {
      {
        if (Eo === null)
          return e;
        var r = Eo(e);
        if (r === void 0) {
          if (e != null && typeof e.render == "function") {
            var s = $p(e.render);
            if (e.render !== s) {
              var c = {
                $$typeof: Ye,
                render: s
              };
              return e.displayName !== void 0 && (c.displayName = e.displayName), c;
            }
          }
          return e;
        }
        return r.current;
      }
    }
    function D2(e, r) {
      {
        if (Eo === null)
          return !1;
        var s = e.elementType, c = r.type, h = !1, y = typeof c == "object" && c !== null ? c.$$typeof : null;
        switch (e.tag) {
          case S: {
            typeof c == "function" && (h = !0);
            break;
          }
          case b: {
            (typeof c == "function" || y === ft) && (h = !0);
            break;
          }
          case G: {
            (y === Ye || y === ft) && (h = !0);
            break;
          }
          case V:
          case ue: {
            (y === Lt || y === ft) && (h = !0);
            break;
          }
          default:
            return !1;
        }
        if (h) {
          var x = Eo(s);
          if (x !== void 0 && x === Eo(c))
            return !0;
        }
        return !1;
      }
    }
    function M2(e) {
      {
        if (Eo === null || typeof WeakSet != "function")
          return;
        zp === null && (zp = /* @__PURE__ */ new WeakSet()), zp.add(e);
      }
    }
    var hP = function(e, r) {
      {
        if (Eo === null)
          return;
        var s = r.staleFamilies, c = r.updatedFamilies;
        nu(), tu(function() {
          t_(e.current, c, s);
        });
      }
    }, mP = function(e, r) {
      {
        if (e.context !== qa)
          return;
        nu(), tu(function() {
          wv(r, e, null, null);
        });
      }
    };
    function t_(e, r, s) {
      {
        var c = e.alternate, h = e.child, y = e.sibling, x = e.tag, C = e.type, T = null;
        switch (x) {
          case b:
          case ue:
          case S:
            T = C;
            break;
          case G:
            T = C.render;
            break;
        }
        if (Eo === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var M = !1, P = !1;
        if (T !== null) {
          var Z = Eo(T);
          Z !== void 0 && (s.has(Z) ? P = !0 : r.has(Z) && (x === S ? P = !0 : M = !0));
        }
        if (zp !== null && (zp.has(e) || c !== null && zp.has(c)) && (P = !0), P && (e._debugNeedsRemount = !0), P || M) {
          var W = Oa(e, bt);
          W !== null && Qr(W, e, bt, Dn);
        }
        h !== null && !P && t_(h, r, s), y !== null && t_(y, r, s);
      }
    }
    var vP = function(e, r) {
      {
        var s = /* @__PURE__ */ new Set(), c = new Set(r.map(function(h) {
          return h.current;
        }));
        return n_(e.current, c, s), s;
      }
    };
    function n_(e, r, s) {
      {
        var c = e.child, h = e.sibling, y = e.tag, x = e.type, C = null;
        switch (y) {
          case b:
          case ue:
          case S:
            C = x;
            break;
          case G:
            C = x.render;
            break;
        }
        var T = !1;
        C !== null && r.has(C) && (T = !0), T ? yP(e, s) : c !== null && n_(c, r, s), h !== null && n_(h, r, s);
      }
    }
    function yP(e, r) {
      {
        var s = gP(e, r);
        if (s)
          return;
        for (var c = e; ; ) {
          switch (c.tag) {
            case k:
              r.add(c.stateNode);
              return;
            case R:
              r.add(c.stateNode.containerInfo);
              return;
            case w:
              r.add(c.stateNode.containerInfo);
              return;
          }
          if (c.return === null)
            throw new Error("Expected to reach root first.");
          c = c.return;
        }
      }
    }
    function gP(e, r) {
      for (var s = e, c = !1; ; ) {
        if (s.tag === k)
          c = !0, r.add(s.stateNode);
        else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === e)
          return c;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === e)
            return c;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return !1;
    }
    var r_;
    {
      r_ = !1;
      try {
        var N2 = Object.preventExtensions({});
      } catch {
        r_ = !0;
      }
    }
    function bP(e, r, s, c) {
      this.tag = e, this.key = s, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = r, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = c, this.flags = ct, this.subtreeFlags = ct, this.deletions = null, this.lanes = pe, this.childLanes = pe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !r_ && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ga = function(e, r, s, c) {
      return new bP(e, r, s, c);
    };
    function i_(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function SP(e) {
      return typeof e == "function" && !i_(e) && e.defaultProps === void 0;
    }
    function xP(e) {
      if (typeof e == "function")
        return i_(e) ? S : b;
      if (e != null) {
        var r = e.$$typeof;
        if (r === Ye)
          return G;
        if (r === Lt)
          return V;
      }
      return E;
    }
    function jf(e, r) {
      var s = e.alternate;
      s === null ? (s = Ga(e.tag, r, e.key, e.mode), s.elementType = e.elementType, s.type = e.type, s.stateNode = e.stateNode, s._debugSource = e._debugSource, s._debugOwner = e._debugOwner, s._debugHookTypes = e._debugHookTypes, s.alternate = e, e.alternate = s) : (s.pendingProps = r, s.type = e.type, s.flags = ct, s.subtreeFlags = ct, s.deletions = null, s.actualDuration = 0, s.actualStartTime = -1), s.flags = e.flags & Ur, s.childLanes = e.childLanes, s.lanes = e.lanes, s.child = e.child, s.memoizedProps = e.memoizedProps, s.memoizedState = e.memoizedState, s.updateQueue = e.updateQueue;
      var c = e.dependencies;
      switch (s.dependencies = c === null ? null : {
        lanes: c.lanes,
        firstContext: c.firstContext
      }, s.sibling = e.sibling, s.index = e.index, s.ref = e.ref, s.selfBaseDuration = e.selfBaseDuration, s.treeBaseDuration = e.treeBaseDuration, s._debugNeedsRemount = e._debugNeedsRemount, s.tag) {
        case E:
        case b:
        case ue:
          s.type = $p(e.type);
          break;
        case S:
          s.type = Jw(e.type);
          break;
        case G:
          s.type = e_(e.type);
          break;
      }
      return s;
    }
    function wP(e, r) {
      e.flags &= Ur | jn;
      var s = e.alternate;
      if (s === null)
        e.childLanes = pe, e.lanes = r, e.child = null, e.subtreeFlags = ct, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = s.childLanes, e.lanes = s.lanes, e.child = s.child, e.subtreeFlags = ct, e.deletions = null, e.memoizedProps = s.memoizedProps, e.memoizedState = s.memoizedState, e.updateQueue = s.updateQueue, e.type = s.type;
        var c = s.dependencies;
        e.dependencies = c === null ? null : {
          lanes: c.lanes,
          firstContext: c.firstContext
        }, e.selfBaseDuration = s.selfBaseDuration, e.treeBaseDuration = s.treeBaseDuration;
      }
      return e;
    }
    function _P(e, r, s) {
      var c;
      return e === Xg ? (c = Bt, r === !0 && (c |= Xn, c |= wa)) : c = ht, Br && (c |= vt), Ga(w, null, null, c);
    }
    function a_(e, r, s, c, h, y) {
      var x = E, C = e;
      if (typeof e == "function")
        i_(e) ? (x = S, C = Jw(C)) : C = $p(C);
      else if (typeof e == "string")
        x = k;
      else
        e:
          switch (e) {
            case Ki:
              return Sc(s.children, h, y, r);
            case ao:
              x = I, h |= Xn, (h & Bt) !== ht && (h |= wa);
              break;
            case U:
              return EP(s, h, y, r);
            case Dt:
              return CP(s, h, y, r);
            case Kt:
              return kP(s, h, y, r);
            case Nn:
              return L2(s, h, y, r);
            case Fr:
            case vr:
            case oo:
            case vu:
            case Mn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case ge:
                    x = q;
                    break e;
                  case ze:
                    x = H;
                    break e;
                  case Ye:
                    x = G, C = e_(C);
                    break e;
                  case Lt:
                    x = V;
                    break e;
                  case ft:
                    x = we, C = null;
                    break e;
                }
              var T = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (T += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var M = c ? kt(c) : null;
                M && (T += `

Check the render method of \`` + M + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + T));
            }
          }
      var P = Ga(x, s, r, h);
      return P.elementType = e, P.type = C, P.lanes = y, P._debugOwner = c, P;
    }
    function o_(e, r, s) {
      var c = null;
      c = e._owner;
      var h = e.type, y = e.key, x = e.props, C = a_(h, y, x, c, r, s);
      return C._debugSource = e._source, C._debugOwner = e._owner, C;
    }
    function Sc(e, r, s, c) {
      var h = Ga(z, e, c, r);
      return h.lanes = s, h;
    }
    function EP(e, r, s, c) {
      typeof e.id != "string" && p('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var h = Ga(te, e, c, r | vt);
      return h.elementType = U, h.lanes = s, h.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, h;
    }
    function CP(e, r, s, c) {
      var h = Ga(ee, e, c, r);
      return h.elementType = Dt, h.lanes = s, h;
    }
    function kP(e, r, s, c) {
      var h = Ga(xe, e, c, r);
      return h.elementType = Kt, h.lanes = s, h;
    }
    function L2(e, r, s, c) {
      var h = Ga(Pe, e, c, r);
      h.elementType = Nn, h.lanes = s;
      var y = {
        isHidden: !1
      };
      return h.stateNode = y, h;
    }
    function l_(e, r, s) {
      var c = Ga(N, e, null, r);
      return c.lanes = s, c;
    }
    function TP() {
      var e = Ga(k, null, null, ht);
      return e.elementType = "DELETED", e;
    }
    function RP(e) {
      var r = Ga(Le, null, null, ht);
      return r.stateNode = e, r;
    }
    function s_(e, r, s) {
      var c = e.children !== null ? e.children : [], h = Ga(R, c, e.key, r);
      return h.lanes = s, h.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, h;
    }
    function P2(e, r) {
      return e === null && (e = Ga(E, null, null, ht)), e.tag = r.tag, e.key = r.key, e.elementType = r.elementType, e.type = r.type, e.stateNode = r.stateNode, e.return = r.return, e.child = r.child, e.sibling = r.sibling, e.index = r.index, e.ref = r.ref, e.pendingProps = r.pendingProps, e.memoizedProps = r.memoizedProps, e.updateQueue = r.updateQueue, e.memoizedState = r.memoizedState, e.dependencies = r.dependencies, e.mode = r.mode, e.flags = r.flags, e.subtreeFlags = r.subtreeFlags, e.deletions = r.deletions, e.lanes = r.lanes, e.childLanes = r.childLanes, e.alternate = r.alternate, e.actualDuration = r.actualDuration, e.actualStartTime = r.actualStartTime, e.selfBaseDuration = r.selfBaseDuration, e.treeBaseDuration = r.treeBaseDuration, e._debugSource = r._debugSource, e._debugOwner = r._debugOwner, e._debugNeedsRemount = r._debugNeedsRemount, e._debugHookTypes = r._debugHookTypes, e;
    }
    function OP(e, r, s, c, h) {
      this.tag = r, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = H1, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Jt, this.eventTimes = Wd(pe), this.expirationTimes = Wd(Dn), this.pendingLanes = pe, this.suspendedLanes = pe, this.pingedLanes = pe, this.expiredLanes = pe, this.mutableReadLanes = pe, this.finishedLanes = pe, this.entangledLanes = pe, this.entanglements = Wd(pe), this.identifierPrefix = c, this.onRecoverableError = h, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var y = this.pendingUpdatersLaneMap = [], x = 0; x < Fn; x++)
          y.push(/* @__PURE__ */ new Set());
      }
      switch (r) {
        case Xg:
          this._debugRootType = s ? "hydrateRoot()" : "createRoot()";
          break;
        case lc:
          this._debugRootType = s ? "hydrate()" : "render()";
          break;
      }
    }
    function z2(e, r, s, c, h, y, x, C, T, M) {
      var P = new OP(e, r, s, C, T), Z = _P(r, y);
      P.current = Z, Z.stateNode = P;
      {
        var W = {
          element: c,
          isDehydrated: s,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        Z.memoizedState = W;
      }
      return vx(Z), P;
    }
    var u_ = "18.2.0";
    function AP(e, r, s) {
      var c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Ir(c), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: di,
        key: c == null ? null : "" + c,
        children: e,
        containerInfo: r,
        implementation: s
      };
    }
    var c_, f_;
    c_ = !1, f_ = {};
    function $2(e) {
      if (!e)
        return qa;
      var r = ya(e), s = pN(r);
      if (r.tag === S) {
        var c = r.type;
        if (Gl(c))
          return uk(r, c, s);
      }
      return s;
    }
    function DP(e, r) {
      {
        var s = ya(e);
        if (s === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var c = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + c);
        }
        var h = xa(s);
        if (h === null)
          return null;
        if (h.mode & Xn) {
          var y = kt(s) || "Component";
          if (!f_[y]) {
            f_[y] = !0;
            var x = qn;
            try {
              yn(h), s.mode & Xn ? p("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, y) : p("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, y);
            } finally {
              x ? yn(x) : rr();
            }
          }
        }
        return h.stateNode;
      }
    }
    function j2(e, r, s, c, h, y, x, C) {
      var T = !1, M = null;
      return z2(e, r, T, M, s, c, h, y, x);
    }
    function I2(e, r, s, c, h, y, x, C, T, M) {
      var P = !0, Z = z2(s, c, P, e, h, y, x, C, T);
      Z.context = $2(null);
      var W = Z.current, ne = la(), ie = gc(W), fe = Qs(ne, ie);
      return fe.callback = r ?? null, cc(W, fe, ie), j6(Z, ie, ne), Z;
    }
    function wv(e, r, s, c) {
      Qy(r, e);
      var h = r.current, y = la(), x = gc(h);
      Ts(x);
      var C = $2(s);
      r.context === null ? r.context = C : r.pendingContext = C, Oi && qn !== null && !c_ && (c_ = !0, p(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, kt(qn) || "Unknown"));
      var T = Qs(y, x);
      T.payload = {
        element: e
      }, c = c === void 0 ? null : c, c !== null && (typeof c != "function" && p("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", c), T.callback = c);
      var M = cc(h, T, x);
      return M !== null && (Qr(M, h, x, y), u0(M, h, x)), x;
    }
    function eb(e) {
      var r = e.current;
      if (!r.child)
        return null;
      switch (r.child.tag) {
        case k:
          return r.child.stateNode;
        default:
          return r.child.stateNode;
      }
    }
    function MP(e) {
      switch (e.tag) {
        case w: {
          var r = e.stateNode;
          if (Er(r)) {
            var s = u1(r);
            B6(r, s);
          }
          break;
        }
        case ee: {
          tu(function() {
            var h = Oa(e, bt);
            if (h !== null) {
              var y = la();
              Qr(h, e, bt, y);
            }
          });
          var c = bt;
          d_(e, c);
          break;
        }
      }
    }
    function F2(e, r) {
      var s = e.memoizedState;
      s !== null && s.dehydrated !== null && (s.retryLane = ug(s.retryLane, r));
    }
    function d_(e, r) {
      F2(e, r);
      var s = e.alternate;
      s && F2(s, r);
    }
    function NP(e) {
      if (e.tag === ee) {
        var r = Iu, s = Oa(e, r);
        if (s !== null) {
          var c = la();
          Qr(s, e, r, c);
        }
        d_(e, r);
      }
    }
    function LP(e) {
      if (e.tag === ee) {
        var r = gc(e), s = Oa(e, r);
        if (s !== null) {
          var c = la();
          Qr(s, e, r, c);
        }
        d_(e, r);
      }
    }
    function U2(e) {
      var r = qy(e);
      return r === null ? null : r.stateNode;
    }
    var B2 = function(e) {
      return null;
    };
    function PP(e) {
      return B2(e);
    }
    var H2 = function(e) {
      return !1;
    };
    function zP(e) {
      return H2(e);
    }
    var V2 = null, W2 = null, Y2 = null, Z2 = null, q2 = null, G2 = null, X2 = null, Q2 = null, K2 = null;
    {
      var J2 = function(e, r, s) {
        var c = r[s], h = Qt(e) ? e.slice() : Ft({}, e);
        return s + 1 === r.length ? (Qt(h) ? h.splice(c, 1) : delete h[c], h) : (h[c] = J2(e[c], r, s + 1), h);
      }, eR = function(e, r) {
        return J2(e, r, 0);
      }, tR = function(e, r, s, c) {
        var h = r[c], y = Qt(e) ? e.slice() : Ft({}, e);
        if (c + 1 === r.length) {
          var x = s[c];
          y[x] = y[h], Qt(y) ? y.splice(h, 1) : delete y[h];
        } else
          y[h] = tR(
            // $FlowFixMe number or string is fine here
            e[h],
            r,
            s,
            c + 1
          );
        return y;
      }, nR = function(e, r, s) {
        if (r.length !== s.length) {
          f("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var c = 0; c < s.length - 1; c++)
            if (r[c] !== s[c]) {
              f("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return tR(e, r, s, 0);
      }, rR = function(e, r, s, c) {
        if (s >= r.length)
          return c;
        var h = r[s], y = Qt(e) ? e.slice() : Ft({}, e);
        return y[h] = rR(e[h], r, s + 1, c), y;
      }, iR = function(e, r, s) {
        return rR(e, r, 0, s);
      }, p_ = function(e, r) {
        for (var s = e.memoizedState; s !== null && r > 0; )
          s = s.next, r--;
        return s;
      };
      V2 = function(e, r, s, c) {
        var h = p_(e, r);
        if (h !== null) {
          var y = iR(h.memoizedState, s, c);
          h.memoizedState = y, h.baseState = y, e.memoizedProps = Ft({}, e.memoizedProps);
          var x = Oa(e, bt);
          x !== null && Qr(x, e, bt, Dn);
        }
      }, W2 = function(e, r, s) {
        var c = p_(e, r);
        if (c !== null) {
          var h = eR(c.memoizedState, s);
          c.memoizedState = h, c.baseState = h, e.memoizedProps = Ft({}, e.memoizedProps);
          var y = Oa(e, bt);
          y !== null && Qr(y, e, bt, Dn);
        }
      }, Y2 = function(e, r, s, c) {
        var h = p_(e, r);
        if (h !== null) {
          var y = nR(h.memoizedState, s, c);
          h.memoizedState = y, h.baseState = y, e.memoizedProps = Ft({}, e.memoizedProps);
          var x = Oa(e, bt);
          x !== null && Qr(x, e, bt, Dn);
        }
      }, Z2 = function(e, r, s) {
        e.pendingProps = iR(e.memoizedProps, r, s), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var c = Oa(e, bt);
        c !== null && Qr(c, e, bt, Dn);
      }, q2 = function(e, r) {
        e.pendingProps = eR(e.memoizedProps, r), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var s = Oa(e, bt);
        s !== null && Qr(s, e, bt, Dn);
      }, G2 = function(e, r, s) {
        e.pendingProps = nR(e.memoizedProps, r, s), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var c = Oa(e, bt);
        c !== null && Qr(c, e, bt, Dn);
      }, X2 = function(e) {
        var r = Oa(e, bt);
        r !== null && Qr(r, e, bt, Dn);
      }, Q2 = function(e) {
        B2 = e;
      }, K2 = function(e) {
        H2 = e;
      };
    }
    function $P(e) {
      var r = xa(e);
      return r === null ? null : r.stateNode;
    }
    function jP(e) {
      return null;
    }
    function IP() {
      return qn;
    }
    function FP(e) {
      var r = e.findFiberByHostInstance, s = i.ReactCurrentDispatcher;
      return Gh({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: V2,
        overrideHookStateDeletePath: W2,
        overrideHookStateRenamePath: Y2,
        overrideProps: Z2,
        overridePropsDeletePath: q2,
        overridePropsRenamePath: G2,
        setErrorHandler: Q2,
        setSuspenseHandler: K2,
        scheduleUpdate: X2,
        currentDispatcherRef: s,
        findHostInstanceByFiber: $P,
        findFiberByHostInstance: r || jP,
        // React Refresh
        findHostInstancesForRefresh: vP,
        scheduleRefresh: hP,
        scheduleRoot: mP,
        setRefreshHandler: pP,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: IP,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: u_
      });
    }
    var aR = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function h_(e) {
      this._internalRoot = e;
    }
    tb.prototype.render = h_.prototype.render = function(e) {
      var r = this._internalRoot;
      if (r === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? p("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : nb(arguments[1]) ? p("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && p("You passed a second argument to root.render(...) but it only accepts one argument.");
        var s = r.containerInfo;
        if (s.nodeType !== yr) {
          var c = U2(r.current);
          c && c.parentNode !== s && p("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      wv(e, r, null, null);
    }, tb.prototype.unmount = h_.prototype.unmount = function() {
      typeof arguments[0] == "function" && p("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var r = e.containerInfo;
        y2() && p("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), tu(function() {
          wv(null, e, null, null);
        }), ik(r);
      }
    };
    function UP(e, r) {
      if (!nb(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      oR(e);
      var s = !1, c = !1, h = "", y = aR;
      r != null && (r.hydrate ? f("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof r == "object" && r !== null && r.$$typeof === io && p(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), r.unstable_strictMode === !0 && (s = !0), r.identifierPrefix !== void 0 && (h = r.identifierPrefix), r.onRecoverableError !== void 0 && (y = r.onRecoverableError), r.transitionCallbacks !== void 0 && r.transitionCallbacks);
      var x = j2(e, Xg, null, s, c, h, y);
      Hg(x.current, e);
      var C = e.nodeType === yr ? e.parentNode : e;
      return Am(C), new h_(x);
    }
    function tb(e) {
      this._internalRoot = e;
    }
    function BP(e) {
      e && yg(e);
    }
    tb.prototype.unstable_scheduleHydration = BP;
    function HP(e, r, s) {
      if (!nb(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      oR(e), r === void 0 && p("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var c = s ?? null, h = s != null && s.hydratedSources || null, y = !1, x = !1, C = "", T = aR;
      s != null && (s.unstable_strictMode === !0 && (y = !0), s.identifierPrefix !== void 0 && (C = s.identifierPrefix), s.onRecoverableError !== void 0 && (T = s.onRecoverableError));
      var M = I2(r, null, e, Xg, c, y, x, C, T);
      if (Hg(M.current, e), Am(e), h)
        for (var P = 0; P < h.length; P++) {
          var Z = h[P];
          QN(M, Z);
        }
      return new tb(M);
    }
    function nb(e) {
      return !!(e && (e.nodeType === Di || e.nodeType === Ha || e.nodeType === gs || !De));
    }
    function _v(e) {
      return !!(e && (e.nodeType === Di || e.nodeType === Ha || e.nodeType === gs || e.nodeType === yr && e.nodeValue === " react-mount-point-unstable "));
    }
    function oR(e) {
      e.nodeType === Di && e.tagName && e.tagName.toUpperCase() === "BODY" && p("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Um(e) && (e._reactRootContainer ? p("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : p("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var VP = i.ReactCurrentOwner, lR;
    lR = function(e) {
      if (e._reactRootContainer && e.nodeType !== yr) {
        var r = U2(e._reactRootContainer.current);
        r && r.parentNode !== e && p("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var s = !!e._reactRootContainer, c = m_(e), h = !!(c && ac(c));
      h && !s && p("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === Di && e.tagName && e.tagName.toUpperCase() === "BODY" && p("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function m_(e) {
      return e ? e.nodeType === Ha ? e.documentElement : e.firstChild : null;
    }
    function sR() {
    }
    function WP(e, r, s, c, h) {
      if (h) {
        if (typeof c == "function") {
          var y = c;
          c = function() {
            var W = eb(x);
            y.call(W);
          };
        }
        var x = I2(
          r,
          c,
          e,
          lc,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          sR
        );
        e._reactRootContainer = x, Hg(x.current, e);
        var C = e.nodeType === yr ? e.parentNode : e;
        return Am(C), tu(), x;
      } else {
        for (var T; T = e.lastChild; )
          e.removeChild(T);
        if (typeof c == "function") {
          var M = c;
          c = function() {
            var W = eb(P);
            M.call(W);
          };
        }
        var P = j2(
          e,
          lc,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          sR
        );
        e._reactRootContainer = P, Hg(P.current, e);
        var Z = e.nodeType === yr ? e.parentNode : e;
        return Am(Z), tu(function() {
          wv(r, P, s, c);
        }), P;
      }
    }
    function YP(e, r) {
      e !== null && typeof e != "function" && p("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e);
    }
    function rb(e, r, s, c, h) {
      lR(s), YP(h === void 0 ? null : h, "render");
      var y = s._reactRootContainer, x;
      if (!y)
        x = WP(s, r, e, h, c);
      else {
        if (x = y, typeof h == "function") {
          var C = h;
          h = function() {
            var T = eb(x);
            C.call(T);
          };
        }
        wv(r, x, e, h);
      }
      return eb(x);
    }
    function ZP(e) {
      {
        var r = VP.current;
        if (r !== null && r.stateNode !== null) {
          var s = r.stateNode._warnedAboutRefsInRender;
          s || p("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", on(r.type) || "A component"), r.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === Di ? e : DP(e, "findDOMNode");
    }
    function qP(e, r, s) {
      if (p("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !_v(r))
        throw new Error("Target container is not a DOM element.");
      {
        var c = Um(r) && r._reactRootContainer === void 0;
        c && p("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return rb(null, e, r, !0, s);
    }
    function GP(e, r, s) {
      if (p("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !_v(r))
        throw new Error("Target container is not a DOM element.");
      {
        var c = Um(r) && r._reactRootContainer === void 0;
        c && p("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return rb(null, e, r, !1, s);
    }
    function XP(e, r, s, c) {
      if (p("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !_v(s))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !Qc(e))
        throw new Error("parentComponent must be a valid React Component");
      return rb(e, r, s, !1, c);
    }
    function QP(e) {
      if (!_v(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var r = Um(e) && e._reactRootContainer === void 0;
        r && p("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var s = m_(e), c = s && !ac(s);
          c && p("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return tu(function() {
          rb(null, null, e, !1, function() {
            e._reactRootContainer = null, ik(e);
          });
        }), !0;
      } else {
        {
          var h = m_(e), y = !!(h && ac(h)), x = e.nodeType === Di && _v(e.parentNode) && !!e.parentNode._reactRootContainer;
          y && p("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", x ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Ke(MP), fg(NP), pf(LP), dm(Ea), pg(cf), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && p("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Wy(eM), dd(Yw, H6, tu);
    function KP(e, r) {
      var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!nb(r))
        throw new Error("Target container is not a DOM element.");
      return AP(e, r, null, s);
    }
    function JP(e, r, s, c) {
      return XP(e, r, s, c);
    }
    var v_ = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [ac, hp, Vg, fd, qc, Yw]
    };
    function e5(e, r) {
      return v_.usingClientEntryPoint || p('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), UP(e, r);
    }
    function t5(e, r, s) {
      return v_.usingClientEntryPoint || p('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), HP(e, r, s);
    }
    function n5(e) {
      return y2() && p("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), tu(e);
    }
    var r5 = FP({
      findFiberByHostInstance: _f,
      bundleType: 1,
      version: u_,
      rendererPackageName: "react-dom"
    });
    if (!r5 && zn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var uR = window.location.protocol;
      /^(https?|file):$/.test(uR) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (uR === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    La.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = v_, La.createPortal = KP, La.createRoot = e5, La.findDOMNode = ZP, La.flushSync = n5, La.hydrate = qP, La.hydrateRoot = t5, La.render = GP, La.unmountComponentAtNode = QP, La.unstable_batchedUpdates = Yw, La.unstable_renderSubtreeIntoContainer = JP, La.version = u_, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), La;
}
function x4() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(x4);
    } catch (t) {
      console.error(t);
    }
  }
}
process.env.NODE_ENV === "production" ? (x4(), eE.exports = y5()) : eE.exports = g5();
var DS = eE.exports;
const b5 = /* @__PURE__ */ jE(DS);
function S5(t, n) {
  typeof t == "function" ? t(n) : t != null && (t.current = n);
}
function w4(...t) {
  return (n) => t.forEach(
    (i) => S5(i, n)
  );
}
function no(...t) {
  return L.useCallback(w4(...t), t);
}
const MS = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { children: i, ...o } = t, u = L.Children.toArray(i), f = u.find(w5);
  if (f) {
    const p = f.props.children, v = u.map((b) => b === f ? L.Children.count(p) > 1 ? L.Children.only(null) : /* @__PURE__ */ L.isValidElement(p) ? p.props.children : null : b);
    return /* @__PURE__ */ L.createElement(tE, Wt({}, o, {
      ref: n
    }), /* @__PURE__ */ L.isValidElement(p) ? /* @__PURE__ */ L.cloneElement(p, void 0, v) : null);
  }
  return /* @__PURE__ */ L.createElement(tE, Wt({}, o, {
    ref: n
  }), i);
});
MS.displayName = "Slot";
const tE = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { children: i, ...o } = t;
  return /* @__PURE__ */ L.isValidElement(i) ? /* @__PURE__ */ L.cloneElement(i, {
    ..._5(o, i.props),
    ref: n ? w4(n, i.ref) : i.ref
  }) : L.Children.count(i) > 1 ? L.Children.only(null) : null;
});
tE.displayName = "SlotClone";
const x5 = ({ children: t }) => /* @__PURE__ */ L.createElement(L.Fragment, null, t);
function w5(t) {
  return /* @__PURE__ */ L.isValidElement(t) && t.type === x5;
}
function _5(t, n) {
  const i = {
    ...n
  };
  for (const o in n) {
    const u = t[o], f = n[o];
    /^on[A-Z]/.test(o) ? u && f ? i[o] = (...v) => {
      f(...v), u(...v);
    } : u && (i[o] = u) : o === "style" ? i[o] = {
      ...u,
      ...f
    } : o === "className" && (i[o] = [
      u,
      f
    ].filter(Boolean).join(" "));
  }
  return {
    ...t,
    ...i
  };
}
const E5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], qi = E5.reduce((t, n) => {
  const i = /* @__PURE__ */ L.forwardRef((o, u) => {
    const { asChild: f, ...p } = o, v = f ? MS : n;
    return L.useEffect(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ L.createElement(v, Wt({}, p, {
      ref: u
    }));
  });
  return i.displayName = `Primitive.${n}`, {
    ...t,
    [n]: i
  };
}, {});
function C5(t, n) {
  t && DS.flushSync(
    () => t.dispatchEvent(n)
  );
}
const k5 = /* @__PURE__ */ L.forwardRef((t, n) => /* @__PURE__ */ L.createElement(qi.label, Wt({}, t, {
  ref: n,
  onMouseDown: (i) => {
    var o;
    (o = t.onMouseDown) === null || o === void 0 || o.call(t, i), !i.defaultPrevented && i.detail > 1 && i.preventDefault();
  }
}))), _4 = k5;
function E4(t) {
  var n, i, o = "";
  if (typeof t == "string" || typeof t == "number")
    o += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (n = 0; n < t.length; n++)
        t[n] && (i = E4(t[n])) && (o && (o += " "), o += i);
    else
      for (n in t)
        t[n] && (o && (o += " "), o += n);
  return o;
}
function T5() {
  for (var t, n, i = 0, o = ""; i < arguments.length; )
    (t = arguments[i++]) && (n = E4(t)) && (o && (o += " "), o += n);
  return o;
}
const xR = (t) => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, wR = T5, C4 = (t, n) => (i) => {
  var o;
  if ((n == null ? void 0 : n.variants) == null)
    return wR(t, i == null ? void 0 : i.class, i == null ? void 0 : i.className);
  const { variants: u, defaultVariants: f } = n, p = Object.keys(u).map((S) => {
    const E = i == null ? void 0 : i[S], w = f == null ? void 0 : f[S];
    if (E === null)
      return null;
    const R = xR(E) || xR(w);
    return u[S][R];
  }), v = i && Object.entries(i).reduce((S, E) => {
    let [w, R] = E;
    return R === void 0 || (S[w] = R), S;
  }, {}), b = n == null || (o = n.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((S, E) => {
    let { class: w, className: R, ...k } = E;
    return Object.entries(k).every((N) => {
      let [z, I] = N;
      return Array.isArray(I) ? I.includes({
        ...f,
        ...v
      }[z]) : {
        ...f,
        ...v
      }[z] === I;
    }) ? [
      ...S,
      w,
      R
    ] : S;
  }, []);
  return wR(t, p, b, i == null ? void 0 : i.class, i == null ? void 0 : i.className);
};
function k4(t) {
  var n, i, o = "";
  if (typeof t == "string" || typeof t == "number")
    o += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var u = t.length;
      for (n = 0; n < u; n++)
        t[n] && (i = k4(t[n])) && (o && (o += " "), o += i);
    } else
      for (i in t)
        t[i] && (o && (o += " "), o += i);
  return o;
}
function R5() {
  for (var t, n, i = 0, o = "", u = arguments.length; i < u; i++)
    (t = arguments[i]) && (n = k4(t)) && (o && (o += " "), o += n);
  return o;
}
const IE = "-";
function O5(t) {
  const n = D5(t), {
    conflictingClassGroups: i,
    conflictingClassGroupModifiers: o
  } = t;
  function u(p) {
    const v = p.split(IE);
    return v[0] === "" && v.length !== 1 && v.shift(), T4(v, n) || A5(p);
  }
  function f(p, v) {
    const b = i[p] || [];
    return v && o[p] ? [...b, ...o[p]] : b;
  }
  return {
    getClassGroupId: u,
    getConflictingClassGroupIds: f
  };
}
function T4(t, n) {
  var p;
  if (t.length === 0)
    return n.classGroupId;
  const i = t[0], o = n.nextPart.get(i), u = o ? T4(t.slice(1), o) : void 0;
  if (u)
    return u;
  if (n.validators.length === 0)
    return;
  const f = t.join(IE);
  return (p = n.validators.find(({
    validator: v
  }) => v(f))) == null ? void 0 : p.classGroupId;
}
const _R = /^\[(.+)\]$/;
function A5(t) {
  if (_R.test(t)) {
    const n = _R.exec(t)[1], i = n == null ? void 0 : n.substring(0, n.indexOf(":"));
    if (i)
      return "arbitrary.." + i;
  }
}
function D5(t) {
  const {
    theme: n,
    prefix: i
  } = t, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return N5(Object.entries(t.classGroups), i).forEach(([f, p]) => {
    nE(p, o, f, n);
  }), o;
}
function nE(t, n, i, o) {
  t.forEach((u) => {
    if (typeof u == "string") {
      const f = u === "" ? n : ER(n, u);
      f.classGroupId = i;
      return;
    }
    if (typeof u == "function") {
      if (M5(u)) {
        nE(u(o), n, i, o);
        return;
      }
      n.validators.push({
        validator: u,
        classGroupId: i
      });
      return;
    }
    Object.entries(u).forEach(([f, p]) => {
      nE(p, ER(n, f), i, o);
    });
  });
}
function ER(t, n) {
  let i = t;
  return n.split(IE).forEach((o) => {
    i.nextPart.has(o) || i.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), i = i.nextPart.get(o);
  }), i;
}
function M5(t) {
  return t.isThemeGetter;
}
function N5(t, n) {
  return n ? t.map(([i, o]) => {
    const u = o.map((f) => typeof f == "string" ? n + f : typeof f == "object" ? Object.fromEntries(Object.entries(f).map(([p, v]) => [n + p, v])) : f);
    return [i, u];
  }) : t;
}
function L5(t) {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let n = 0, i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  function u(f, p) {
    i.set(f, p), n++, n > t && (n = 0, o = i, i = /* @__PURE__ */ new Map());
  }
  return {
    get(f) {
      let p = i.get(f);
      if (p !== void 0)
        return p;
      if ((p = o.get(f)) !== void 0)
        return u(f, p), p;
    },
    set(f, p) {
      i.has(f) ? i.set(f, p) : u(f, p);
    }
  };
}
const R4 = "!";
function P5(t) {
  const n = t.separator, i = n.length === 1, o = n[0], u = n.length;
  return function(p) {
    const v = [];
    let b = 0, S = 0, E;
    for (let z = 0; z < p.length; z++) {
      let I = p[z];
      if (b === 0) {
        if (I === o && (i || p.slice(z, z + u) === n)) {
          v.push(p.slice(S, z)), S = z + u;
          continue;
        }
        if (I === "/") {
          E = z;
          continue;
        }
      }
      I === "[" ? b++ : I === "]" && b--;
    }
    const w = v.length === 0 ? p : p.substring(S), R = w.startsWith(R4), k = R ? w.substring(1) : w, N = E && E > S ? E - S : void 0;
    return {
      modifiers: v,
      hasImportantModifier: R,
      baseClassName: k,
      maybePostfixModifierPosition: N
    };
  };
}
function z5(t) {
  if (t.length <= 1)
    return t;
  const n = [];
  let i = [];
  return t.forEach((o) => {
    o[0] === "[" ? (n.push(...i.sort(), o), i = []) : i.push(o);
  }), n.push(...i.sort()), n;
}
function $5(t) {
  return {
    cache: L5(t.cacheSize),
    splitModifiers: P5(t),
    ...O5(t)
  };
}
const j5 = /\s+/;
function I5(t, n) {
  const {
    splitModifiers: i,
    getClassGroupId: o,
    getConflictingClassGroupIds: u
  } = n, f = /* @__PURE__ */ new Set();
  return t.trim().split(j5).map((p) => {
    const {
      modifiers: v,
      hasImportantModifier: b,
      baseClassName: S,
      maybePostfixModifierPosition: E
    } = i(p);
    let w = o(E ? S.substring(0, E) : S), R = !!E;
    if (!w) {
      if (!E)
        return {
          isTailwindClass: !1,
          originalClassName: p
        };
      if (w = o(S), !w)
        return {
          isTailwindClass: !1,
          originalClassName: p
        };
      R = !1;
    }
    const k = z5(v).join(":");
    return {
      isTailwindClass: !0,
      modifierId: b ? k + R4 : k,
      classGroupId: w,
      originalClassName: p,
      hasPostfixModifier: R
    };
  }).reverse().filter((p) => {
    if (!p.isTailwindClass)
      return !0;
    const {
      modifierId: v,
      classGroupId: b,
      hasPostfixModifier: S
    } = p, E = v + b;
    return f.has(E) ? !1 : (f.add(E), u(b, S).forEach((w) => f.add(v + w)), !0);
  }).reverse().map((p) => p.originalClassName).join(" ");
}
function F5() {
  let t = 0, n, i, o = "";
  for (; t < arguments.length; )
    (n = arguments[t++]) && (i = O4(n)) && (o && (o += " "), o += i);
  return o;
}
function O4(t) {
  if (typeof t == "string")
    return t;
  let n, i = "";
  for (let o = 0; o < t.length; o++)
    t[o] && (n = O4(t[o])) && (i && (i += " "), i += n);
  return i;
}
function U5(t, ...n) {
  let i, o, u, f = p;
  function p(b) {
    const S = n.reduce((E, w) => w(E), t());
    return i = $5(S), o = i.cache.get, u = i.cache.set, f = v, v(b);
  }
  function v(b) {
    const S = o(b);
    if (S)
      return S;
    const E = I5(b, i);
    return u(b, E), E;
  }
  return function() {
    return f(F5.apply(null, arguments));
  };
}
function Jn(t) {
  const n = (i) => i[t] || [];
  return n.isThemeGetter = !0, n;
}
const A4 = /^\[(?:([a-z-]+):)?(.+)\]$/i, B5 = /^\d+\/\d+$/, H5 = /* @__PURE__ */ new Set(["px", "full", "screen"]), V5 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, W5 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Y5 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Z5 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, q5 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function iu(t) {
  return Hf(t) || H5.has(t) || B5.test(t);
}
function xc(t) {
  return ph(t, "length", n8);
}
function Hf(t) {
  return !!t && !Number.isNaN(Number(t));
}
function ab(t) {
  return ph(t, "number", Hf);
}
function Tv(t) {
  return !!t && Number.isInteger(Number(t));
}
function G5(t) {
  return t.endsWith("%") && Hf(t.slice(0, -1));
}
function Ht(t) {
  return A4.test(t);
}
function wc(t) {
  return V5.test(t);
}
const X5 = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function Q5(t) {
  return ph(t, X5, D4);
}
function K5(t) {
  return ph(t, "position", D4);
}
const J5 = /* @__PURE__ */ new Set(["image", "url"]);
function e8(t) {
  return ph(t, J5, i8);
}
function t8(t) {
  return ph(t, "", r8);
}
function Rv() {
  return !0;
}
function ph(t, n, i) {
  const o = A4.exec(t);
  return o ? o[1] ? typeof n == "string" ? o[1] === n : n.has(o[1]) : i(o[2]) : !1;
}
function n8(t) {
  return W5.test(t) && !Y5.test(t);
}
function D4() {
  return !1;
}
function r8(t) {
  return Z5.test(t);
}
function i8(t) {
  return q5.test(t);
}
function a8() {
  const t = Jn("colors"), n = Jn("spacing"), i = Jn("blur"), o = Jn("brightness"), u = Jn("borderColor"), f = Jn("borderRadius"), p = Jn("borderSpacing"), v = Jn("borderWidth"), b = Jn("contrast"), S = Jn("grayscale"), E = Jn("hueRotate"), w = Jn("invert"), R = Jn("gap"), k = Jn("gradientColorStops"), N = Jn("gradientColorStopPositions"), z = Jn("inset"), I = Jn("margin"), H = Jn("opacity"), q = Jn("padding"), G = Jn("saturate"), te = Jn("scale"), ee = Jn("sepia"), V = Jn("skew"), ue = Jn("space"), we = Jn("translate"), me = () => ["auto", "contain", "none"], Le = () => ["auto", "hidden", "clip", "visible", "scroll"], xe = () => ["auto", Ht, n], ve = () => [Ht, n], Pe = () => ["", iu, xc], Ue = () => ["auto", Hf, Ht], We = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], at = () => ["solid", "dashed", "dotted", "double", "none"], Te = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"], ye = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Fe = () => ["", "0", Ht], O = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ce = () => [Hf, ab], De = () => [Hf, Ht];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Rv],
      spacing: [iu, xc],
      blur: ["none", "", wc, Ht],
      brightness: ce(),
      borderColor: [t],
      borderRadius: ["none", "", "full", wc, Ht],
      borderSpacing: ve(),
      borderWidth: Pe(),
      contrast: ce(),
      grayscale: Fe(),
      hueRotate: De(),
      invert: Fe(),
      gap: ve(),
      gradientColorStops: [t],
      gradientColorStopPositions: [G5, xc],
      inset: xe(),
      margin: xe(),
      opacity: ce(),
      padding: ve(),
      saturate: ce(),
      scale: ce(),
      sepia: Fe(),
      skew: De(),
      space: ve(),
      translate: ve()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ht]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [wc]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": O()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": O()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...We(), Ht]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: Le()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": Le()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": Le()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: me()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": me()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": me()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [z]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [z]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [z]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [z]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [z]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [z]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [z]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [z]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [z]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Tv, Ht]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: xe()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ht]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: Fe()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: Fe()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Tv, Ht]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Rv]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Tv, Ht]
        }, Ht]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Ue()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Ue()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Rv]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Tv, Ht]
        }, Ht]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Ue()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Ue()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ht]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ht]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [R]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [R]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [R]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...ye()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ye(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...ye(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [q]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [q]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [q]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [q]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [q]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [q]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [q]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [q]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [q]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [I]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [I]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [I]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [I]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [I]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [I]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [I]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [I]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [I]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [ue]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [ue]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ht, n]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ht, n, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ht, n, "none", "full", "min", "max", "fit", "prose", {
          screen: [wc]
        }, wc]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ht, n, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ht, n, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ht, n, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ht, n, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", wc, xc]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", ab]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Rv]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ht]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Hf, ab]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", iu, Ht]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ht]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ht]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [H]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [H]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...at(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", iu, xc]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", iu, Ht]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: ve()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ht]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ht]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [H]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...We(), K5]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Q5]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, e8]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [N]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [N]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [N]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [k]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [k]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [k]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [f]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [f]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [f]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [f]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [f]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [f]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [f]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [f]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [f]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [f]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [f]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [f]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [f]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [f]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [f]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [v]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [v]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [v]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [v]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [v]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [v]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [v]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [v]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [v]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [H]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...at(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [v]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [v]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [H]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: at()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [u]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [u]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [u]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [u]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [u]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [u]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [u]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [u]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...at()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [iu, Ht]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [iu, xc]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Pe()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [H]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [iu, xc]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", wc, t8]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Rv]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [H]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": Te()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": Te()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [i]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [b]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", wc, Ht]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [S]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [E]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [w]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [G]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [ee]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [i]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [b]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [S]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [E]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [w]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [H]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [G]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [ee]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [p]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [p]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [p]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ht]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: De()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ht]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: De()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ht]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [te]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [te]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [te]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Tv, Ht]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [we]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [we]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [V]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [V]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ht]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ht]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": ve()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": ve()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": ve()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": ve()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": ve()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": ve()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": ve()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": ve()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": ve()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": ve()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": ve()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": ve()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": ve()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": ve()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": ve()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": ve()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": ve()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": ve()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ht]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [iu, xc, ab]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
const o8 = /* @__PURE__ */ U5(a8);
function Kr(...t) {
  return o8(R5(t));
}
const l8 = C4(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
), qv = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  _4,
  {
    ref: i,
    className: Kr(l8(), t),
    ...n
  }
));
qv.displayName = _4.displayName;
const ah = L.forwardRef(
  ({ className: t, type: n, ...i }, o) => /* @__PURE__ */ oe.jsx(
    "input",
    {
      type: n,
      className: Kr(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        t
      ),
      ref: o,
      ...i
    }
  )
);
ah.displayName = "Input";
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var s8 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const u8 = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const NS = (t, n) => {
  const i = L.forwardRef(
    ({
      color: o = "currentColor",
      size: u = 24,
      strokeWidth: f = 2,
      absoluteStrokeWidth: p,
      className: v = "",
      children: b,
      ...S
    }, E) => L.createElement(
      "svg",
      {
        ref: E,
        ...s8,
        width: u,
        height: u,
        stroke: o,
        strokeWidth: p ? Number(f) * 24 / Number(u) : f,
        className: ["lucide", `lucide-${u8(t)}`, v].join(" "),
        ...S
      },
      [
        ...n.map(([w, R]) => L.createElement(w, R)),
        ...Array.isArray(b) ? b : [b]
      ]
    )
  );
  return i.displayName = `${t}`, i;
};
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const c8 = NS("EyeOff", [
  ["path", { d: "M9.88 9.88a3 3 0 1 0 4.24 4.24", key: "1jxqfv" }],
  [
    "path",
    {
      d: "M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68",
      key: "9wicm4"
    }
  ],
  [
    "path",
    { d: "M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61", key: "1jreej" }
  ],
  ["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }]
]);
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const f8 = NS("Eye", [
  ["path", { d: "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z", key: "rwhkz3" }],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const d8 = NS("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.363.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const p8 = NS("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), hy = L.forwardRef(
  ({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
    "textarea",
    {
      className: Kr(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        t
      ),
      ref: i,
      ...n
    }
  )
);
hy.displayName = "Textarea";
const h8 = C4(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Qp = L.forwardRef(
  ({ className: t, variant: n, size: i, asChild: o = !1, ...u }, f) => {
    const p = o ? MS : "button";
    return /* @__PURE__ */ oe.jsx(
      p,
      {
        className: Kr(h8({ variant: n, size: i, className: t })),
        ref: f,
        ...u
      }
    );
  }
);
Qp.displayName = "Button";
function Yi(t, n, { checkForDefaultPrevented: i = !0 } = {}) {
  return function(u) {
    if (t == null || t(u), i === !1 || !u.defaultPrevented)
      return n == null ? void 0 : n(u);
  };
}
function FE(t, n = []) {
  let i = [];
  function o(f, p) {
    const v = /* @__PURE__ */ L.createContext(p), b = i.length;
    i = [
      ...i,
      p
    ];
    function S(w) {
      const { scope: R, children: k, ...N } = w, z = (R == null ? void 0 : R[t][b]) || v, I = L.useMemo(
        () => N,
        Object.values(N)
      );
      return /* @__PURE__ */ L.createElement(z.Provider, {
        value: I
      }, k);
    }
    function E(w, R) {
      const k = (R == null ? void 0 : R[t][b]) || v, N = L.useContext(k);
      if (N)
        return N;
      if (p !== void 0)
        return p;
      throw new Error(`\`${w}\` must be used within \`${f}\``);
    }
    return S.displayName = f + "Provider", [
      S,
      E
    ];
  }
  const u = () => {
    const f = i.map((p) => /* @__PURE__ */ L.createContext(p));
    return function(v) {
      const b = (v == null ? void 0 : v[t]) || f;
      return L.useMemo(
        () => ({
          [`__scope${t}`]: {
            ...v,
            [t]: b
          }
        }),
        [
          v,
          b
        ]
      );
    };
  };
  return u.scopeName = t, [
    o,
    m8(u, ...n)
  ];
}
function m8(...t) {
  const n = t[0];
  if (t.length === 1)
    return n;
  const i = () => {
    const o = t.map(
      (u) => ({
        useScope: u(),
        scopeName: u.scopeName
      })
    );
    return function(f) {
      const p = o.reduce((v, { useScope: b, scopeName: S }) => {
        const w = b(f)[`__scope${S}`];
        return {
          ...v,
          ...w
        };
      }, {});
      return L.useMemo(
        () => ({
          [`__scope${n.scopeName}`]: p
        }),
        [
          p
        ]
      );
    };
  };
  return i.scopeName = n.scopeName, i;
}
const Gv = globalThis != null && globalThis.document ? L.useLayoutEffect : () => {
}, v8 = d5.useId || (() => {
});
let y8 = 0;
function b_(t) {
  const [n, i] = L.useState(v8());
  return Gv(() => {
    t || i(
      (o) => o ?? String(y8++)
    );
  }, [
    t
  ]), t || (n ? `radix-${n}` : "");
}
function za(t) {
  const n = L.useRef(t);
  return L.useEffect(() => {
    n.current = t;
  }), L.useMemo(
    () => (...i) => {
      var o;
      return (o = n.current) === null || o === void 0 ? void 0 : o.call(n, ...i);
    },
    []
  );
}
function M4({ prop: t, defaultProp: n, onChange: i = () => {
} }) {
  const [o, u] = g8({
    defaultProp: n,
    onChange: i
  }), f = t !== void 0, p = f ? t : o, v = za(i), b = L.useCallback((S) => {
    if (f) {
      const w = typeof S == "function" ? S(t) : S;
      w !== t && v(w);
    } else
      u(S);
  }, [
    f,
    t,
    u,
    v
  ]);
  return [
    p,
    b
  ];
}
function g8({ defaultProp: t, onChange: n }) {
  const i = L.useState(t), [o] = i, u = L.useRef(o), f = za(n);
  return L.useEffect(() => {
    u.current !== o && (f(o), u.current = o);
  }, [
    o,
    u,
    f
  ]), i;
}
function b8(t, n = globalThis == null ? void 0 : globalThis.document) {
  const i = za(t);
  L.useEffect(() => {
    const o = (u) => {
      u.key === "Escape" && i(u);
    };
    return n.addEventListener("keydown", o), () => n.removeEventListener("keydown", o);
  }, [
    i,
    n
  ]);
}
const rE = "dismissableLayer.update", S8 = "dismissableLayer.pointerDownOutside", x8 = "dismissableLayer.focusOutside";
let CR;
const w8 = /* @__PURE__ */ L.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), _8 = /* @__PURE__ */ L.forwardRef((t, n) => {
  var i;
  const { disableOutsidePointerEvents: o = !1, onEscapeKeyDown: u, onPointerDownOutside: f, onFocusOutside: p, onInteractOutside: v, onDismiss: b, ...S } = t, E = L.useContext(w8), [w, R] = L.useState(null), k = (i = w == null ? void 0 : w.ownerDocument) !== null && i !== void 0 ? i : globalThis == null ? void 0 : globalThis.document, [, N] = L.useState({}), z = no(
    n,
    (we) => R(we)
  ), I = Array.from(E.layers), [H] = [
    ...E.layersWithOutsidePointerEventsDisabled
  ].slice(-1), q = I.indexOf(H), G = w ? I.indexOf(w) : -1, te = E.layersWithOutsidePointerEventsDisabled.size > 0, ee = G >= q, V = E8((we) => {
    const me = we.target, Le = [
      ...E.branches
    ].some(
      (xe) => xe.contains(me)
    );
    !ee || Le || (f == null || f(we), v == null || v(we), we.defaultPrevented || b == null || b());
  }, k), ue = C8((we) => {
    const me = we.target;
    [
      ...E.branches
    ].some(
      (xe) => xe.contains(me)
    ) || (p == null || p(we), v == null || v(we), we.defaultPrevented || b == null || b());
  }, k);
  return b8((we) => {
    G === E.layers.size - 1 && (u == null || u(we), !we.defaultPrevented && b && (we.preventDefault(), b()));
  }, k), L.useEffect(() => {
    if (w)
      return o && (E.layersWithOutsidePointerEventsDisabled.size === 0 && (CR = k.body.style.pointerEvents, k.body.style.pointerEvents = "none"), E.layersWithOutsidePointerEventsDisabled.add(w)), E.layers.add(w), kR(), () => {
        o && E.layersWithOutsidePointerEventsDisabled.size === 1 && (k.body.style.pointerEvents = CR);
      };
  }, [
    w,
    k,
    o,
    E
  ]), L.useEffect(() => () => {
    w && (E.layers.delete(w), E.layersWithOutsidePointerEventsDisabled.delete(w), kR());
  }, [
    w,
    E
  ]), L.useEffect(() => {
    const we = () => N({});
    return document.addEventListener(rE, we), () => document.removeEventListener(rE, we);
  }, []), /* @__PURE__ */ L.createElement(qi.div, Wt({}, S, {
    ref: z,
    style: {
      pointerEvents: te ? ee ? "auto" : "none" : void 0,
      ...t.style
    },
    onFocusCapture: Yi(t.onFocusCapture, ue.onFocusCapture),
    onBlurCapture: Yi(t.onBlurCapture, ue.onBlurCapture),
    onPointerDownCapture: Yi(t.onPointerDownCapture, V.onPointerDownCapture)
  }));
});
function E8(t, n = globalThis == null ? void 0 : globalThis.document) {
  const i = za(t), o = L.useRef(!1), u = L.useRef(() => {
  });
  return L.useEffect(() => {
    const f = (v) => {
      if (v.target && !o.current) {
        let S = function() {
          N4(S8, i, b, {
            discrete: !0
          });
        };
        const b = {
          originalEvent: v
        };
        v.pointerType === "touch" ? (n.removeEventListener("click", u.current), u.current = S, n.addEventListener("click", u.current, {
          once: !0
        })) : S();
      } else
        n.removeEventListener("click", u.current);
      o.current = !1;
    }, p = window.setTimeout(() => {
      n.addEventListener("pointerdown", f);
    }, 0);
    return () => {
      window.clearTimeout(p), n.removeEventListener("pointerdown", f), n.removeEventListener("click", u.current);
    };
  }, [
    n,
    i
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => o.current = !0
  };
}
function C8(t, n = globalThis == null ? void 0 : globalThis.document) {
  const i = za(t), o = L.useRef(!1);
  return L.useEffect(() => {
    const u = (f) => {
      f.target && !o.current && N4(x8, i, {
        originalEvent: f
      }, {
        discrete: !1
      });
    };
    return n.addEventListener("focusin", u), () => n.removeEventListener("focusin", u);
  }, [
    n,
    i
  ]), {
    onFocusCapture: () => o.current = !0,
    onBlurCapture: () => o.current = !1
  };
}
function kR() {
  const t = new CustomEvent(rE);
  document.dispatchEvent(t);
}
function N4(t, n, i, { discrete: o }) {
  const u = i.originalEvent.target, f = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: i
  });
  n && u.addEventListener(t, n, {
    once: !0
  }), o ? C5(u, f) : u.dispatchEvent(f);
}
const S_ = "focusScope.autoFocusOnMount", x_ = "focusScope.autoFocusOnUnmount", TR = {
  bubbles: !1,
  cancelable: !0
}, k8 = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { loop: i = !1, trapped: o = !1, onMountAutoFocus: u, onUnmountAutoFocus: f, ...p } = t, [v, b] = L.useState(null), S = za(u), E = za(f), w = L.useRef(null), R = no(
    n,
    (z) => b(z)
  ), k = L.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  L.useEffect(() => {
    if (o) {
      let z = function(G) {
        if (k.paused || !v)
          return;
        const te = G.target;
        v.contains(te) ? w.current = te : Cc(w.current, {
          select: !0
        });
      }, I = function(G) {
        if (k.paused || !v)
          return;
        const te = G.relatedTarget;
        te !== null && (v.contains(te) || Cc(w.current, {
          select: !0
        }));
      }, H = function(G) {
        if (document.activeElement === document.body)
          for (const ee of G)
            ee.removedNodes.length > 0 && Cc(v);
      };
      document.addEventListener("focusin", z), document.addEventListener("focusout", I);
      const q = new MutationObserver(H);
      return v && q.observe(v, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", z), document.removeEventListener("focusout", I), q.disconnect();
      };
    }
  }, [
    o,
    v,
    k.paused
  ]), L.useEffect(() => {
    if (v) {
      OR.add(k);
      const z = document.activeElement;
      if (!v.contains(z)) {
        const H = new CustomEvent(S_, TR);
        v.addEventListener(S_, S), v.dispatchEvent(H), H.defaultPrevented || (T8(M8(L4(v)), {
          select: !0
        }), document.activeElement === z && Cc(v));
      }
      return () => {
        v.removeEventListener(S_, S), setTimeout(() => {
          const H = new CustomEvent(x_, TR);
          v.addEventListener(x_, E), v.dispatchEvent(H), H.defaultPrevented || Cc(z ?? document.body, {
            select: !0
          }), v.removeEventListener(x_, E), OR.remove(k);
        }, 0);
      };
    }
  }, [
    v,
    S,
    E,
    k
  ]);
  const N = L.useCallback((z) => {
    if (!i && !o || k.paused)
      return;
    const I = z.key === "Tab" && !z.altKey && !z.ctrlKey && !z.metaKey, H = document.activeElement;
    if (I && H) {
      const q = z.currentTarget, [G, te] = R8(q);
      G && te ? !z.shiftKey && H === te ? (z.preventDefault(), i && Cc(G, {
        select: !0
      })) : z.shiftKey && H === G && (z.preventDefault(), i && Cc(te, {
        select: !0
      })) : H === q && z.preventDefault();
    }
  }, [
    i,
    o,
    k.paused
  ]);
  return /* @__PURE__ */ L.createElement(qi.div, Wt({
    tabIndex: -1
  }, p, {
    ref: R,
    onKeyDown: N
  }));
});
function T8(t, { select: n = !1 } = {}) {
  const i = document.activeElement;
  for (const o of t)
    if (Cc(o, {
      select: n
    }), document.activeElement !== i)
      return;
}
function R8(t) {
  const n = L4(t), i = RR(n, t), o = RR(n.reverse(), t);
  return [
    i,
    o
  ];
}
function L4(t) {
  const n = [], i = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const u = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || u ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; i.nextNode(); )
    n.push(i.currentNode);
  return n;
}
function RR(t, n) {
  for (const i of t)
    if (!O8(i, {
      upTo: n
    }))
      return i;
}
function O8(t, { upTo: n }) {
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (n !== void 0 && t === n)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function A8(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Cc(t, { select: n = !1 } = {}) {
  if (t && t.focus) {
    const i = document.activeElement;
    t.focus({
      preventScroll: !0
    }), t !== i && A8(t) && n && t.select();
  }
}
const OR = D8();
function D8() {
  let t = [];
  return {
    add(n) {
      const i = t[0];
      n !== i && (i == null || i.pause()), t = AR(t, n), t.unshift(n);
    },
    remove(n) {
      var i;
      t = AR(t, n), (i = t[0]) === null || i === void 0 || i.resume();
    }
  };
}
function AR(t, n) {
  const i = [
    ...t
  ], o = i.indexOf(n);
  return o !== -1 && i.splice(o, 1), i;
}
function M8(t) {
  return t.filter(
    (n) => n.tagName !== "A"
  );
}
const N8 = /* @__PURE__ */ L.forwardRef((t, n) => {
  var i;
  const { container: o = globalThis == null || (i = globalThis.document) === null || i === void 0 ? void 0 : i.body, ...u } = t;
  return o ? /* @__PURE__ */ b5.createPortal(/* @__PURE__ */ L.createElement(qi.div, Wt({}, u, {
    ref: n
  })), o) : null;
});
function L8(t, n) {
  return L.useReducer((i, o) => {
    const u = n[i][o];
    return u ?? i;
  }, t);
}
const Mc = (t) => {
  const { present: n, children: i } = t, o = P8(n), u = typeof i == "function" ? i({
    present: o.isPresent
  }) : L.Children.only(i), f = no(o.ref, u.ref);
  return typeof i == "function" || o.isPresent ? /* @__PURE__ */ L.cloneElement(u, {
    ref: f
  }) : null;
};
Mc.displayName = "Presence";
function P8(t) {
  const [n, i] = L.useState(), o = L.useRef({}), u = L.useRef(t), f = L.useRef("none"), p = t ? "mounted" : "unmounted", [v, b] = L8(p, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return L.useEffect(() => {
    const S = ob(o.current);
    f.current = v === "mounted" ? S : "none";
  }, [
    v
  ]), Gv(() => {
    const S = o.current, E = u.current;
    if (E !== t) {
      const R = f.current, k = ob(S);
      t ? b("MOUNT") : k === "none" || (S == null ? void 0 : S.display) === "none" ? b("UNMOUNT") : b(E && R !== k ? "ANIMATION_OUT" : "UNMOUNT"), u.current = t;
    }
  }, [
    t,
    b
  ]), Gv(() => {
    if (n) {
      const S = (w) => {
        const k = ob(o.current).includes(w.animationName);
        w.target === n && k && DS.flushSync(
          () => b("ANIMATION_END")
        );
      }, E = (w) => {
        w.target === n && (f.current = ob(o.current));
      };
      return n.addEventListener("animationstart", E), n.addEventListener("animationcancel", S), n.addEventListener("animationend", S), () => {
        n.removeEventListener("animationstart", E), n.removeEventListener("animationcancel", S), n.removeEventListener("animationend", S);
      };
    } else
      b("ANIMATION_END");
  }, [
    n,
    b
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(v),
    ref: L.useCallback((S) => {
      S && (o.current = getComputedStyle(S)), i(S);
    }, [])
  };
}
function ob(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
let w_ = 0;
function z8() {
  L.useEffect(() => {
    var t, n;
    const i = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (t = i[0]) !== null && t !== void 0 ? t : DR()), document.body.insertAdjacentElement("beforeend", (n = i[1]) !== null && n !== void 0 ? n : DR()), w_++, () => {
      w_ === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (o) => o.remove()
      ), w_--;
    };
  }, []);
}
function DR() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t;
}
var ls = function() {
  return ls = Object.assign || function(n) {
    for (var i, o = 1, u = arguments.length; o < u; o++) {
      i = arguments[o];
      for (var f in i)
        Object.prototype.hasOwnProperty.call(i, f) && (n[f] = i[f]);
    }
    return n;
  }, ls.apply(this, arguments);
};
function P4(t, n) {
  var i = {};
  for (var o in t)
    Object.prototype.hasOwnProperty.call(t, o) && n.indexOf(o) < 0 && (i[o] = t[o]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var u = 0, o = Object.getOwnPropertySymbols(t); u < o.length; u++)
      n.indexOf(o[u]) < 0 && Object.prototype.propertyIsEnumerable.call(t, o[u]) && (i[o[u]] = t[o[u]]);
  return i;
}
function $8(t, n, i) {
  if (i || arguments.length === 2)
    for (var o = 0, u = n.length, f; o < u; o++)
      (f || !(o in n)) && (f || (f = Array.prototype.slice.call(n, 0, o)), f[o] = n[o]);
  return t.concat(f || Array.prototype.slice.call(n));
}
var bb = "right-scroll-bar-position", Sb = "width-before-scroll-bar", j8 = "with-scroll-bars-hidden", I8 = "--removed-body-scroll-bar-size";
function __(t, n) {
  return typeof t == "function" ? t(n) : t && (t.current = n), t;
}
function F8(t, n) {
  var i = L.useState(function() {
    return {
      // value
      value: t,
      // last callback
      callback: n,
      // "memoized" public interface
      facade: {
        get current() {
          return i.value;
        },
        set current(o) {
          var u = i.value;
          u !== o && (i.value = o, i.callback(o, u));
        }
      }
    };
  })[0];
  return i.callback = n, i.facade;
}
var U8 = typeof window < "u" ? L.useLayoutEffect : L.useEffect, MR = /* @__PURE__ */ new WeakMap();
function B8(t, n) {
  var i = F8(n || null, function(o) {
    return t.forEach(function(u) {
      return __(u, o);
    });
  });
  return U8(function() {
    var o = MR.get(i);
    if (o) {
      var u = new Set(o), f = new Set(t), p = i.current;
      u.forEach(function(v) {
        f.has(v) || __(v, null);
      }), f.forEach(function(v) {
        u.has(v) || __(v, p);
      });
    }
    MR.set(i, t);
  }, [t]), i;
}
function H8(t) {
  return t;
}
function V8(t, n) {
  n === void 0 && (n = H8);
  var i = [], o = !1, u = {
    read: function() {
      if (o)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return i.length ? i[i.length - 1] : t;
    },
    useMedium: function(f) {
      var p = n(f, o);
      return i.push(p), function() {
        i = i.filter(function(v) {
          return v !== p;
        });
      };
    },
    assignSyncMedium: function(f) {
      for (o = !0; i.length; ) {
        var p = i;
        i = [], p.forEach(f);
      }
      i = {
        push: function(v) {
          return f(v);
        },
        filter: function() {
          return i;
        }
      };
    },
    assignMedium: function(f) {
      o = !0;
      var p = [];
      if (i.length) {
        var v = i;
        i = [], v.forEach(f), p = i;
      }
      var b = function() {
        var E = p;
        p = [], E.forEach(f);
      }, S = function() {
        return Promise.resolve().then(b);
      };
      S(), i = {
        push: function(E) {
          p.push(E), S();
        },
        filter: function(E) {
          return p = p.filter(E), i;
        }
      };
    }
  };
  return u;
}
function W8(t) {
  t === void 0 && (t = {});
  var n = V8(null);
  return n.options = ls({ async: !0, ssr: !1 }, t), n;
}
var z4 = function(t) {
  var n = t.sideCar, i = P4(t, ["sideCar"]);
  if (!n)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var o = n.read();
  if (!o)
    throw new Error("Sidecar medium not found");
  return L.createElement(o, ls({}, i));
};
z4.isSideCarExport = !0;
function Y8(t, n) {
  return t.useMedium(n), z4;
}
var $4 = W8(), E_ = function() {
}, LS = L.forwardRef(function(t, n) {
  var i = L.useRef(null), o = L.useState({
    onScrollCapture: E_,
    onWheelCapture: E_,
    onTouchMoveCapture: E_
  }), u = o[0], f = o[1], p = t.forwardProps, v = t.children, b = t.className, S = t.removeScrollBar, E = t.enabled, w = t.shards, R = t.sideCar, k = t.noIsolation, N = t.inert, z = t.allowPinchZoom, I = t.as, H = I === void 0 ? "div" : I, q = P4(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), G = R, te = B8([i, n]), ee = ls(ls({}, q), u);
  return L.createElement(
    L.Fragment,
    null,
    E && L.createElement(G, { sideCar: $4, removeScrollBar: S, shards: w, noIsolation: k, inert: N, setCallbacks: f, allowPinchZoom: !!z, lockRef: i }),
    p ? L.cloneElement(L.Children.only(v), ls(ls({}, ee), { ref: te })) : L.createElement(H, ls({}, ee, { className: b, ref: te }), v)
  );
});
LS.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
LS.classNames = {
  fullWidth: Sb,
  zeroRight: bb
};
var Z8 = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function q8() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var n = Z8();
  return n && t.setAttribute("nonce", n), t;
}
function G8(t, n) {
  t.styleSheet ? t.styleSheet.cssText = n : t.appendChild(document.createTextNode(n));
}
function X8(t) {
  var n = document.head || document.getElementsByTagName("head")[0];
  n.appendChild(t);
}
var Q8 = function() {
  var t = 0, n = null;
  return {
    add: function(i) {
      t == 0 && (n = q8()) && (G8(n, i), X8(n)), t++;
    },
    remove: function() {
      t--, !t && n && (n.parentNode && n.parentNode.removeChild(n), n = null);
    }
  };
}, K8 = function() {
  var t = Q8();
  return function(n, i) {
    L.useEffect(function() {
      return t.add(n), function() {
        t.remove();
      };
    }, [n && i]);
  };
}, j4 = function() {
  var t = K8(), n = function(i) {
    var o = i.styles, u = i.dynamic;
    return t(o, u), null;
  };
  return n;
}, J8 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, C_ = function(t) {
  return parseInt(t || "", 10) || 0;
}, ez = function(t) {
  var n = window.getComputedStyle(document.body), i = n[t === "padding" ? "paddingLeft" : "marginLeft"], o = n[t === "padding" ? "paddingTop" : "marginTop"], u = n[t === "padding" ? "paddingRight" : "marginRight"];
  return [C_(i), C_(o), C_(u)];
}, tz = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return J8;
  var n = ez(t), i = document.documentElement.clientWidth, o = window.innerWidth;
  return {
    left: n[0],
    top: n[1],
    right: n[2],
    gap: Math.max(0, o - i + n[2] - n[0])
  };
}, nz = j4(), Kp = "data-scroll-locked", rz = function(t, n, i, o) {
  var u = t.left, f = t.top, p = t.right, v = t.gap;
  return i === void 0 && (i = "margin"), `
  .`.concat(j8, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(v, "px ").concat(o, `;
  }
  body[`).concat(Kp, `] {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([
    n && "position: relative ".concat(o, ";"),
    i === "margin" && `
    padding-left: `.concat(u, `px;
    padding-top: `).concat(f, `px;
    padding-right: `).concat(p, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(v, "px ").concat(o, `;
    `),
    i === "padding" && "padding-right: ".concat(v, "px ").concat(o, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(bb, ` {
    right: `).concat(v, "px ").concat(o, `;
  }
  
  .`).concat(Sb, ` {
    margin-right: `).concat(v, "px ").concat(o, `;
  }
  
  .`).concat(bb, " .").concat(bb, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(Sb, " .").concat(Sb, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body[`).concat(Kp, `] {
    `).concat(I8, ": ").concat(v, `px;
  }
`);
}, NR = function() {
  var t = parseInt(document.body.getAttribute(Kp) || "0", 10);
  return isFinite(t) ? t : 0;
}, iz = function() {
  L.useEffect(function() {
    return document.body.setAttribute(Kp, (NR() + 1).toString()), function() {
      var t = NR() - 1;
      t <= 0 ? document.body.removeAttribute(Kp) : document.body.setAttribute(Kp, t.toString());
    };
  }, []);
}, az = function(t) {
  var n = t.noRelative, i = t.noImportant, o = t.gapMode, u = o === void 0 ? "margin" : o;
  iz();
  var f = L.useMemo(function() {
    return tz(u);
  }, [u]);
  return L.createElement(nz, { styles: rz(f, !n, u, i ? "" : "!important") });
}, iE = !1;
if (typeof window < "u")
  try {
    var lb = Object.defineProperty({}, "passive", {
      get: function() {
        return iE = !0, !0;
      }
    });
    window.addEventListener("test", lb, lb), window.removeEventListener("test", lb, lb);
  } catch {
    iE = !1;
  }
var Ip = iE ? { passive: !1 } : !1, oz = function(t) {
  return t.tagName === "TEXTAREA";
}, I4 = function(t, n) {
  var i = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    i[n] !== "hidden" && // contains scroll inside self
    !(i.overflowY === i.overflowX && !oz(t) && i[n] === "visible")
  );
}, lz = function(t) {
  return I4(t, "overflowY");
}, sz = function(t) {
  return I4(t, "overflowX");
}, LR = function(t, n) {
  var i = n;
  do {
    typeof ShadowRoot < "u" && i instanceof ShadowRoot && (i = i.host);
    var o = F4(t, i);
    if (o) {
      var u = U4(t, i), f = u[1], p = u[2];
      if (f > p)
        return !0;
    }
    i = i.parentNode;
  } while (i && i !== document.body);
  return !1;
}, uz = function(t) {
  var n = t.scrollTop, i = t.scrollHeight, o = t.clientHeight;
  return [
    n,
    i,
    o
  ];
}, cz = function(t) {
  var n = t.scrollLeft, i = t.scrollWidth, o = t.clientWidth;
  return [
    n,
    i,
    o
  ];
}, F4 = function(t, n) {
  return t === "v" ? lz(n) : sz(n);
}, U4 = function(t, n) {
  return t === "v" ? uz(n) : cz(n);
}, fz = function(t, n) {
  return t === "h" && n === "rtl" ? -1 : 1;
}, dz = function(t, n, i, o, u) {
  var f = fz(t, window.getComputedStyle(n).direction), p = f * o, v = i.target, b = n.contains(v), S = !1, E = p > 0, w = 0, R = 0;
  do {
    var k = U4(t, v), N = k[0], z = k[1], I = k[2], H = z - I - f * N;
    (N || H) && F4(t, v) && (w += H, R += N), v = v.parentNode;
  } while (
    // portaled content
    !b && v !== document.body || // self content
    b && (n.contains(v) || n === v)
  );
  return (E && (u && w === 0 || !u && p > w) || !E && (u && R === 0 || !u && -p > R)) && (S = !0), S;
}, sb = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, PR = function(t) {
  return [t.deltaX, t.deltaY];
}, zR = function(t) {
  return t && "current" in t ? t.current : t;
}, pz = function(t, n) {
  return t[0] === n[0] && t[1] === n[1];
}, hz = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, mz = 0, Fp = [];
function vz(t) {
  var n = L.useRef([]), i = L.useRef([0, 0]), o = L.useRef(), u = L.useState(mz++)[0], f = L.useState(function() {
    return j4();
  })[0], p = L.useRef(t);
  L.useEffect(function() {
    p.current = t;
  }, [t]), L.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(u));
      var z = $8([t.lockRef.current], (t.shards || []).map(zR), !0).filter(Boolean);
      return z.forEach(function(I) {
        return I.classList.add("allow-interactivity-".concat(u));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(u)), z.forEach(function(I) {
          return I.classList.remove("allow-interactivity-".concat(u));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var v = L.useCallback(function(z, I) {
    if ("touches" in z && z.touches.length === 2)
      return !p.current.allowPinchZoom;
    var H = sb(z), q = i.current, G = "deltaX" in z ? z.deltaX : q[0] - H[0], te = "deltaY" in z ? z.deltaY : q[1] - H[1], ee, V = z.target, ue = Math.abs(G) > Math.abs(te) ? "h" : "v";
    if ("touches" in z && ue === "h" && V.type === "range")
      return !1;
    var we = LR(ue, V);
    if (!we)
      return !0;
    if (we ? ee = ue : (ee = ue === "v" ? "h" : "v", we = LR(ue, V)), !we)
      return !1;
    if (!o.current && "changedTouches" in z && (G || te) && (o.current = ee), !ee)
      return !0;
    var me = o.current || ee;
    return dz(me, I, z, me === "h" ? G : te, !0);
  }, []), b = L.useCallback(function(z) {
    var I = z;
    if (!(!Fp.length || Fp[Fp.length - 1] !== f)) {
      var H = "deltaY" in I ? PR(I) : sb(I), q = n.current.filter(function(ee) {
        return ee.name === I.type && ee.target === I.target && pz(ee.delta, H);
      })[0];
      if (q && q.should) {
        I.cancelable && I.preventDefault();
        return;
      }
      if (!q) {
        var G = (p.current.shards || []).map(zR).filter(Boolean).filter(function(ee) {
          return ee.contains(I.target);
        }), te = G.length > 0 ? v(I, G[0]) : !p.current.noIsolation;
        te && I.cancelable && I.preventDefault();
      }
    }
  }, []), S = L.useCallback(function(z, I, H, q) {
    var G = { name: z, delta: I, target: H, should: q };
    n.current.push(G), setTimeout(function() {
      n.current = n.current.filter(function(te) {
        return te !== G;
      });
    }, 1);
  }, []), E = L.useCallback(function(z) {
    i.current = sb(z), o.current = void 0;
  }, []), w = L.useCallback(function(z) {
    S(z.type, PR(z), z.target, v(z, t.lockRef.current));
  }, []), R = L.useCallback(function(z) {
    S(z.type, sb(z), z.target, v(z, t.lockRef.current));
  }, []);
  L.useEffect(function() {
    return Fp.push(f), t.setCallbacks({
      onScrollCapture: w,
      onWheelCapture: w,
      onTouchMoveCapture: R
    }), document.addEventListener("wheel", b, Ip), document.addEventListener("touchmove", b, Ip), document.addEventListener("touchstart", E, Ip), function() {
      Fp = Fp.filter(function(z) {
        return z !== f;
      }), document.removeEventListener("wheel", b, Ip), document.removeEventListener("touchmove", b, Ip), document.removeEventListener("touchstart", E, Ip);
    };
  }, []);
  var k = t.removeScrollBar, N = t.inert;
  return L.createElement(
    L.Fragment,
    null,
    N ? L.createElement(f, { styles: hz(u) }) : null,
    k ? L.createElement(az, { gapMode: "margin" }) : null
  );
}
const yz = Y8($4, vz);
var B4 = L.forwardRef(function(t, n) {
  return L.createElement(LS, ls({}, t, { ref: n, sideCar: yz }));
});
B4.classNames = LS.classNames;
const gz = B4;
var bz = function(t) {
  if (typeof document > "u")
    return null;
  var n = Array.isArray(t) ? t[0] : t;
  return n.ownerDocument.body;
}, Up = /* @__PURE__ */ new WeakMap(), ub = /* @__PURE__ */ new WeakMap(), cb = {}, k_ = 0, H4 = function(t) {
  return t && (t.host || H4(t.parentNode));
}, Sz = function(t, n) {
  return n.map(function(i) {
    if (t.contains(i))
      return i;
    var o = H4(i);
    return o && t.contains(o) ? o : (console.error("aria-hidden", i, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(i) {
    return !!i;
  });
}, xz = function(t, n, i, o) {
  var u = Sz(n, Array.isArray(t) ? t : [t]);
  cb[i] || (cb[i] = /* @__PURE__ */ new WeakMap());
  var f = cb[i], p = [], v = /* @__PURE__ */ new Set(), b = new Set(u), S = function(w) {
    !w || v.has(w) || (v.add(w), S(w.parentNode));
  };
  u.forEach(S);
  var E = function(w) {
    !w || b.has(w) || Array.prototype.forEach.call(w.children, function(R) {
      if (v.has(R))
        E(R);
      else
        try {
          var k = R.getAttribute(o), N = k !== null && k !== "false", z = (Up.get(R) || 0) + 1, I = (f.get(R) || 0) + 1;
          Up.set(R, z), f.set(R, I), p.push(R), z === 1 && N && ub.set(R, !0), I === 1 && R.setAttribute(i, "true"), N || R.setAttribute(o, "true");
        } catch (H) {
          console.error("aria-hidden: cannot operate on ", R, H);
        }
    });
  };
  return E(n), v.clear(), k_++, function() {
    p.forEach(function(w) {
      var R = Up.get(w) - 1, k = f.get(w) - 1;
      Up.set(w, R), f.set(w, k), R || (ub.has(w) || w.removeAttribute(o), ub.delete(w)), k || w.removeAttribute(i);
    }), k_--, k_ || (Up = /* @__PURE__ */ new WeakMap(), Up = /* @__PURE__ */ new WeakMap(), ub = /* @__PURE__ */ new WeakMap(), cb = {});
  };
}, wz = function(t, n, i) {
  i === void 0 && (i = "data-aria-hidden");
  var o = Array.from(Array.isArray(t) ? t : [t]), u = n || bz(t);
  return u ? (o.push.apply(o, Array.from(u.querySelectorAll("[aria-live]"))), xz(o, u, i, "aria-hidden")) : function() {
    return null;
  };
};
const V4 = "Dialog", [W4, oV] = FE(V4), [_z, pl] = W4(V4), Ez = (t) => {
  const { __scopeDialog: n, children: i, open: o, defaultOpen: u, onOpenChange: f, modal: p = !0 } = t, v = L.useRef(null), b = L.useRef(null), [S = !1, E] = M4({
    prop: o,
    defaultProp: u,
    onChange: f
  });
  return /* @__PURE__ */ L.createElement(_z, {
    scope: n,
    triggerRef: v,
    contentRef: b,
    contentId: b_(),
    titleId: b_(),
    descriptionId: b_(),
    open: S,
    onOpenChange: E,
    onOpenToggle: L.useCallback(
      () => E(
        (w) => !w
      ),
      [
        E
      ]
    ),
    modal: p
  }, i);
}, Cz = "DialogTrigger", kz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeDialog: i, ...o } = t, u = pl(Cz, i), f = no(n, u.triggerRef);
  return /* @__PURE__ */ L.createElement(qi.button, Wt({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": u.open,
    "aria-controls": u.contentId,
    "data-state": UE(u.open)
  }, o, {
    ref: f,
    onClick: Yi(t.onClick, u.onOpenToggle)
  }));
}), Y4 = "DialogPortal", [Tz, Z4] = W4(Y4, {
  forceMount: void 0
}), Rz = (t) => {
  const { __scopeDialog: n, forceMount: i, children: o, container: u } = t, f = pl(Y4, n);
  return /* @__PURE__ */ L.createElement(Tz, {
    scope: n,
    forceMount: i
  }, L.Children.map(
    o,
    (p) => /* @__PURE__ */ L.createElement(Mc, {
      present: i || f.open
    }, /* @__PURE__ */ L.createElement(N8, {
      asChild: !0,
      container: u
    }, p))
  ));
}, aE = "DialogOverlay", Oz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const i = Z4(aE, t.__scopeDialog), { forceMount: o = i.forceMount, ...u } = t, f = pl(aE, t.__scopeDialog);
  return f.modal ? /* @__PURE__ */ L.createElement(Mc, {
    present: o || f.open
  }, /* @__PURE__ */ L.createElement(Az, Wt({}, u, {
    ref: n
  }))) : null;
}), Az = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeDialog: i, ...o } = t, u = pl(aE, i);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ L.createElement(gz, {
      as: MS,
      allowPinchZoom: !0,
      shards: [
        u.contentRef
      ]
    }, /* @__PURE__ */ L.createElement(qi.div, Wt({
      "data-state": UE(u.open)
    }, o, {
      ref: n,
      style: {
        pointerEvents: "auto",
        ...o.style
      }
    })))
  );
}), Xv = "DialogContent", Dz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const i = Z4(Xv, t.__scopeDialog), { forceMount: o = i.forceMount, ...u } = t, f = pl(Xv, t.__scopeDialog);
  return /* @__PURE__ */ L.createElement(Mc, {
    present: o || f.open
  }, f.modal ? /* @__PURE__ */ L.createElement(Mz, Wt({}, u, {
    ref: n
  })) : /* @__PURE__ */ L.createElement(Nz, Wt({}, u, {
    ref: n
  })));
}), Mz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const i = pl(Xv, t.__scopeDialog), o = L.useRef(null), u = no(n, i.contentRef, o);
  return L.useEffect(() => {
    const f = o.current;
    if (f)
      return wz(f);
  }, []), /* @__PURE__ */ L.createElement(q4, Wt({}, t, {
    ref: u,
    trapFocus: i.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: Yi(t.onCloseAutoFocus, (f) => {
      var p;
      f.preventDefault(), (p = i.triggerRef.current) === null || p === void 0 || p.focus();
    }),
    onPointerDownOutside: Yi(t.onPointerDownOutside, (f) => {
      const p = f.detail.originalEvent, v = p.button === 0 && p.ctrlKey === !0;
      (p.button === 2 || v) && f.preventDefault();
    }),
    onFocusOutside: Yi(
      t.onFocusOutside,
      (f) => f.preventDefault()
    )
  }));
}), Nz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const i = pl(Xv, t.__scopeDialog), o = L.useRef(!1), u = L.useRef(!1);
  return /* @__PURE__ */ L.createElement(q4, Wt({}, t, {
    ref: n,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (f) => {
      var p;
      if ((p = t.onCloseAutoFocus) === null || p === void 0 || p.call(t, f), !f.defaultPrevented) {
        var v;
        o.current || (v = i.triggerRef.current) === null || v === void 0 || v.focus(), f.preventDefault();
      }
      o.current = !1, u.current = !1;
    },
    onInteractOutside: (f) => {
      var p, v;
      (p = t.onInteractOutside) === null || p === void 0 || p.call(t, f), f.defaultPrevented || (o.current = !0, f.detail.originalEvent.type === "pointerdown" && (u.current = !0));
      const b = f.target;
      ((v = i.triggerRef.current) === null || v === void 0 ? void 0 : v.contains(b)) && f.preventDefault(), f.detail.originalEvent.type === "focusin" && u.current && f.preventDefault();
    }
  }));
}), q4 = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeDialog: i, trapFocus: o, onOpenAutoFocus: u, onCloseAutoFocus: f, ...p } = t, v = pl(Xv, i), b = L.useRef(null), S = no(n, b);
  return z8(), /* @__PURE__ */ L.createElement(L.Fragment, null, /* @__PURE__ */ L.createElement(k8, {
    asChild: !0,
    loop: !0,
    trapped: o,
    onMountAutoFocus: u,
    onUnmountAutoFocus: f
  }, /* @__PURE__ */ L.createElement(_8, Wt({
    role: "dialog",
    id: v.contentId,
    "aria-describedby": v.descriptionId,
    "aria-labelledby": v.titleId,
    "data-state": UE(v.open)
  }, p, {
    ref: S,
    onDismiss: () => v.onOpenChange(!1)
  }))), !1);
}), Lz = "DialogTitle", oE = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeDialog: i, ...o } = t, u = pl(Lz, i);
  return /* @__PURE__ */ L.createElement(qi.h2, Wt({
    id: u.titleId
  }, o, {
    ref: n
  }));
}), Pz = "DialogDescription", zz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeDialog: i, ...o } = t, u = pl(Pz, i);
  return /* @__PURE__ */ L.createElement(qi.p, Wt({
    id: u.descriptionId
  }, o, {
    ref: n
  }));
}), $z = "DialogClose", jz = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeDialog: i, ...o } = t, u = pl($z, i);
  return /* @__PURE__ */ L.createElement(qi.button, Wt({
    type: "button"
  }, o, {
    ref: n,
    onClick: Yi(
      t.onClick,
      () => u.onOpenChange(!1)
    )
  }));
});
function UE(t) {
  return t ? "open" : "closed";
}
const Iz = Ez, Fz = kz, Uz = Rz, G4 = Oz, X4 = Dz, Q4 = oE, K4 = zz, Bz = jz, Hz = Iz, Vz = Fz, Wz = Uz, J4 = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  G4,
  {
    ref: i,
    className: Kr(
      "fixed inset-0 z-50  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      t
    ),
    ...n
  }
));
J4.displayName = G4.displayName;
const eA = L.forwardRef(({ className: t, children: n, ...i }, o) => /* @__PURE__ */ oe.jsxs(Wz, { children: [
  /* @__PURE__ */ oe.jsx(J4, {}),
  /* @__PURE__ */ oe.jsxs(
    X4,
    {
      ref: o,
      className: Kr(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        t
      ),
      ...i,
      children: [
        n,
        /* @__PURE__ */ oe.jsxs(Bz, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ oe.jsx(p8, { className: "h-4 w-4" }),
          /* @__PURE__ */ oe.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
eA.displayName = X4.displayName;
const Qv = ({
  className: t,
  ...n
}) => /* @__PURE__ */ oe.jsx(
  "div",
  {
    className: Kr(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      t
    ),
    ...n
  }
);
Qv.displayName = "DialogHeader";
const BE = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  Q4,
  {
    ref: i,
    className: Kr(
      "text-lg font-semibold leading-none tracking-tight",
      t
    ),
    ...n
  }
));
BE.displayName = Q4.displayName;
const Yz = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  K4,
  {
    ref: i,
    className: Kr("text-sm text-muted-foreground", t),
    ...n
  }
));
Yz.displayName = K4.displayName;
const ss = {
  saveSchema(t) {
    if (!ss.di) {
      console.log(t);
      return;
    }
    const { pageState: n, initData: i } = ss.di.useCanvas(), o = {
      ...t,
      componentName: n.pageSchema.componentName
    };
    i(o, n.currentPage), ss.di.useHistory().addHistory();
  },
  getCurrentSchema: () => {
    var t;
    return (t = ss.di) == null ? void 0 : t.useCanvas().getCurrentSchema();
  },
  getPageSchema: () => {
    var t;
    return (t = ss.di) == null ? void 0 : t.useCanvas().getPageSchema();
  }
}, Zz = `# 任务描述\r
\r
- 作为一个低代码工具专家，输出符合 TinyEngine 低代码工具的 Typescript Interface IPageSchema 的 JSON 数据，实现应用布局和逻辑\r
- 不需要在代码中包含注释\r
- 不需要回答你的思路等文字描述，仅仅输出代码即可\r
- 尽量多使用 \`IPageSchema['css']\` 和 \`IComponentSchema['props']['style']\` 设置美观的样式，任何合法的 CSS 都是可用的\r
- 如果使用任何 image，请从 Unsplash 加载它们或使用纯色矩形作为占位符。\r
- 只对 div 组件设置 padding 和 margin 用于布局\r
- TinyEngine 低代码工具的 Typescript Interface 如下：\r
\r
\`\`\`ts\r
interface IPageSchema { // 页面 或 区块 schema\r
 css?: string; // 页面全局样式\r
 children?: Array< IComponentSchema > | string; // 子组件列表 或 文本字符串\r
}\r
\r
interface IComponentSchema { // 组件 schema\r
  componentName?: string;     // 组件名称\r
  id: string; // 一个语义化的组件 ID，保持唯一\r
  props?: { // 组件绑定的属性\r
      style?: string; // 组件 CSS 样式\r
      className?: string // 组件 class name，与 CSS 联动\r
      [prop:string]?: any; // 组件 props schema 具体参考以下组件使用文档\r
  };\r
  children?: Array< IComponentSchema >; // 嵌套 children，形成树状页面结构\r
}\r
\`\`\`\r
\r
## 组件使用文档\r
\r
每个 IComponentSchema 的 componentName 为以下列出组件之一，props 数据需符合为组件对应的 props schema\r
\r
### 组件 TinyCarousel\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyCarousel",\r
  "props": {\r
    "height": "180px"\r
  },\r
  "children": [\r
    {\r
      "componentName": "TinyCarouselItem",\r
      "children": [\r
        {\r
          "componentName": "div",\r
          "props": {\r
            "style": "margin:10px 0 0 30px"\r
          }\r
        }\r
      ]\r
    },\r
    {\r
      "componentName": "TinyCarouselItem",\r
      "children": [\r
        {\r
          "componentName": "div",\r
          "props": {\r
            "style": "margin:10px 0 0 30px"\r
          }\r
        }\r
      ]\r
    }\r
  ]\r
}\r
\`\`\`\r
\r
### 组件 Img\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "img",\r
  "props": {\r
    "src": "https://images.unsplash.com/photo-1588345921523-c2dcdb7f1dcd?w=200&h=100&dpr=2&q=80",\r
    "width": "200",\r
    "height": "100"\r
  }\r
}\r
\`\`\`\r
\r
### 组件 table\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "table",\r
  "props": {\r
    "border": "1"\r
  },\r
  "children": [\r
    {\r
      "componentName": "tr",\r
      "children": [\r
        {\r
          "componentName": "td",\r
          "children": [\r
            {\r
              "componentName": "p",\r
              "children": "Month"\r
            }\r
          ]\r
        },\r
        {\r
          "componentName": "td",\r
          "children": [\r
            {\r
              "componentName": "p",\r
              "children": "Savings"\r
            }\r
          ]\r
        }\r
      ]\r
    },\r
    {\r
      "componentName": "tr",\r
      "children": [\r
        {\r
          "componentName": "td",\r
          "children": [\r
            {\r
              "componentName": "p",\r
              "children": "January"\r
            }\r
          ]\r
        },\r
        {\r
          "componentName": "td",\r
          "children": [\r
            {\r
              "componentName": "p",\r
              "children": "100"\r
            }\r
          ]\r
        }\r
      ]\r
    }\r
  ]\r
}\r
\`\`\`\r
\r
### 组件 TinyRow\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyRow",\r
  "props": {},\r
  "children": [\r
    {\r
      "componentName": "TinyCol",\r
      "props": {\r
        "span": 3\r
      }\r
    },\r
    {\r
      "componentName": "TinyCol",\r
      "props": {\r
        "span": 3\r
      }\r
    },\r
    {\r
      "componentName": "TinyCol",\r
      "props": {\r
        "span": 3\r
      }\r
    },\r
    {\r
      "componentName": "TinyCol",\r
      "props": {\r
        "span": 3\r
      }\r
    }\r
  ]\r
}\r
\`\`\`\r
\r
### 组件 TinyButton\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyButton",\r
  "props": {\r
    "text": "按钮文案"\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyInput\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyInput",\r
  "props": {\r
    "placeholder": "请输入",\r
    "modelValue": ""\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyRadio\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyRadio",\r
  "props": {\r
    "label": "1",\r
    "text": "单选文本"\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinySelect\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinySelect",\r
  "props": {\r
    "modelValue": "",\r
    "placeholder": "请选择",\r
    "options": [\r
      {\r
        "value": "1",\r
        "label": "黄金糕"\r
      },\r
      {\r
        "value": "2",\r
        "label": "双皮奶"\r
      }\r
    ]\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinySwitch\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinySwitch",\r
  "props": {\r
    "modelValue": ""\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyCheckbox\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyCheckbox",\r
  "props": {\r
    "text": "复选框文案"\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyDialogBox\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyDialogBox",\r
  "props": {\r
    "visible": true,\r
    "show-close": true,\r
    "title": "dialogBox title"\r
  },\r
  "children": [\r
    {\r
      "componentName": "div"\r
    }\r
  ]\r
}\r
\`\`\`\r
\r
### 组件 TinyTabs\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyTabs",\r
  "props": {\r
    "modelValue": "first"\r
  },\r
  "children": [\r
    {\r
      "componentName": "TinyTabItem",\r
      "props": {\r
        "title": "标签页1",\r
        "name": "first"\r
      },\r
      "children": [\r
        {\r
          "componentName": "div",\r
          "props": {\r
            "style": "margin:10px 0 0 30px"\r
          }\r
        }\r
      ]\r
    },\r
    {\r
      "componentName": "TinyTabItem",\r
      "props": {\r
        "title": "标签页2",\r
        "name": "second"\r
      },\r
      "children": [\r
        {\r
          "componentName": "div",\r
          "props": {\r
            "style": "margin:10px 0 0 30px"\r
          }\r
        }\r
      ]\r
    }\r
  ]\r
}\r
\`\`\`\r
\r
### 组件 TinyBreadcrumb\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyBreadcrumb",\r
  "props": {\r
    "options": [\r
      {\r
        "to": "{ path: '/' }",\r
        "label": "首页"\r
      },\r
      {\r
        "to": "{ path: '/breadcrumb' }",\r
        "label": "产品"\r
      },\r
      {\r
        "replace": "true",\r
        "label": "软件"\r
      }\r
    ]\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyCollapse\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyCollapse",\r
  "props": {\r
    "modelValue": "collapse1"\r
  },\r
  "children": [\r
    {\r
      "componentName": "TinyCollapseItem",\r
      "props": {\r
        "name": "collapse1",\r
        "title": "折叠项1"\r
      },\r
      "children": [\r
        {\r
          "componentName": "div"\r
        }\r
      ]\r
    },\r
    {\r
      "componentName": "TinyCollapseItem",\r
      "props": {\r
        "name": "collapse2",\r
        "title": "折叠项2"\r
      },\r
      "children": [\r
        {\r
          "componentName": "div"\r
        }\r
      ]\r
    },\r
    {\r
      "componentName": "TinyCollapseItem",\r
      "props": {\r
        "name": "collapse3",\r
        "title": "折叠项3"\r
      },\r
      "children": [\r
        {\r
          "componentName": "div"\r
        }\r
      ]\r
    }\r
  ]\r
}\r
\`\`\`\r
\r
### 组件 TinyGrid\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyGrid",\r
  "props": {\r
    "editConfig": {\r
      "trigger": "click",\r
      "mode": "cell",\r
      "showStatus": true\r
    },\r
    "columns": [\r
      {\r
        "type": "index",\r
        "width": 60\r
      },\r
      {\r
        "type": "selection",\r
        "width": 60\r
      },\r
      {\r
        "field": "employees",\r
        "title": "员工数"\r
      },\r
      {\r
        "field": "created_date",\r
        "title": "创建日期"\r
      },\r
      {\r
        "field": "city",\r
        "title": "城市"\r
      }\r
    ],\r
    "data": [\r
      {\r
        "id": "1",\r
        "name": "GFD科技有限公司",\r
        "city": "福州",\r
        "employees": 800,\r
        "created_date": "2014-04-30 00:56:00",\r
        "boole": false\r
      },\r
      {\r
        "id": "2",\r
        "name": "WWW科技有限公司",\r
        "city": "深圳",\r
        "employees": 300,\r
        "created_date": "2016-07-08 12:36:22",\r
        "boole": true\r
      }\r
    ]\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyPager\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyPager",\r
  "props": {\r
    "layout": "total, sizes, prev, pager, next",\r
    "total": 100,\r
    "pageSize": 10,\r
    "currentPage": 1\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyTree\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyTree",\r
  "props": {\r
    "data": [\r
      {\r
        "label": "一级 1",\r
        "children": [\r
          {\r
            "label": "二级 1-1",\r
            "children": [\r
              {\r
                "label": "三级 1-1-1"\r
              }\r
            ]\r
          }\r
        ]\r
      },\r
      {\r
        "label": "一级 2",\r
        "children": [\r
          {\r
            "label": "二级 2-1",\r
            "children": [\r
              {\r
                "label": "三级 2-1-1"\r
              }\r
            ]\r
          },\r
          {\r
            "label": "二级 2-2",\r
            "children": [\r
              {\r
                "label": "三级 2-2-1"\r
              }\r
            ]\r
          }\r
        ]\r
      }\r
    ]\r
  }\r
}\r
\`\`\`\r
\r
### 组件 TinyTimeLine\r
\r
使用适例:\r
\r
\`\`\`json\r
{\r
  "componentName": "TinyTimeLine",\r
  "props": {\r
    "active": "2",\r
    "data": [\r
      {\r
        "name": "已下单"\r
      },\r
      {\r
        "name": "运输中"\r
      },\r
      {\r
        "name": "已签收"\r
      }\r
    ]\r
  }\r
}\r
\`\`\`\r
`, qz = {};
function Gz(t, n) {
  const i = n || qz, o = typeof i.includeImageAlt == "boolean" ? i.includeImageAlt : !0, u = typeof i.includeHtml == "boolean" ? i.includeHtml : !0;
  return tA(t, o, u);
}
function tA(t, n, i) {
  if (Xz(t)) {
    if ("value" in t)
      return t.type === "html" && !i ? "" : t.value;
    if (n && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return $R(t.children, n, i);
  }
  return Array.isArray(t) ? $R(t, n, i) : "";
}
function $R(t, n, i) {
  const o = [];
  let u = -1;
  for (; ++u < t.length; )
    o[u] = tA(t[u], n, i);
  return o.join("");
}
function Xz(t) {
  return !!(t && typeof t == "object");
}
const jR = document.createElement("i");
function HE(t) {
  const n = "&" + t + ";";
  jR.innerHTML = n;
  const i = jR.textContent;
  return i.charCodeAt(i.length - 1) === 59 && t !== "semi" || i === n ? !1 : i;
}
function cs(t, n, i, o) {
  const u = t.length;
  let f = 0, p;
  if (n < 0 ? n = -n > u ? 0 : u + n : n = n > u ? u : n, i = i > 0 ? i : 0, o.length < 1e4)
    p = Array.from(o), p.unshift(n, i), t.splice(...p);
  else
    for (i && t.splice(n, i); f < o.length; )
      p = o.slice(f, f + 1e4), p.unshift(n, 0), t.splice(...p), f += 1e4, n += 1e4;
}
function Co(t, n) {
  return t.length > 0 ? (cs(t, t.length, 0, n), t) : n;
}
const IR = {}.hasOwnProperty;
function Qz(t) {
  const n = {};
  let i = -1;
  for (; ++i < t.length; )
    Kz(n, t[i]);
  return n;
}
function Kz(t, n) {
  let i;
  for (i in n) {
    const u = (IR.call(t, i) ? t[i] : void 0) || (t[i] = {}), f = n[i];
    let p;
    if (f)
      for (p in f) {
        IR.call(u, p) || (u[p] = []);
        const v = f[p];
        Jz(
          // @ts-expect-error Looks like a list.
          u[p],
          Array.isArray(v) ? v : v ? [v] : []
        );
      }
  }
}
function Jz(t, n) {
  let i = -1;
  const o = [];
  for (; ++i < n.length; )
    (n[i].add === "after" ? t : o).push(n[i]);
  cs(t, 0, 0, o);
}
function nA(t, n) {
  const i = Number.parseInt(t, n);
  return (
    // C0 except for HT, LF, FF, CR, space.
    i < 9 || i === 11 || i > 13 && i < 32 || // Control character (DEL) of C0, and C1 controls.
    i > 126 && i < 160 || // Lone high surrogates and low surrogates.
    i > 55295 && i < 57344 || // Noncharacters.
    i > 64975 && i < 65008 || /* eslint-disable no-bitwise */
    (i & 65535) === 65535 || (i & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    i > 1114111 ? "�" : String.fromCodePoint(i)
  );
}
function Jp(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const us = Nc(/[A-Za-z]/), to = Nc(/[\dA-Za-z]/), e$ = Nc(/[#-'*+\--9=?A-Z^-~]/);
function lE(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const sE = Nc(/\d/), t$ = Nc(/[\dA-Fa-f]/), n$ = Nc(/[!-/:-@[-`{-~]/);
function Ot(t) {
  return t !== null && t < -2;
}
function $a(t) {
  return t !== null && (t < 0 || t === 32);
}
function En(t) {
  return t === -2 || t === -1 || t === 32;
}
const r$ = Nc(new RegExp("\\p{P}|\\p{S}", "u")), i$ = Nc(/\s/);
function Nc(t) {
  return n;
  function n(i) {
    return i !== null && i > -1 && t.test(String.fromCharCode(i));
  }
}
function hh(t) {
  const n = [];
  let i = -1, o = 0, u = 0;
  for (; ++i < t.length; ) {
    const f = t.charCodeAt(i);
    let p = "";
    if (f === 37 && to(t.charCodeAt(i + 1)) && to(t.charCodeAt(i + 2)))
      u = 2;
    else if (f < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(f)) || (p = String.fromCharCode(f));
    else if (f > 55295 && f < 57344) {
      const v = t.charCodeAt(i + 1);
      f < 56320 && v > 56319 && v < 57344 ? (p = String.fromCharCode(f, v), u = 1) : p = "�";
    } else
      p = String.fromCharCode(f);
    p && (n.push(t.slice(o, i), encodeURIComponent(p)), o = i + u + 1, p = ""), u && (i += u, u = 0);
  }
  return n.join("") + t.slice(o);
}
function Yn(t, n, i, o) {
  const u = o ? o - 1 : Number.POSITIVE_INFINITY;
  let f = 0;
  return p;
  function p(b) {
    return En(b) ? (t.enter(i), v(b)) : n(b);
  }
  function v(b) {
    return En(b) && f++ < u ? (t.consume(b), v) : (t.exit(i), n(b));
  }
}
const a$ = {
  tokenize: o$
};
function o$(t) {
  const n = t.attempt(
    this.parser.constructs.contentInitial,
    o,
    u
  );
  let i;
  return n;
  function o(v) {
    if (v === null) {
      t.consume(v);
      return;
    }
    return t.enter("lineEnding"), t.consume(v), t.exit("lineEnding"), Yn(t, n, "linePrefix");
  }
  function u(v) {
    return t.enter("paragraph"), f(v);
  }
  function f(v) {
    const b = t.enter("chunkText", {
      contentType: "text",
      previous: i
    });
    return i && (i.next = b), i = b, p(v);
  }
  function p(v) {
    if (v === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(v);
      return;
    }
    return Ot(v) ? (t.consume(v), t.exit("chunkText"), f) : (t.consume(v), p);
  }
}
const l$ = {
  tokenize: s$
}, FR = {
  tokenize: u$
};
function s$(t) {
  const n = this, i = [];
  let o = 0, u, f, p;
  return v;
  function v(G) {
    if (o < i.length) {
      const te = i[o];
      return n.containerState = te[1], t.attempt(
        te[0].continuation,
        b,
        S
      )(G);
    }
    return S(G);
  }
  function b(G) {
    if (o++, n.containerState._closeFlow) {
      n.containerState._closeFlow = void 0, u && q();
      const te = n.events.length;
      let ee = te, V;
      for (; ee--; )
        if (n.events[ee][0] === "exit" && n.events[ee][1].type === "chunkFlow") {
          V = n.events[ee][1].end;
          break;
        }
      H(o);
      let ue = te;
      for (; ue < n.events.length; )
        n.events[ue][1].end = Object.assign({}, V), ue++;
      return cs(
        n.events,
        ee + 1,
        0,
        n.events.slice(te)
      ), n.events.length = ue, S(G);
    }
    return v(G);
  }
  function S(G) {
    if (o === i.length) {
      if (!u)
        return R(G);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return N(G);
      n.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return n.containerState = {}, t.check(
      FR,
      E,
      w
    )(G);
  }
  function E(G) {
    return u && q(), H(o), R(G);
  }
  function w(G) {
    return n.parser.lazy[n.now().line] = o !== i.length, p = n.now().offset, N(G);
  }
  function R(G) {
    return n.containerState = {}, t.attempt(
      FR,
      k,
      N
    )(G);
  }
  function k(G) {
    return o++, i.push([n.currentConstruct, n.containerState]), R(G);
  }
  function N(G) {
    if (G === null) {
      u && q(), H(0), t.consume(G);
      return;
    }
    return u = u || n.parser.flow(n.now()), t.enter("chunkFlow", {
      contentType: "flow",
      previous: f,
      _tokenizer: u
    }), z(G);
  }
  function z(G) {
    if (G === null) {
      I(t.exit("chunkFlow"), !0), H(0), t.consume(G);
      return;
    }
    return Ot(G) ? (t.consume(G), I(t.exit("chunkFlow")), o = 0, n.interrupt = void 0, v) : (t.consume(G), z);
  }
  function I(G, te) {
    const ee = n.sliceStream(G);
    if (te && ee.push(null), G.previous = f, f && (f.next = G), f = G, u.defineSkip(G.start), u.write(ee), n.parser.lazy[G.start.line]) {
      let V = u.events.length;
      for (; V--; )
        if (
          // The token starts before the line ending…
          u.events[V][1].start.offset < p && // …and either is not ended yet…
          (!u.events[V][1].end || // …or ends after it.
          u.events[V][1].end.offset > p)
        )
          return;
      const ue = n.events.length;
      let we = ue, me, Le;
      for (; we--; )
        if (n.events[we][0] === "exit" && n.events[we][1].type === "chunkFlow") {
          if (me) {
            Le = n.events[we][1].end;
            break;
          }
          me = !0;
        }
      for (H(o), V = ue; V < n.events.length; )
        n.events[V][1].end = Object.assign({}, Le), V++;
      cs(
        n.events,
        we + 1,
        0,
        n.events.slice(ue)
      ), n.events.length = V;
    }
  }
  function H(G) {
    let te = i.length;
    for (; te-- > G; ) {
      const ee = i[te];
      n.containerState = ee[1], ee[0].exit.call(n, t);
    }
    i.length = G;
  }
  function q() {
    u.write([null]), f = void 0, u = void 0, n.containerState._closeFlow = void 0;
  }
}
function u$(t, n, i) {
  return Yn(
    t,
    t.attempt(this.parser.constructs.document, n, i),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function UR(t) {
  if (t === null || $a(t) || i$(t))
    return 1;
  if (r$(t))
    return 2;
}
function VE(t, n, i) {
  const o = [];
  let u = -1;
  for (; ++u < t.length; ) {
    const f = t[u].resolveAll;
    f && !o.includes(f) && (n = f(n, i), o.push(f));
  }
  return n;
}
const uE = {
  name: "attention",
  tokenize: f$,
  resolveAll: c$
};
function c$(t, n) {
  let i = -1, o, u, f, p, v, b, S, E;
  for (; ++i < t.length; )
    if (t[i][0] === "enter" && t[i][1].type === "attentionSequence" && t[i][1]._close) {
      for (o = i; o--; )
        if (t[o][0] === "exit" && t[o][1].type === "attentionSequence" && t[o][1]._open && // If the markers are the same:
        n.sliceSerialize(t[o][1]).charCodeAt(0) === n.sliceSerialize(t[i][1]).charCodeAt(0)) {
          if ((t[o][1]._close || t[i][1]._open) && (t[i][1].end.offset - t[i][1].start.offset) % 3 && !((t[o][1].end.offset - t[o][1].start.offset + t[i][1].end.offset - t[i][1].start.offset) % 3))
            continue;
          b = t[o][1].end.offset - t[o][1].start.offset > 1 && t[i][1].end.offset - t[i][1].start.offset > 1 ? 2 : 1;
          const w = Object.assign({}, t[o][1].end), R = Object.assign({}, t[i][1].start);
          BR(w, -b), BR(R, b), p = {
            type: b > 1 ? "strongSequence" : "emphasisSequence",
            start: w,
            end: Object.assign({}, t[o][1].end)
          }, v = {
            type: b > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, t[i][1].start),
            end: R
          }, f = {
            type: b > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, t[o][1].end),
            end: Object.assign({}, t[i][1].start)
          }, u = {
            type: b > 1 ? "strong" : "emphasis",
            start: Object.assign({}, p.start),
            end: Object.assign({}, v.end)
          }, t[o][1].end = Object.assign({}, p.start), t[i][1].start = Object.assign({}, v.end), S = [], t[o][1].end.offset - t[o][1].start.offset && (S = Co(S, [
            ["enter", t[o][1], n],
            ["exit", t[o][1], n]
          ])), S = Co(S, [
            ["enter", u, n],
            ["enter", p, n],
            ["exit", p, n],
            ["enter", f, n]
          ]), S = Co(
            S,
            VE(
              n.parser.constructs.insideSpan.null,
              t.slice(o + 1, i),
              n
            )
          ), S = Co(S, [
            ["exit", f, n],
            ["enter", v, n],
            ["exit", v, n],
            ["exit", u, n]
          ]), t[i][1].end.offset - t[i][1].start.offset ? (E = 2, S = Co(S, [
            ["enter", t[i][1], n],
            ["exit", t[i][1], n]
          ])) : E = 0, cs(t, o - 1, i - o + 3, S), i = o + S.length - E - 2;
          break;
        }
    }
  for (i = -1; ++i < t.length; )
    t[i][1].type === "attentionSequence" && (t[i][1].type = "data");
  return t;
}
function f$(t, n) {
  const i = this.parser.constructs.attentionMarkers.null, o = this.previous, u = UR(o);
  let f;
  return p;
  function p(b) {
    return f = b, t.enter("attentionSequence"), v(b);
  }
  function v(b) {
    if (b === f)
      return t.consume(b), v;
    const S = t.exit("attentionSequence"), E = UR(b), w = !E || E === 2 && u || i.includes(b), R = !u || u === 2 && E || i.includes(o);
    return S._open = !!(f === 42 ? w : w && (u || !R)), S._close = !!(f === 42 ? R : R && (E || !w)), n(b);
  }
}
function BR(t, n) {
  t.column += n, t.offset += n, t._bufferIndex += n;
}
const d$ = {
  name: "autolink",
  tokenize: p$
};
function p$(t, n, i) {
  let o = 0;
  return u;
  function u(k) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(k), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), f;
  }
  function f(k) {
    return us(k) ? (t.consume(k), p) : S(k);
  }
  function p(k) {
    return k === 43 || k === 45 || k === 46 || to(k) ? (o = 1, v(k)) : S(k);
  }
  function v(k) {
    return k === 58 ? (t.consume(k), o = 0, b) : (k === 43 || k === 45 || k === 46 || to(k)) && o++ < 32 ? (t.consume(k), v) : (o = 0, S(k));
  }
  function b(k) {
    return k === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(k), t.exit("autolinkMarker"), t.exit("autolink"), n) : k === null || k === 32 || k === 60 || lE(k) ? i(k) : (t.consume(k), b);
  }
  function S(k) {
    return k === 64 ? (t.consume(k), E) : e$(k) ? (t.consume(k), S) : i(k);
  }
  function E(k) {
    return to(k) ? w(k) : i(k);
  }
  function w(k) {
    return k === 46 ? (t.consume(k), o = 0, E) : k === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(k), t.exit("autolinkMarker"), t.exit("autolink"), n) : R(k);
  }
  function R(k) {
    if ((k === 45 || to(k)) && o++ < 63) {
      const N = k === 45 ? R : w;
      return t.consume(k), N;
    }
    return i(k);
  }
}
const PS = {
  tokenize: h$,
  partial: !0
};
function h$(t, n, i) {
  return o;
  function o(f) {
    return En(f) ? Yn(t, u, "linePrefix")(f) : u(f);
  }
  function u(f) {
    return f === null || Ot(f) ? n(f) : i(f);
  }
}
const rA = {
  name: "blockQuote",
  tokenize: m$,
  continuation: {
    tokenize: v$
  },
  exit: y$
};
function m$(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    if (p === 62) {
      const v = o.containerState;
      return v.open || (t.enter("blockQuote", {
        _container: !0
      }), v.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(p), t.exit("blockQuoteMarker"), f;
    }
    return i(p);
  }
  function f(p) {
    return En(p) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(p), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), n) : (t.exit("blockQuotePrefix"), n(p));
  }
}
function v$(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    return En(p) ? Yn(
      t,
      f,
      "linePrefix",
      o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(p) : f(p);
  }
  function f(p) {
    return t.attempt(rA, n, i)(p);
  }
}
function y$(t) {
  t.exit("blockQuote");
}
const iA = {
  name: "characterEscape",
  tokenize: g$
};
function g$(t, n, i) {
  return o;
  function o(f) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(f), t.exit("escapeMarker"), u;
  }
  function u(f) {
    return n$(f) ? (t.enter("characterEscapeValue"), t.consume(f), t.exit("characterEscapeValue"), t.exit("characterEscape"), n) : i(f);
  }
}
const aA = {
  name: "characterReference",
  tokenize: b$
};
function b$(t, n, i) {
  const o = this;
  let u = 0, f, p;
  return v;
  function v(w) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(w), t.exit("characterReferenceMarker"), b;
  }
  function b(w) {
    return w === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(w), t.exit("characterReferenceMarkerNumeric"), S) : (t.enter("characterReferenceValue"), f = 31, p = to, E(w));
  }
  function S(w) {
    return w === 88 || w === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(w), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), f = 6, p = t$, E) : (t.enter("characterReferenceValue"), f = 7, p = sE, E(w));
  }
  function E(w) {
    if (w === 59 && u) {
      const R = t.exit("characterReferenceValue");
      return p === to && !HE(o.sliceSerialize(R)) ? i(w) : (t.enter("characterReferenceMarker"), t.consume(w), t.exit("characterReferenceMarker"), t.exit("characterReference"), n);
    }
    return p(w) && u++ < f ? (t.consume(w), E) : i(w);
  }
}
const HR = {
  tokenize: x$,
  partial: !0
}, VR = {
  name: "codeFenced",
  tokenize: S$,
  concrete: !0
};
function S$(t, n, i) {
  const o = this, u = {
    tokenize: ee,
    partial: !0
  };
  let f = 0, p = 0, v;
  return b;
  function b(V) {
    return S(V);
  }
  function S(V) {
    const ue = o.events[o.events.length - 1];
    return f = ue && ue[1].type === "linePrefix" ? ue[2].sliceSerialize(ue[1], !0).length : 0, v = V, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), E(V);
  }
  function E(V) {
    return V === v ? (p++, t.consume(V), E) : p < 3 ? i(V) : (t.exit("codeFencedFenceSequence"), En(V) ? Yn(t, w, "whitespace")(V) : w(V));
  }
  function w(V) {
    return V === null || Ot(V) ? (t.exit("codeFencedFence"), o.interrupt ? n(V) : t.check(HR, z, te)(V)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), R(V));
  }
  function R(V) {
    return V === null || Ot(V) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), w(V)) : En(V) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), Yn(t, k, "whitespace")(V)) : V === 96 && V === v ? i(V) : (t.consume(V), R);
  }
  function k(V) {
    return V === null || Ot(V) ? w(V) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), N(V));
  }
  function N(V) {
    return V === null || Ot(V) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), w(V)) : V === 96 && V === v ? i(V) : (t.consume(V), N);
  }
  function z(V) {
    return t.attempt(u, te, I)(V);
  }
  function I(V) {
    return t.enter("lineEnding"), t.consume(V), t.exit("lineEnding"), H;
  }
  function H(V) {
    return f > 0 && En(V) ? Yn(
      t,
      q,
      "linePrefix",
      f + 1
    )(V) : q(V);
  }
  function q(V) {
    return V === null || Ot(V) ? t.check(HR, z, te)(V) : (t.enter("codeFlowValue"), G(V));
  }
  function G(V) {
    return V === null || Ot(V) ? (t.exit("codeFlowValue"), q(V)) : (t.consume(V), G);
  }
  function te(V) {
    return t.exit("codeFenced"), n(V);
  }
  function ee(V, ue, we) {
    let me = 0;
    return Le;
    function Le(We) {
      return V.enter("lineEnding"), V.consume(We), V.exit("lineEnding"), xe;
    }
    function xe(We) {
      return V.enter("codeFencedFence"), En(We) ? Yn(
        V,
        ve,
        "linePrefix",
        o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(We) : ve(We);
    }
    function ve(We) {
      return We === v ? (V.enter("codeFencedFenceSequence"), Pe(We)) : we(We);
    }
    function Pe(We) {
      return We === v ? (me++, V.consume(We), Pe) : me >= p ? (V.exit("codeFencedFenceSequence"), En(We) ? Yn(V, Ue, "whitespace")(We) : Ue(We)) : we(We);
    }
    function Ue(We) {
      return We === null || Ot(We) ? (V.exit("codeFencedFence"), ue(We)) : we(We);
    }
  }
}
function x$(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    return p === null ? i(p) : (t.enter("lineEnding"), t.consume(p), t.exit("lineEnding"), f);
  }
  function f(p) {
    return o.parser.lazy[o.now().line] ? i(p) : n(p);
  }
}
const T_ = {
  name: "codeIndented",
  tokenize: _$
}, w$ = {
  tokenize: E$,
  partial: !0
};
function _$(t, n, i) {
  const o = this;
  return u;
  function u(S) {
    return t.enter("codeIndented"), Yn(t, f, "linePrefix", 5)(S);
  }
  function f(S) {
    const E = o.events[o.events.length - 1];
    return E && E[1].type === "linePrefix" && E[2].sliceSerialize(E[1], !0).length >= 4 ? p(S) : i(S);
  }
  function p(S) {
    return S === null ? b(S) : Ot(S) ? t.attempt(w$, p, b)(S) : (t.enter("codeFlowValue"), v(S));
  }
  function v(S) {
    return S === null || Ot(S) ? (t.exit("codeFlowValue"), p(S)) : (t.consume(S), v);
  }
  function b(S) {
    return t.exit("codeIndented"), n(S);
  }
}
function E$(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    return o.parser.lazy[o.now().line] ? i(p) : Ot(p) ? (t.enter("lineEnding"), t.consume(p), t.exit("lineEnding"), u) : Yn(t, f, "linePrefix", 5)(p);
  }
  function f(p) {
    const v = o.events[o.events.length - 1];
    return v && v[1].type === "linePrefix" && v[2].sliceSerialize(v[1], !0).length >= 4 ? n(p) : Ot(p) ? u(p) : i(p);
  }
}
const C$ = {
  name: "codeText",
  tokenize: R$,
  resolve: k$,
  previous: T$
};
function k$(t) {
  let n = t.length - 4, i = 3, o, u;
  if ((t[i][1].type === "lineEnding" || t[i][1].type === "space") && (t[n][1].type === "lineEnding" || t[n][1].type === "space")) {
    for (o = i; ++o < n; )
      if (t[o][1].type === "codeTextData") {
        t[i][1].type = "codeTextPadding", t[n][1].type = "codeTextPadding", i += 2, n -= 2;
        break;
      }
  }
  for (o = i - 1, n++; ++o <= n; )
    u === void 0 ? o !== n && t[o][1].type !== "lineEnding" && (u = o) : (o === n || t[o][1].type === "lineEnding") && (t[u][1].type = "codeTextData", o !== u + 2 && (t[u][1].end = t[o - 1][1].end, t.splice(u + 2, o - u - 2), n -= o - u - 2, o = u + 2), u = void 0);
  return t;
}
function T$(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function R$(t, n, i) {
  let o = 0, u, f;
  return p;
  function p(w) {
    return t.enter("codeText"), t.enter("codeTextSequence"), v(w);
  }
  function v(w) {
    return w === 96 ? (t.consume(w), o++, v) : (t.exit("codeTextSequence"), b(w));
  }
  function b(w) {
    return w === null ? i(w) : w === 32 ? (t.enter("space"), t.consume(w), t.exit("space"), b) : w === 96 ? (f = t.enter("codeTextSequence"), u = 0, E(w)) : Ot(w) ? (t.enter("lineEnding"), t.consume(w), t.exit("lineEnding"), b) : (t.enter("codeTextData"), S(w));
  }
  function S(w) {
    return w === null || w === 32 || w === 96 || Ot(w) ? (t.exit("codeTextData"), b(w)) : (t.consume(w), S);
  }
  function E(w) {
    return w === 96 ? (t.consume(w), u++, E) : u === o ? (t.exit("codeTextSequence"), t.exit("codeText"), n(w)) : (f.type = "codeTextData", S(w));
  }
}
function oA(t) {
  const n = {};
  let i = -1, o, u, f, p, v, b, S;
  for (; ++i < t.length; ) {
    for (; i in n; )
      i = n[i];
    if (o = t[i], i && o[1].type === "chunkFlow" && t[i - 1][1].type === "listItemPrefix" && (b = o[1]._tokenizer.events, f = 0, f < b.length && b[f][1].type === "lineEndingBlank" && (f += 2), f < b.length && b[f][1].type === "content"))
      for (; ++f < b.length && b[f][1].type !== "content"; )
        b[f][1].type === "chunkText" && (b[f][1]._isInFirstContentOfListItem = !0, f++);
    if (o[0] === "enter")
      o[1].contentType && (Object.assign(n, O$(t, i)), i = n[i], S = !0);
    else if (o[1]._container) {
      for (f = i, u = void 0; f-- && (p = t[f], p[1].type === "lineEnding" || p[1].type === "lineEndingBlank"); )
        p[0] === "enter" && (u && (t[u][1].type = "lineEndingBlank"), p[1].type = "lineEnding", u = f);
      u && (o[1].end = Object.assign({}, t[u][1].start), v = t.slice(u, i), v.unshift(o), cs(t, u, i - u + 1, v));
    }
  }
  return !S;
}
function O$(t, n) {
  const i = t[n][1], o = t[n][2];
  let u = n - 1;
  const f = [], p = i._tokenizer || o.parser[i.contentType](i.start), v = p.events, b = [], S = {};
  let E, w, R = -1, k = i, N = 0, z = 0;
  const I = [z];
  for (; k; ) {
    for (; t[++u][1] !== k; )
      ;
    f.push(u), k._tokenizer || (E = o.sliceStream(k), k.next || E.push(null), w && p.defineSkip(k.start), k._isInFirstContentOfListItem && (p._gfmTasklistFirstContentOfListItem = !0), p.write(E), k._isInFirstContentOfListItem && (p._gfmTasklistFirstContentOfListItem = void 0)), w = k, k = k.next;
  }
  for (k = i; ++R < v.length; )
    // Find a void token that includes a break.
    v[R][0] === "exit" && v[R - 1][0] === "enter" && v[R][1].type === v[R - 1][1].type && v[R][1].start.line !== v[R][1].end.line && (z = R + 1, I.push(z), k._tokenizer = void 0, k.previous = void 0, k = k.next);
  for (p.events = [], k ? (k._tokenizer = void 0, k.previous = void 0) : I.pop(), R = I.length; R--; ) {
    const H = v.slice(I[R], I[R + 1]), q = f.pop();
    b.unshift([q, q + H.length - 1]), cs(t, q, 2, H);
  }
  for (R = -1; ++R < b.length; )
    S[N + b[R][0]] = N + b[R][1], N += b[R][1] - b[R][0] - 1;
  return S;
}
const A$ = {
  tokenize: N$,
  resolve: M$
}, D$ = {
  tokenize: L$,
  partial: !0
};
function M$(t) {
  return oA(t), t;
}
function N$(t, n) {
  let i;
  return o;
  function o(v) {
    return t.enter("content"), i = t.enter("chunkContent", {
      contentType: "content"
    }), u(v);
  }
  function u(v) {
    return v === null ? f(v) : Ot(v) ? t.check(
      D$,
      p,
      f
    )(v) : (t.consume(v), u);
  }
  function f(v) {
    return t.exit("chunkContent"), t.exit("content"), n(v);
  }
  function p(v) {
    return t.consume(v), t.exit("chunkContent"), i.next = t.enter("chunkContent", {
      contentType: "content",
      previous: i
    }), i = i.next, u;
  }
}
function L$(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(p), t.exit("lineEnding"), Yn(t, f, "linePrefix");
  }
  function f(p) {
    if (p === null || Ot(p))
      return i(p);
    const v = o.events[o.events.length - 1];
    return !o.parser.constructs.disable.null.includes("codeIndented") && v && v[1].type === "linePrefix" && v[2].sliceSerialize(v[1], !0).length >= 4 ? n(p) : t.interrupt(o.parser.constructs.flow, i, n)(p);
  }
}
function lA(t, n, i, o, u, f, p, v, b) {
  const S = b || Number.POSITIVE_INFINITY;
  let E = 0;
  return w;
  function w(H) {
    return H === 60 ? (t.enter(o), t.enter(u), t.enter(f), t.consume(H), t.exit(f), R) : H === null || H === 32 || H === 41 || lE(H) ? i(H) : (t.enter(o), t.enter(p), t.enter(v), t.enter("chunkString", {
      contentType: "string"
    }), z(H));
  }
  function R(H) {
    return H === 62 ? (t.enter(f), t.consume(H), t.exit(f), t.exit(u), t.exit(o), n) : (t.enter(v), t.enter("chunkString", {
      contentType: "string"
    }), k(H));
  }
  function k(H) {
    return H === 62 ? (t.exit("chunkString"), t.exit(v), R(H)) : H === null || H === 60 || Ot(H) ? i(H) : (t.consume(H), H === 92 ? N : k);
  }
  function N(H) {
    return H === 60 || H === 62 || H === 92 ? (t.consume(H), k) : k(H);
  }
  function z(H) {
    return !E && (H === null || H === 41 || $a(H)) ? (t.exit("chunkString"), t.exit(v), t.exit(p), t.exit(o), n(H)) : E < S && H === 40 ? (t.consume(H), E++, z) : H === 41 ? (t.consume(H), E--, z) : H === null || H === 32 || H === 40 || lE(H) ? i(H) : (t.consume(H), H === 92 ? I : z);
  }
  function I(H) {
    return H === 40 || H === 41 || H === 92 ? (t.consume(H), z) : z(H);
  }
}
function sA(t, n, i, o, u, f) {
  const p = this;
  let v = 0, b;
  return S;
  function S(k) {
    return t.enter(o), t.enter(u), t.consume(k), t.exit(u), t.enter(f), E;
  }
  function E(k) {
    return v > 999 || k === null || k === 91 || k === 93 && !b || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    k === 94 && !v && "_hiddenFootnoteSupport" in p.parser.constructs ? i(k) : k === 93 ? (t.exit(f), t.enter(u), t.consume(k), t.exit(u), t.exit(o), n) : Ot(k) ? (t.enter("lineEnding"), t.consume(k), t.exit("lineEnding"), E) : (t.enter("chunkString", {
      contentType: "string"
    }), w(k));
  }
  function w(k) {
    return k === null || k === 91 || k === 93 || Ot(k) || v++ > 999 ? (t.exit("chunkString"), E(k)) : (t.consume(k), b || (b = !En(k)), k === 92 ? R : w);
  }
  function R(k) {
    return k === 91 || k === 92 || k === 93 ? (t.consume(k), v++, w) : w(k);
  }
}
function uA(t, n, i, o, u, f) {
  let p;
  return v;
  function v(R) {
    return R === 34 || R === 39 || R === 40 ? (t.enter(o), t.enter(u), t.consume(R), t.exit(u), p = R === 40 ? 41 : R, b) : i(R);
  }
  function b(R) {
    return R === p ? (t.enter(u), t.consume(R), t.exit(u), t.exit(o), n) : (t.enter(f), S(R));
  }
  function S(R) {
    return R === p ? (t.exit(f), b(p)) : R === null ? i(R) : Ot(R) ? (t.enter("lineEnding"), t.consume(R), t.exit("lineEnding"), Yn(t, S, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), E(R));
  }
  function E(R) {
    return R === p || R === null || Ot(R) ? (t.exit("chunkString"), S(R)) : (t.consume(R), R === 92 ? w : E);
  }
  function w(R) {
    return R === p || R === 92 ? (t.consume(R), E) : E(R);
  }
}
function Vv(t, n) {
  let i;
  return o;
  function o(u) {
    return Ot(u) ? (t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), i = !0, o) : En(u) ? Yn(
      t,
      o,
      i ? "linePrefix" : "lineSuffix"
    )(u) : n(u);
  }
}
const P$ = {
  name: "definition",
  tokenize: $$
}, z$ = {
  tokenize: j$,
  partial: !0
};
function $$(t, n, i) {
  const o = this;
  let u;
  return f;
  function f(k) {
    return t.enter("definition"), p(k);
  }
  function p(k) {
    return sA.call(
      o,
      t,
      v,
      // Note: we don’t need to reset the way `markdown-rs` does.
      i,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(k);
  }
  function v(k) {
    return u = Jp(
      o.sliceSerialize(o.events[o.events.length - 1][1]).slice(1, -1)
    ), k === 58 ? (t.enter("definitionMarker"), t.consume(k), t.exit("definitionMarker"), b) : i(k);
  }
  function b(k) {
    return $a(k) ? Vv(t, S)(k) : S(k);
  }
  function S(k) {
    return lA(
      t,
      E,
      // Note: we don’t need to reset the way `markdown-rs` does.
      i,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(k);
  }
  function E(k) {
    return t.attempt(z$, w, w)(k);
  }
  function w(k) {
    return En(k) ? Yn(t, R, "whitespace")(k) : R(k);
  }
  function R(k) {
    return k === null || Ot(k) ? (t.exit("definition"), o.parser.defined.push(u), n(k)) : i(k);
  }
}
function j$(t, n, i) {
  return o;
  function o(v) {
    return $a(v) ? Vv(t, u)(v) : i(v);
  }
  function u(v) {
    return uA(
      t,
      f,
      i,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(v);
  }
  function f(v) {
    return En(v) ? Yn(t, p, "whitespace")(v) : p(v);
  }
  function p(v) {
    return v === null || Ot(v) ? n(v) : i(v);
  }
}
const I$ = {
  name: "hardBreakEscape",
  tokenize: F$
};
function F$(t, n, i) {
  return o;
  function o(f) {
    return t.enter("hardBreakEscape"), t.consume(f), u;
  }
  function u(f) {
    return Ot(f) ? (t.exit("hardBreakEscape"), n(f)) : i(f);
  }
}
const U$ = {
  name: "headingAtx",
  tokenize: H$,
  resolve: B$
};
function B$(t, n) {
  let i = t.length - 2, o = 3, u, f;
  return t[o][1].type === "whitespace" && (o += 2), i - 2 > o && t[i][1].type === "whitespace" && (i -= 2), t[i][1].type === "atxHeadingSequence" && (o === i - 1 || i - 4 > o && t[i - 2][1].type === "whitespace") && (i -= o + 1 === i ? 2 : 4), i > o && (u = {
    type: "atxHeadingText",
    start: t[o][1].start,
    end: t[i][1].end
  }, f = {
    type: "chunkText",
    start: t[o][1].start,
    end: t[i][1].end,
    contentType: "text"
  }, cs(t, o, i - o + 1, [
    ["enter", u, n],
    ["enter", f, n],
    ["exit", f, n],
    ["exit", u, n]
  ])), t;
}
function H$(t, n, i) {
  let o = 0;
  return u;
  function u(E) {
    return t.enter("atxHeading"), f(E);
  }
  function f(E) {
    return t.enter("atxHeadingSequence"), p(E);
  }
  function p(E) {
    return E === 35 && o++ < 6 ? (t.consume(E), p) : E === null || $a(E) ? (t.exit("atxHeadingSequence"), v(E)) : i(E);
  }
  function v(E) {
    return E === 35 ? (t.enter("atxHeadingSequence"), b(E)) : E === null || Ot(E) ? (t.exit("atxHeading"), n(E)) : En(E) ? Yn(t, v, "whitespace")(E) : (t.enter("atxHeadingText"), S(E));
  }
  function b(E) {
    return E === 35 ? (t.consume(E), b) : (t.exit("atxHeadingSequence"), v(E));
  }
  function S(E) {
    return E === null || E === 35 || $a(E) ? (t.exit("atxHeadingText"), v(E)) : (t.consume(E), S);
  }
}
const V$ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], WR = ["pre", "script", "style", "textarea"], W$ = {
  name: "htmlFlow",
  tokenize: G$,
  resolveTo: q$,
  concrete: !0
}, Y$ = {
  tokenize: Q$,
  partial: !0
}, Z$ = {
  tokenize: X$,
  partial: !0
};
function q$(t) {
  let n = t.length;
  for (; n-- && !(t[n][0] === "enter" && t[n][1].type === "htmlFlow"); )
    ;
  return n > 1 && t[n - 2][1].type === "linePrefix" && (t[n][1].start = t[n - 2][1].start, t[n + 1][1].start = t[n - 2][1].start, t.splice(n - 2, 2)), t;
}
function G$(t, n, i) {
  const o = this;
  let u, f, p, v, b;
  return S;
  function S(j) {
    return E(j);
  }
  function E(j) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(j), w;
  }
  function w(j) {
    return j === 33 ? (t.consume(j), R) : j === 47 ? (t.consume(j), f = !0, z) : j === 63 ? (t.consume(j), u = 3, o.interrupt ? n : O) : us(j) ? (t.consume(j), p = String.fromCharCode(j), I) : i(j);
  }
  function R(j) {
    return j === 45 ? (t.consume(j), u = 2, k) : j === 91 ? (t.consume(j), u = 5, v = 0, N) : us(j) ? (t.consume(j), u = 4, o.interrupt ? n : O) : i(j);
  }
  function k(j) {
    return j === 45 ? (t.consume(j), o.interrupt ? n : O) : i(j);
  }
  function N(j) {
    const rt = "CDATA[";
    return j === rt.charCodeAt(v++) ? (t.consume(j), v === rt.length ? o.interrupt ? n : ve : N) : i(j);
  }
  function z(j) {
    return us(j) ? (t.consume(j), p = String.fromCharCode(j), I) : i(j);
  }
  function I(j) {
    if (j === null || j === 47 || j === 62 || $a(j)) {
      const rt = j === 47, Mt = p.toLowerCase();
      return !rt && !f && WR.includes(Mt) ? (u = 1, o.interrupt ? n(j) : ve(j)) : V$.includes(p.toLowerCase()) ? (u = 6, rt ? (t.consume(j), H) : o.interrupt ? n(j) : ve(j)) : (u = 7, o.interrupt && !o.parser.lazy[o.now().line] ? i(j) : f ? q(j) : G(j));
    }
    return j === 45 || to(j) ? (t.consume(j), p += String.fromCharCode(j), I) : i(j);
  }
  function H(j) {
    return j === 62 ? (t.consume(j), o.interrupt ? n : ve) : i(j);
  }
  function q(j) {
    return En(j) ? (t.consume(j), q) : Le(j);
  }
  function G(j) {
    return j === 47 ? (t.consume(j), Le) : j === 58 || j === 95 || us(j) ? (t.consume(j), te) : En(j) ? (t.consume(j), G) : Le(j);
  }
  function te(j) {
    return j === 45 || j === 46 || j === 58 || j === 95 || to(j) ? (t.consume(j), te) : ee(j);
  }
  function ee(j) {
    return j === 61 ? (t.consume(j), V) : En(j) ? (t.consume(j), ee) : G(j);
  }
  function V(j) {
    return j === null || j === 60 || j === 61 || j === 62 || j === 96 ? i(j) : j === 34 || j === 39 ? (t.consume(j), b = j, ue) : En(j) ? (t.consume(j), V) : we(j);
  }
  function ue(j) {
    return j === b ? (t.consume(j), b = null, me) : j === null || Ot(j) ? i(j) : (t.consume(j), ue);
  }
  function we(j) {
    return j === null || j === 34 || j === 39 || j === 47 || j === 60 || j === 61 || j === 62 || j === 96 || $a(j) ? ee(j) : (t.consume(j), we);
  }
  function me(j) {
    return j === 47 || j === 62 || En(j) ? G(j) : i(j);
  }
  function Le(j) {
    return j === 62 ? (t.consume(j), xe) : i(j);
  }
  function xe(j) {
    return j === null || Ot(j) ? ve(j) : En(j) ? (t.consume(j), xe) : i(j);
  }
  function ve(j) {
    return j === 45 && u === 2 ? (t.consume(j), at) : j === 60 && u === 1 ? (t.consume(j), Te) : j === 62 && u === 4 ? (t.consume(j), ce) : j === 63 && u === 3 ? (t.consume(j), O) : j === 93 && u === 5 ? (t.consume(j), Fe) : Ot(j) && (u === 6 || u === 7) ? (t.exit("htmlFlowData"), t.check(
      Y$,
      De,
      Pe
    )(j)) : j === null || Ot(j) ? (t.exit("htmlFlowData"), Pe(j)) : (t.consume(j), ve);
  }
  function Pe(j) {
    return t.check(
      Z$,
      Ue,
      De
    )(j);
  }
  function Ue(j) {
    return t.enter("lineEnding"), t.consume(j), t.exit("lineEnding"), We;
  }
  function We(j) {
    return j === null || Ot(j) ? Pe(j) : (t.enter("htmlFlowData"), ve(j));
  }
  function at(j) {
    return j === 45 ? (t.consume(j), O) : ve(j);
  }
  function Te(j) {
    return j === 47 ? (t.consume(j), p = "", ye) : ve(j);
  }
  function ye(j) {
    if (j === 62) {
      const rt = p.toLowerCase();
      return WR.includes(rt) ? (t.consume(j), ce) : ve(j);
    }
    return us(j) && p.length < 8 ? (t.consume(j), p += String.fromCharCode(j), ye) : ve(j);
  }
  function Fe(j) {
    return j === 93 ? (t.consume(j), O) : ve(j);
  }
  function O(j) {
    return j === 62 ? (t.consume(j), ce) : j === 45 && u === 2 ? (t.consume(j), O) : ve(j);
  }
  function ce(j) {
    return j === null || Ot(j) ? (t.exit("htmlFlowData"), De(j)) : (t.consume(j), ce);
  }
  function De(j) {
    return t.exit("htmlFlow"), n(j);
  }
}
function X$(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    return Ot(p) ? (t.enter("lineEnding"), t.consume(p), t.exit("lineEnding"), f) : i(p);
  }
  function f(p) {
    return o.parser.lazy[o.now().line] ? i(p) : n(p);
  }
}
function Q$(t, n, i) {
  return o;
  function o(u) {
    return t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), t.attempt(PS, n, i);
  }
}
const K$ = {
  name: "htmlText",
  tokenize: J$
};
function J$(t, n, i) {
  const o = this;
  let u, f, p;
  return v;
  function v(O) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(O), b;
  }
  function b(O) {
    return O === 33 ? (t.consume(O), S) : O === 47 ? (t.consume(O), ee) : O === 63 ? (t.consume(O), G) : us(O) ? (t.consume(O), we) : i(O);
  }
  function S(O) {
    return O === 45 ? (t.consume(O), E) : O === 91 ? (t.consume(O), f = 0, N) : us(O) ? (t.consume(O), q) : i(O);
  }
  function E(O) {
    return O === 45 ? (t.consume(O), k) : i(O);
  }
  function w(O) {
    return O === null ? i(O) : O === 45 ? (t.consume(O), R) : Ot(O) ? (p = w, Te(O)) : (t.consume(O), w);
  }
  function R(O) {
    return O === 45 ? (t.consume(O), k) : w(O);
  }
  function k(O) {
    return O === 62 ? at(O) : O === 45 ? R(O) : w(O);
  }
  function N(O) {
    const ce = "CDATA[";
    return O === ce.charCodeAt(f++) ? (t.consume(O), f === ce.length ? z : N) : i(O);
  }
  function z(O) {
    return O === null ? i(O) : O === 93 ? (t.consume(O), I) : Ot(O) ? (p = z, Te(O)) : (t.consume(O), z);
  }
  function I(O) {
    return O === 93 ? (t.consume(O), H) : z(O);
  }
  function H(O) {
    return O === 62 ? at(O) : O === 93 ? (t.consume(O), H) : z(O);
  }
  function q(O) {
    return O === null || O === 62 ? at(O) : Ot(O) ? (p = q, Te(O)) : (t.consume(O), q);
  }
  function G(O) {
    return O === null ? i(O) : O === 63 ? (t.consume(O), te) : Ot(O) ? (p = G, Te(O)) : (t.consume(O), G);
  }
  function te(O) {
    return O === 62 ? at(O) : G(O);
  }
  function ee(O) {
    return us(O) ? (t.consume(O), V) : i(O);
  }
  function V(O) {
    return O === 45 || to(O) ? (t.consume(O), V) : ue(O);
  }
  function ue(O) {
    return Ot(O) ? (p = ue, Te(O)) : En(O) ? (t.consume(O), ue) : at(O);
  }
  function we(O) {
    return O === 45 || to(O) ? (t.consume(O), we) : O === 47 || O === 62 || $a(O) ? me(O) : i(O);
  }
  function me(O) {
    return O === 47 ? (t.consume(O), at) : O === 58 || O === 95 || us(O) ? (t.consume(O), Le) : Ot(O) ? (p = me, Te(O)) : En(O) ? (t.consume(O), me) : at(O);
  }
  function Le(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || to(O) ? (t.consume(O), Le) : xe(O);
  }
  function xe(O) {
    return O === 61 ? (t.consume(O), ve) : Ot(O) ? (p = xe, Te(O)) : En(O) ? (t.consume(O), xe) : me(O);
  }
  function ve(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? i(O) : O === 34 || O === 39 ? (t.consume(O), u = O, Pe) : Ot(O) ? (p = ve, Te(O)) : En(O) ? (t.consume(O), ve) : (t.consume(O), Ue);
  }
  function Pe(O) {
    return O === u ? (t.consume(O), u = void 0, We) : O === null ? i(O) : Ot(O) ? (p = Pe, Te(O)) : (t.consume(O), Pe);
  }
  function Ue(O) {
    return O === null || O === 34 || O === 39 || O === 60 || O === 61 || O === 96 ? i(O) : O === 47 || O === 62 || $a(O) ? me(O) : (t.consume(O), Ue);
  }
  function We(O) {
    return O === 47 || O === 62 || $a(O) ? me(O) : i(O);
  }
  function at(O) {
    return O === 62 ? (t.consume(O), t.exit("htmlTextData"), t.exit("htmlText"), n) : i(O);
  }
  function Te(O) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(O), t.exit("lineEnding"), ye;
  }
  function ye(O) {
    return En(O) ? Yn(
      t,
      Fe,
      "linePrefix",
      o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(O) : Fe(O);
  }
  function Fe(O) {
    return t.enter("htmlTextData"), p(O);
  }
}
const WE = {
  name: "labelEnd",
  tokenize: aj,
  resolveTo: ij,
  resolveAll: rj
}, ej = {
  tokenize: oj
}, tj = {
  tokenize: lj
}, nj = {
  tokenize: sj
};
function rj(t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const i = t[n][1];
    (i.type === "labelImage" || i.type === "labelLink" || i.type === "labelEnd") && (t.splice(n + 1, i.type === "labelImage" ? 4 : 2), i.type = "data", n++);
  }
  return t;
}
function ij(t, n) {
  let i = t.length, o = 0, u, f, p, v;
  for (; i--; )
    if (u = t[i][1], f) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      t[i][0] === "enter" && u.type === "labelLink" && (u._inactive = !0);
    } else if (p) {
      if (t[i][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (f = i, u.type !== "labelLink")) {
        o = 2;
        break;
      }
    } else
      u.type === "labelEnd" && (p = i);
  const b = {
    type: t[f][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, t[f][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, S = {
    type: "label",
    start: Object.assign({}, t[f][1].start),
    end: Object.assign({}, t[p][1].end)
  }, E = {
    type: "labelText",
    start: Object.assign({}, t[f + o + 2][1].end),
    end: Object.assign({}, t[p - 2][1].start)
  };
  return v = [
    ["enter", b, n],
    ["enter", S, n]
  ], v = Co(v, t.slice(f + 1, f + o + 3)), v = Co(v, [["enter", E, n]]), v = Co(
    v,
    VE(
      n.parser.constructs.insideSpan.null,
      t.slice(f + o + 4, p - 3),
      n
    )
  ), v = Co(v, [
    ["exit", E, n],
    t[p - 2],
    t[p - 1],
    ["exit", S, n]
  ]), v = Co(v, t.slice(p + 1)), v = Co(v, [["exit", b, n]]), cs(t, f, t.length, v), t;
}
function aj(t, n, i) {
  const o = this;
  let u = o.events.length, f, p;
  for (; u--; )
    if ((o.events[u][1].type === "labelImage" || o.events[u][1].type === "labelLink") && !o.events[u][1]._balanced) {
      f = o.events[u][1];
      break;
    }
  return v;
  function v(R) {
    return f ? f._inactive ? w(R) : (p = o.parser.defined.includes(
      Jp(
        o.sliceSerialize({
          start: f.end,
          end: o.now()
        })
      )
    ), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(R), t.exit("labelMarker"), t.exit("labelEnd"), b) : i(R);
  }
  function b(R) {
    return R === 40 ? t.attempt(
      ej,
      E,
      p ? E : w
    )(R) : R === 91 ? t.attempt(
      tj,
      E,
      p ? S : w
    )(R) : p ? E(R) : w(R);
  }
  function S(R) {
    return t.attempt(
      nj,
      E,
      w
    )(R);
  }
  function E(R) {
    return n(R);
  }
  function w(R) {
    return f._balanced = !0, i(R);
  }
}
function oj(t, n, i) {
  return o;
  function o(w) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(w), t.exit("resourceMarker"), u;
  }
  function u(w) {
    return $a(w) ? Vv(t, f)(w) : f(w);
  }
  function f(w) {
    return w === 41 ? E(w) : lA(
      t,
      p,
      v,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(w);
  }
  function p(w) {
    return $a(w) ? Vv(t, b)(w) : E(w);
  }
  function v(w) {
    return i(w);
  }
  function b(w) {
    return w === 34 || w === 39 || w === 40 ? uA(
      t,
      S,
      i,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(w) : E(w);
  }
  function S(w) {
    return $a(w) ? Vv(t, E)(w) : E(w);
  }
  function E(w) {
    return w === 41 ? (t.enter("resourceMarker"), t.consume(w), t.exit("resourceMarker"), t.exit("resource"), n) : i(w);
  }
}
function lj(t, n, i) {
  const o = this;
  return u;
  function u(v) {
    return sA.call(
      o,
      t,
      f,
      p,
      "reference",
      "referenceMarker",
      "referenceString"
    )(v);
  }
  function f(v) {
    return o.parser.defined.includes(
      Jp(
        o.sliceSerialize(o.events[o.events.length - 1][1]).slice(1, -1)
      )
    ) ? n(v) : i(v);
  }
  function p(v) {
    return i(v);
  }
}
function sj(t, n, i) {
  return o;
  function o(f) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(f), t.exit("referenceMarker"), u;
  }
  function u(f) {
    return f === 93 ? (t.enter("referenceMarker"), t.consume(f), t.exit("referenceMarker"), t.exit("reference"), n) : i(f);
  }
}
const uj = {
  name: "labelStartImage",
  tokenize: cj,
  resolveAll: WE.resolveAll
};
function cj(t, n, i) {
  const o = this;
  return u;
  function u(v) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(v), t.exit("labelImageMarker"), f;
  }
  function f(v) {
    return v === 91 ? (t.enter("labelMarker"), t.consume(v), t.exit("labelMarker"), t.exit("labelImage"), p) : i(v);
  }
  function p(v) {
    return v === 94 && "_hiddenFootnoteSupport" in o.parser.constructs ? i(v) : n(v);
  }
}
const fj = {
  name: "labelStartLink",
  tokenize: dj,
  resolveAll: WE.resolveAll
};
function dj(t, n, i) {
  const o = this;
  return u;
  function u(p) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(p), t.exit("labelMarker"), t.exit("labelLink"), f;
  }
  function f(p) {
    return p === 94 && "_hiddenFootnoteSupport" in o.parser.constructs ? i(p) : n(p);
  }
}
const R_ = {
  name: "lineEnding",
  tokenize: pj
};
function pj(t, n) {
  return i;
  function i(o) {
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), Yn(t, n, "linePrefix");
  }
}
const xb = {
  name: "thematicBreak",
  tokenize: hj
};
function hj(t, n, i) {
  let o = 0, u;
  return f;
  function f(S) {
    return t.enter("thematicBreak"), p(S);
  }
  function p(S) {
    return u = S, v(S);
  }
  function v(S) {
    return S === u ? (t.enter("thematicBreakSequence"), b(S)) : o >= 3 && (S === null || Ot(S)) ? (t.exit("thematicBreak"), n(S)) : i(S);
  }
  function b(S) {
    return S === u ? (t.consume(S), o++, b) : (t.exit("thematicBreakSequence"), En(S) ? Yn(t, v, "whitespace")(S) : v(S));
  }
}
const Pa = {
  name: "list",
  tokenize: yj,
  continuation: {
    tokenize: gj
  },
  exit: Sj
}, mj = {
  tokenize: xj,
  partial: !0
}, vj = {
  tokenize: bj,
  partial: !0
};
function yj(t, n, i) {
  const o = this, u = o.events[o.events.length - 1];
  let f = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0, p = 0;
  return v;
  function v(k) {
    const N = o.containerState.type || (k === 42 || k === 43 || k === 45 ? "listUnordered" : "listOrdered");
    if (N === "listUnordered" ? !o.containerState.marker || k === o.containerState.marker : sE(k)) {
      if (o.containerState.type || (o.containerState.type = N, t.enter(N, {
        _container: !0
      })), N === "listUnordered")
        return t.enter("listItemPrefix"), k === 42 || k === 45 ? t.check(xb, i, S)(k) : S(k);
      if (!o.interrupt || k === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), b(k);
    }
    return i(k);
  }
  function b(k) {
    return sE(k) && ++p < 10 ? (t.consume(k), b) : (!o.interrupt || p < 2) && (o.containerState.marker ? k === o.containerState.marker : k === 41 || k === 46) ? (t.exit("listItemValue"), S(k)) : i(k);
  }
  function S(k) {
    return t.enter("listItemMarker"), t.consume(k), t.exit("listItemMarker"), o.containerState.marker = o.containerState.marker || k, t.check(
      PS,
      // Can’t be empty when interrupting.
      o.interrupt ? i : E,
      t.attempt(
        mj,
        R,
        w
      )
    );
  }
  function E(k) {
    return o.containerState.initialBlankLine = !0, f++, R(k);
  }
  function w(k) {
    return En(k) ? (t.enter("listItemPrefixWhitespace"), t.consume(k), t.exit("listItemPrefixWhitespace"), R) : i(k);
  }
  function R(k) {
    return o.containerState.size = f + o.sliceSerialize(t.exit("listItemPrefix"), !0).length, n(k);
  }
}
function gj(t, n, i) {
  const o = this;
  return o.containerState._closeFlow = void 0, t.check(PS, u, f);
  function u(v) {
    return o.containerState.furtherBlankLines = o.containerState.furtherBlankLines || o.containerState.initialBlankLine, Yn(
      t,
      n,
      "listItemIndent",
      o.containerState.size + 1
    )(v);
  }
  function f(v) {
    return o.containerState.furtherBlankLines || !En(v) ? (o.containerState.furtherBlankLines = void 0, o.containerState.initialBlankLine = void 0, p(v)) : (o.containerState.furtherBlankLines = void 0, o.containerState.initialBlankLine = void 0, t.attempt(vj, n, p)(v));
  }
  function p(v) {
    return o.containerState._closeFlow = !0, o.interrupt = void 0, Yn(
      t,
      t.attempt(Pa, n, i),
      "linePrefix",
      o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(v);
  }
}
function bj(t, n, i) {
  const o = this;
  return Yn(
    t,
    u,
    "listItemIndent",
    o.containerState.size + 1
  );
  function u(f) {
    const p = o.events[o.events.length - 1];
    return p && p[1].type === "listItemIndent" && p[2].sliceSerialize(p[1], !0).length === o.containerState.size ? n(f) : i(f);
  }
}
function Sj(t) {
  t.exit(this.containerState.type);
}
function xj(t, n, i) {
  const o = this;
  return Yn(
    t,
    u,
    "listItemPrefixWhitespace",
    o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function u(f) {
    const p = o.events[o.events.length - 1];
    return !En(f) && p && p[1].type === "listItemPrefixWhitespace" ? n(f) : i(f);
  }
}
const YR = {
  name: "setextUnderline",
  tokenize: _j,
  resolveTo: wj
};
function wj(t, n) {
  let i = t.length, o, u, f;
  for (; i--; )
    if (t[i][0] === "enter") {
      if (t[i][1].type === "content") {
        o = i;
        break;
      }
      t[i][1].type === "paragraph" && (u = i);
    } else
      t[i][1].type === "content" && t.splice(i, 1), !f && t[i][1].type === "definition" && (f = i);
  const p = {
    type: "setextHeading",
    start: Object.assign({}, t[u][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  };
  return t[u][1].type = "setextHeadingText", f ? (t.splice(u, 0, ["enter", p, n]), t.splice(f + 1, 0, ["exit", t[o][1], n]), t[o][1].end = Object.assign({}, t[f][1].end)) : t[o][1] = p, t.push(["exit", p, n]), t;
}
function _j(t, n, i) {
  const o = this;
  let u;
  return f;
  function f(S) {
    let E = o.events.length, w;
    for (; E--; )
      if (o.events[E][1].type !== "lineEnding" && o.events[E][1].type !== "linePrefix" && o.events[E][1].type !== "content") {
        w = o.events[E][1].type === "paragraph";
        break;
      }
    return !o.parser.lazy[o.now().line] && (o.interrupt || w) ? (t.enter("setextHeadingLine"), u = S, p(S)) : i(S);
  }
  function p(S) {
    return t.enter("setextHeadingLineSequence"), v(S);
  }
  function v(S) {
    return S === u ? (t.consume(S), v) : (t.exit("setextHeadingLineSequence"), En(S) ? Yn(t, b, "lineSuffix")(S) : b(S));
  }
  function b(S) {
    return S === null || Ot(S) ? (t.exit("setextHeadingLine"), n(S)) : i(S);
  }
}
const Ej = {
  tokenize: Cj
};
function Cj(t) {
  const n = this, i = t.attempt(
    // Try to parse a blank line.
    PS,
    o,
    // Try to parse initial flow (essentially, only code).
    t.attempt(
      this.parser.constructs.flowInitial,
      u,
      Yn(
        t,
        t.attempt(
          this.parser.constructs.flow,
          u,
          t.attempt(A$, u)
        ),
        "linePrefix"
      )
    )
  );
  return i;
  function o(f) {
    if (f === null) {
      t.consume(f);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(f), t.exit("lineEndingBlank"), n.currentConstruct = void 0, i;
  }
  function u(f) {
    if (f === null) {
      t.consume(f);
      return;
    }
    return t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), n.currentConstruct = void 0, i;
  }
}
const kj = {
  resolveAll: fA()
}, Tj = cA("string"), Rj = cA("text");
function cA(t) {
  return {
    tokenize: n,
    resolveAll: fA(
      t === "text" ? Oj : void 0
    )
  };
  function n(i) {
    const o = this, u = this.parser.constructs[t], f = i.attempt(u, p, v);
    return p;
    function p(E) {
      return S(E) ? f(E) : v(E);
    }
    function v(E) {
      if (E === null) {
        i.consume(E);
        return;
      }
      return i.enter("data"), i.consume(E), b;
    }
    function b(E) {
      return S(E) ? (i.exit("data"), f(E)) : (i.consume(E), b);
    }
    function S(E) {
      if (E === null)
        return !0;
      const w = u[E];
      let R = -1;
      if (w)
        for (; ++R < w.length; ) {
          const k = w[R];
          if (!k.previous || k.previous.call(o, o.previous))
            return !0;
        }
      return !1;
    }
  }
}
function fA(t) {
  return n;
  function n(i, o) {
    let u = -1, f;
    for (; ++u <= i.length; )
      f === void 0 ? i[u] && i[u][1].type === "data" && (f = u, u++) : (!i[u] || i[u][1].type !== "data") && (u !== f + 2 && (i[f][1].end = i[u - 1][1].end, i.splice(f + 2, u - f - 2), u = f + 2), f = void 0);
    return t ? t(i, o) : i;
  }
}
function Oj(t, n) {
  let i = 0;
  for (; ++i <= t.length; )
    if ((i === t.length || t[i][1].type === "lineEnding") && t[i - 1][1].type === "data") {
      const o = t[i - 1][1], u = n.sliceStream(o);
      let f = u.length, p = -1, v = 0, b;
      for (; f--; ) {
        const S = u[f];
        if (typeof S == "string") {
          for (p = S.length; S.charCodeAt(p - 1) === 32; )
            v++, p--;
          if (p)
            break;
          p = -1;
        } else if (S === -2)
          b = !0, v++;
        else if (S !== -1) {
          f++;
          break;
        }
      }
      if (v) {
        const S = {
          type: i === t.length || b || v < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: o.end.line,
            column: o.end.column - v,
            offset: o.end.offset - v,
            _index: o.start._index + f,
            _bufferIndex: f ? p : o.start._bufferIndex + p
          },
          end: Object.assign({}, o.end)
        };
        o.end = Object.assign({}, S.start), o.start.offset === o.end.offset ? Object.assign(o, S) : (t.splice(
          i,
          0,
          ["enter", S, n],
          ["exit", S, n]
        ), i += 2);
      }
      i++;
    }
  return t;
}
function Aj(t, n, i) {
  let o = Object.assign(
    i ? Object.assign({}, i) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, f = [];
  let p = [], v = [];
  const b = {
    consume: q,
    enter: G,
    exit: te,
    attempt: ue(ee),
    check: ue(V),
    interrupt: ue(V, {
      interrupt: !0
    })
  }, S = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: t,
    sliceStream: k,
    sliceSerialize: R,
    now: N,
    defineSkip: z,
    write: w
  };
  let E = n.tokenize.call(S, b);
  return n.resolveAll && f.push(n), S;
  function w(xe) {
    return p = Co(p, xe), I(), p[p.length - 1] !== null ? [] : (we(n, 0), S.events = VE(f, S.events, S), S.events);
  }
  function R(xe, ve) {
    return Mj(k(xe), ve);
  }
  function k(xe) {
    return Dj(p, xe);
  }
  function N() {
    const { line: xe, column: ve, offset: Pe, _index: Ue, _bufferIndex: We } = o;
    return {
      line: xe,
      column: ve,
      offset: Pe,
      _index: Ue,
      _bufferIndex: We
    };
  }
  function z(xe) {
    u[xe.line] = xe.column, Le();
  }
  function I() {
    let xe;
    for (; o._index < p.length; ) {
      const ve = p[o._index];
      if (typeof ve == "string")
        for (xe = o._index, o._bufferIndex < 0 && (o._bufferIndex = 0); o._index === xe && o._bufferIndex < ve.length; )
          H(ve.charCodeAt(o._bufferIndex));
      else
        H(ve);
    }
  }
  function H(xe) {
    E = E(xe);
  }
  function q(xe) {
    Ot(xe) ? (o.line++, o.column = 1, o.offset += xe === -3 ? 2 : 1, Le()) : xe !== -1 && (o.column++, o.offset++), o._bufferIndex < 0 ? o._index++ : (o._bufferIndex++, o._bufferIndex === p[o._index].length && (o._bufferIndex = -1, o._index++)), S.previous = xe;
  }
  function G(xe, ve) {
    const Pe = ve || {};
    return Pe.type = xe, Pe.start = N(), S.events.push(["enter", Pe, S]), v.push(Pe), Pe;
  }
  function te(xe) {
    const ve = v.pop();
    return ve.end = N(), S.events.push(["exit", ve, S]), ve;
  }
  function ee(xe, ve) {
    we(xe, ve.from);
  }
  function V(xe, ve) {
    ve.restore();
  }
  function ue(xe, ve) {
    return Pe;
    function Pe(Ue, We, at) {
      let Te, ye, Fe, O;
      return Array.isArray(Ue) ? De(Ue) : "tokenize" in Ue ? (
        // @ts-expect-error Looks like a construct.
        De([Ue])
      ) : ce(Ue);
      function ce(lt) {
        return Nt;
        function Nt(xt) {
          const Zt = xt !== null && lt[xt], er = xt !== null && lt.null, hr = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Zt) ? Zt : Zt ? [Zt] : [],
            ...Array.isArray(er) ? er : er ? [er] : []
          ];
          return De(hr)(xt);
        }
      }
      function De(lt) {
        return Te = lt, ye = 0, lt.length === 0 ? at : j(lt[ye]);
      }
      function j(lt) {
        return Nt;
        function Nt(xt) {
          return O = me(), Fe = lt, lt.partial || (S.currentConstruct = lt), lt.name && S.parser.constructs.disable.null.includes(lt.name) ? Mt() : lt.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            ve ? Object.assign(Object.create(S), ve) : S,
            b,
            rt,
            Mt
          )(xt);
        }
      }
      function rt(lt) {
        return xe(Fe, O), We;
      }
      function Mt(lt) {
        return O.restore(), ++ye < Te.length ? j(Te[ye]) : at;
      }
    }
  }
  function we(xe, ve) {
    xe.resolveAll && !f.includes(xe) && f.push(xe), xe.resolve && cs(
      S.events,
      ve,
      S.events.length - ve,
      xe.resolve(S.events.slice(ve), S)
    ), xe.resolveTo && (S.events = xe.resolveTo(S.events, S));
  }
  function me() {
    const xe = N(), ve = S.previous, Pe = S.currentConstruct, Ue = S.events.length, We = Array.from(v);
    return {
      restore: at,
      from: Ue
    };
    function at() {
      o = xe, S.previous = ve, S.currentConstruct = Pe, S.events.length = Ue, v = We, Le();
    }
  }
  function Le() {
    o.line in u && o.column < 2 && (o.column = u[o.line], o.offset += u[o.line] - 1);
  }
}
function Dj(t, n) {
  const i = n.start._index, o = n.start._bufferIndex, u = n.end._index, f = n.end._bufferIndex;
  let p;
  if (i === u)
    p = [t[i].slice(o, f)];
  else {
    if (p = t.slice(i, u), o > -1) {
      const v = p[0];
      typeof v == "string" ? p[0] = v.slice(o) : p.shift();
    }
    f > 0 && p.push(t[u].slice(0, f));
  }
  return p;
}
function Mj(t, n) {
  let i = -1;
  const o = [];
  let u;
  for (; ++i < t.length; ) {
    const f = t[i];
    let p;
    if (typeof f == "string")
      p = f;
    else
      switch (f) {
        case -5: {
          p = "\r";
          break;
        }
        case -4: {
          p = `
`;
          break;
        }
        case -3: {
          p = `\r
`;
          break;
        }
        case -2: {
          p = n ? " " : "	";
          break;
        }
        case -1: {
          if (!n && u)
            continue;
          p = " ";
          break;
        }
        default:
          p = String.fromCharCode(f);
      }
    u = f === -2, o.push(p);
  }
  return o.join("");
}
const Nj = {
  42: Pa,
  43: Pa,
  45: Pa,
  48: Pa,
  49: Pa,
  50: Pa,
  51: Pa,
  52: Pa,
  53: Pa,
  54: Pa,
  55: Pa,
  56: Pa,
  57: Pa,
  62: rA
}, Lj = {
  91: P$
}, Pj = {
  [-2]: T_,
  [-1]: T_,
  32: T_
}, zj = {
  35: U$,
  42: xb,
  45: [YR, xb],
  60: W$,
  61: YR,
  95: xb,
  96: VR,
  126: VR
}, $j = {
  38: aA,
  92: iA
}, jj = {
  [-5]: R_,
  [-4]: R_,
  [-3]: R_,
  33: uj,
  38: aA,
  42: uE,
  60: [d$, K$],
  91: fj,
  92: [I$, iA],
  93: WE,
  95: uE,
  96: C$
}, Ij = {
  null: [uE, kj]
}, Fj = {
  null: [42, 95]
}, Uj = {
  null: []
}, Bj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Fj,
  contentInitial: Lj,
  disable: Uj,
  document: Nj,
  flow: zj,
  flowInitial: Pj,
  insideSpan: Ij,
  string: $j,
  text: jj
}, Symbol.toStringTag, { value: "Module" }));
function Hj(t) {
  const i = (
    /** @type {FullNormalizedExtension} */
    Qz([Bj, ...(t || {}).extensions || []])
  ), o = {
    defined: [],
    lazy: {},
    constructs: i,
    content: u(a$),
    document: u(l$),
    flow: u(Ej),
    string: u(Tj),
    text: u(Rj)
  };
  return o;
  function u(f) {
    return p;
    function p(v) {
      return Aj(o, f, v);
    }
  }
}
function Vj(t) {
  for (; !oA(t); )
    ;
  return t;
}
const ZR = /[\0\t\n\r]/g;
function Wj() {
  let t = 1, n = "", i = !0, o;
  return u;
  function u(f, p, v) {
    const b = [];
    let S, E, w, R, k;
    for (f = n + (typeof f == "string" ? f.toString() : new TextDecoder(p || void 0).decode(f)), w = 0, n = "", i && (f.charCodeAt(0) === 65279 && w++, i = void 0); w < f.length; ) {
      if (ZR.lastIndex = w, S = ZR.exec(f), R = S && S.index !== void 0 ? S.index : f.length, k = f.charCodeAt(R), !S) {
        n = f.slice(w);
        break;
      }
      if (k === 10 && w === R && o)
        b.push(-3), o = void 0;
      else
        switch (o && (b.push(-5), o = void 0), w < R && (b.push(f.slice(w, R)), t += R - w), k) {
          case 0: {
            b.push(65533), t++;
            break;
          }
          case 9: {
            for (E = Math.ceil(t / 4) * 4, b.push(-2); t++ < E; )
              b.push(-1);
            break;
          }
          case 10: {
            b.push(-4), t = 1;
            break;
          }
          default:
            o = !0, t = 1;
        }
      w = R + 1;
    }
    return v && (o && b.push(-5), n && b.push(n), b.push(null)), b;
  }
}
const Yj = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Zj(t) {
  return t.replace(Yj, qj);
}
function qj(t, n, i) {
  if (n)
    return n;
  if (i.charCodeAt(0) === 35) {
    const u = i.charCodeAt(1), f = u === 120 || u === 88;
    return nA(i.slice(f ? 2 : 1), f ? 16 : 10);
  }
  return HE(i) || t;
}
function Wv(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? qR(t.position) : "start" in t || "end" in t ? qR(t) : "line" in t || "column" in t ? cE(t) : "";
}
function cE(t) {
  return GR(t && t.line) + ":" + GR(t && t.column);
}
function qR(t) {
  return cE(t && t.start) + "-" + cE(t && t.end);
}
function GR(t) {
  return t && typeof t == "number" ? t : 1;
}
const dA = {}.hasOwnProperty;
function pA(t, n, i) {
  return typeof n != "string" && (i = n, n = void 0), Gj(i)(
    Vj(
      Hj(i).document().write(Wj()(t, n, !0))
    )
  );
}
function Gj(t) {
  const n = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: f(jr),
      autolinkProtocol: me,
      autolinkEmail: me,
      atxHeading: f(sr),
      blockQuote: f(Zt),
      characterEscape: me,
      characterReference: me,
      codeFenced: f(er),
      codeFencedFenceInfo: p,
      codeFencedFenceMeta: p,
      codeIndented: f(er, p),
      codeText: f(hr, p),
      codeTextData: me,
      data: me,
      codeFlowValue: me,
      definition: f(Jr),
      definitionDestinationString: p,
      definitionLabelString: p,
      definitionTitleString: p,
      emphasis: f(zn),
      hardBreakEscape: f(tr),
      hardBreakTrailing: f(tr),
      htmlFlow: f(nr, p),
      htmlFlowData: me,
      htmlText: f(nr, p),
      htmlTextData: me,
      image: f(Zn),
      label: p,
      link: f(jr),
      listItem: f(mr),
      listItemValue: R,
      listOrdered: f(Ir, w),
      listUnordered: f(Ir),
      paragraph: f(Tr),
      reference: j,
      referenceString: p,
      resourceDestinationString: p,
      resourceTitleString: p,
      setextHeading: f(sr),
      strong: f(ei),
      thematicBreak: f(ci)
    },
    exit: {
      atxHeading: b(),
      atxHeadingSequence: ee,
      autolink: b(),
      autolinkEmail: xt,
      autolinkProtocol: Nt,
      blockQuote: b(),
      characterEscapeValue: Le,
      characterReferenceMarkerHexadecimal: Mt,
      characterReferenceMarkerNumeric: Mt,
      characterReferenceValue: lt,
      codeFenced: b(I),
      codeFencedFence: z,
      codeFencedFenceInfo: k,
      codeFencedFenceMeta: N,
      codeFlowValue: Le,
      codeIndented: b(H),
      codeText: b(We),
      codeTextData: Le,
      data: Le,
      definition: b(),
      definitionDestinationString: te,
      definitionLabelString: q,
      definitionTitleString: G,
      emphasis: b(),
      hardBreakEscape: b(ve),
      hardBreakTrailing: b(ve),
      htmlFlow: b(Pe),
      htmlFlowData: Le,
      htmlText: b(Ue),
      htmlTextData: Le,
      image: b(Te),
      label: Fe,
      labelText: ye,
      lineEnding: xe,
      link: b(at),
      listItem: b(),
      listOrdered: b(),
      listUnordered: b(),
      paragraph: b(),
      referenceString: rt,
      resourceDestinationString: O,
      resourceTitleString: ce,
      resource: De,
      setextHeading: b(we),
      setextHeadingLineSequence: ue,
      setextHeadingText: V,
      strong: b(),
      thematicBreak: b()
    }
  };
  hA(n, (t || {}).mdastExtensions || []);
  const i = {};
  return o;
  function o(le) {
    let Ce = {
      type: "root",
      children: []
    };
    const Ge = {
      stack: [Ce],
      tokenStack: [],
      config: n,
      enter: v,
      exit: S,
      buffer: p,
      resume: E,
      data: i
    }, gt = [];
    let It = -1;
    for (; ++It < le.length; )
      if (le[It][1].type === "listOrdered" || le[It][1].type === "listUnordered")
        if (le[It][0] === "enter")
          gt.push(It);
        else {
          const $n = gt.pop();
          It = u(le, $n, It);
        }
    for (It = -1; ++It < le.length; ) {
      const $n = n[le[It][0]];
      dA.call($n, le[It][1].type) && $n[le[It][1].type].call(
        Object.assign(
          {
            sliceSerialize: le[It][2].sliceSerialize
          },
          Ge
        ),
        le[It][1]
      );
    }
    if (Ge.tokenStack.length > 0) {
      const $n = Ge.tokenStack[Ge.tokenStack.length - 1];
      ($n[1] || XR).call(Ge, void 0, $n[0]);
    }
    for (Ce.position = {
      start: _c(
        le.length > 0 ? le[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: _c(
        le.length > 0 ? le[le.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, It = -1; ++It < n.transforms.length; )
      Ce = n.transforms[It](Ce) || Ce;
    return Ce;
  }
  function u(le, Ce, Ge) {
    let gt = Ce - 1, It = -1, $n = !1, Re, Xe, Ct, qt;
    for (; ++gt <= Ge; ) {
      const At = le[gt];
      switch (At[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          At[0] === "enter" ? It++ : It--, qt = void 0;
          break;
        }
        case "lineEndingBlank": {
          At[0] === "enter" && (Re && !qt && !It && !Ct && (Ct = gt), qt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          qt = void 0;
      }
      if (!It && At[0] === "enter" && At[1].type === "listItemPrefix" || It === -1 && At[0] === "exit" && (At[1].type === "listUnordered" || At[1].type === "listOrdered")) {
        if (Re) {
          let Cn = gt;
          for (Xe = void 0; Cn--; ) {
            const sn = le[Cn];
            if (sn[1].type === "lineEnding" || sn[1].type === "lineEndingBlank") {
              if (sn[0] === "exit")
                continue;
              Xe && (le[Xe][1].type = "lineEndingBlank", $n = !0), sn[1].type = "lineEnding", Xe = Cn;
            } else if (!(sn[1].type === "linePrefix" || sn[1].type === "blockQuotePrefix" || sn[1].type === "blockQuotePrefixWhitespace" || sn[1].type === "blockQuoteMarker" || sn[1].type === "listItemIndent"))
              break;
          }
          Ct && (!Xe || Ct < Xe) && (Re._spread = !0), Re.end = Object.assign(
            {},
            Xe ? le[Xe][1].start : At[1].end
          ), le.splice(Xe || gt, 0, ["exit", Re, At[2]]), gt++, Ge++;
        }
        if (At[1].type === "listItemPrefix") {
          const Cn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, At[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Re = Cn, le.splice(gt, 0, ["enter", Cn, At[2]]), gt++, Ge++, Ct = void 0, qt = !0;
        }
      }
    }
    return le[Ce][1]._spread = $n, Ge;
  }
  function f(le, Ce) {
    return Ge;
    function Ge(gt) {
      v.call(this, le(gt), gt), Ce && Ce.call(this, gt);
    }
  }
  function p() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function v(le, Ce, Ge) {
    this.stack[this.stack.length - 1].children.push(le), this.stack.push(le), this.tokenStack.push([Ce, Ge]), le.position = {
      start: _c(Ce.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function b(le) {
    return Ce;
    function Ce(Ge) {
      le && le.call(this, Ge), S.call(this, Ge);
    }
  }
  function S(le, Ce) {
    const Ge = this.stack.pop(), gt = this.tokenStack.pop();
    if (gt)
      gt[0].type !== le.type && (Ce ? Ce.call(this, le, gt[0]) : (gt[1] || XR).call(this, le, gt[0]));
    else
      throw new Error(
        "Cannot close `" + le.type + "` (" + Wv({
          start: le.start,
          end: le.end
        }) + "): it’s not open"
      );
    Ge.position.end = _c(le.end);
  }
  function E() {
    return Gz(this.stack.pop());
  }
  function w() {
    this.data.expectingFirstListItemValue = !0;
  }
  function R(le) {
    if (this.data.expectingFirstListItemValue) {
      const Ce = this.stack[this.stack.length - 2];
      Ce.start = Number.parseInt(this.sliceSerialize(le), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function k() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.lang = le;
  }
  function N() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.meta = le;
  }
  function z() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function I() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = le.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function H() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = le.replace(/(\r?\n|\r)$/g, "");
  }
  function q(le) {
    const Ce = this.resume(), Ge = this.stack[this.stack.length - 1];
    Ge.label = Ce, Ge.identifier = Jp(
      this.sliceSerialize(le)
    ).toLowerCase();
  }
  function G() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.title = le;
  }
  function te() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.url = le;
  }
  function ee(le) {
    const Ce = this.stack[this.stack.length - 1];
    if (!Ce.depth) {
      const Ge = this.sliceSerialize(le).length;
      Ce.depth = Ge;
    }
  }
  function V() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function ue(le) {
    const Ce = this.stack[this.stack.length - 1];
    Ce.depth = this.sliceSerialize(le).codePointAt(0) === 61 ? 1 : 2;
  }
  function we() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function me(le) {
    const Ge = this.stack[this.stack.length - 1].children;
    let gt = Ge[Ge.length - 1];
    (!gt || gt.type !== "text") && (gt = Rr(), gt.position = {
      start: _c(le.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, Ge.push(gt)), this.stack.push(gt);
  }
  function Le(le) {
    const Ce = this.stack.pop();
    Ce.value += this.sliceSerialize(le), Ce.position.end = _c(le.end);
  }
  function xe(le) {
    const Ce = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ge = Ce.children[Ce.children.length - 1];
      Ge.position.end = _c(le.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && n.canContainEols.includes(Ce.type) && (me.call(this, le), Le.call(this, le));
  }
  function ve() {
    this.data.atHardBreak = !0;
  }
  function Pe() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = le;
  }
  function Ue() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = le;
  }
  function We() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = le;
  }
  function at() {
    const le = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ce = this.data.referenceType || "shortcut";
      le.type += "Reference", le.referenceType = Ce, delete le.url, delete le.title;
    } else
      delete le.identifier, delete le.label;
    this.data.referenceType = void 0;
  }
  function Te() {
    const le = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ce = this.data.referenceType || "shortcut";
      le.type += "Reference", le.referenceType = Ce, delete le.url, delete le.title;
    } else
      delete le.identifier, delete le.label;
    this.data.referenceType = void 0;
  }
  function ye(le) {
    const Ce = this.sliceSerialize(le), Ge = this.stack[this.stack.length - 2];
    Ge.label = Zj(Ce), Ge.identifier = Jp(Ce).toLowerCase();
  }
  function Fe() {
    const le = this.stack[this.stack.length - 1], Ce = this.resume(), Ge = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ge.type === "link") {
      const gt = le.children;
      Ge.children = gt;
    } else
      Ge.alt = Ce;
  }
  function O() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.url = le;
  }
  function ce() {
    const le = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.title = le;
  }
  function De() {
    this.data.inReference = void 0;
  }
  function j() {
    this.data.referenceType = "collapsed";
  }
  function rt(le) {
    const Ce = this.resume(), Ge = this.stack[this.stack.length - 1];
    Ge.label = Ce, Ge.identifier = Jp(
      this.sliceSerialize(le)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Mt(le) {
    this.data.characterReferenceType = le.type;
  }
  function lt(le) {
    const Ce = this.sliceSerialize(le), Ge = this.data.characterReferenceType;
    let gt;
    Ge ? (gt = nA(
      Ce,
      Ge === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : gt = HE(Ce);
    const It = this.stack.pop();
    It.value += gt, It.position.end = _c(le.end);
  }
  function Nt(le) {
    Le.call(this, le);
    const Ce = this.stack[this.stack.length - 1];
    Ce.url = this.sliceSerialize(le);
  }
  function xt(le) {
    Le.call(this, le);
    const Ce = this.stack[this.stack.length - 1];
    Ce.url = "mailto:" + this.sliceSerialize(le);
  }
  function Zt() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function er() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function hr() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Jr() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function zn() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function sr() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function tr() {
    return {
      type: "break"
    };
  }
  function nr() {
    return {
      type: "html",
      value: ""
    };
  }
  function Zn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function jr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Ir(le) {
    return {
      type: "list",
      ordered: le.type === "listOrdered",
      start: null,
      spread: le._spread,
      children: []
    };
  }
  function mr(le) {
    return {
      type: "listItem",
      spread: le._spread,
      checked: null,
      children: []
    };
  }
  function Tr() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ei() {
    return {
      type: "strong",
      children: []
    };
  }
  function Rr() {
    return {
      type: "text",
      value: ""
    };
  }
  function ci() {
    return {
      type: "thematicBreak"
    };
  }
}
function _c(t) {
  return {
    line: t.line,
    column: t.column,
    offset: t.offset
  };
}
function hA(t, n) {
  let i = -1;
  for (; ++i < n.length; ) {
    const o = n[i];
    Array.isArray(o) ? hA(t, o) : Xj(t, o);
  }
}
function Xj(t, n) {
  let i;
  for (i in n)
    if (dA.call(n, i))
      switch (i) {
        case "canContainEols": {
          const o = n[i];
          o && t[i].push(...o);
          break;
        }
        case "transforms": {
          const o = n[i];
          o && t[i].push(...o);
          break;
        }
        case "enter":
        case "exit": {
          const o = n[i];
          o && Object.assign(t[i], o);
          break;
        }
      }
}
function XR(t, n) {
  throw t ? new Error(
    "Cannot close `" + t.type + "` (" + Wv({
      start: t.start,
      end: t.end
    }) + "): a different token (`" + n.type + "`, " + Wv({
      start: n.start,
      end: n.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + n.type + "`, " + Wv({
      start: n.start,
      end: n.end
    }) + ") is still open"
  );
}
const Vp = "4.29.2";
let QR = !1, Yv, mA, vA, fE, yA, gA, bA, SA, xA;
function Qj(t, n = { auto: !1 }) {
  if (QR)
    throw new Error(`you must \`import 'openai/shims/${t.kind}'\` before importing anything else from openai`);
  if (Yv)
    throw new Error(`can't \`import 'openai/shims/${t.kind}'\` after \`import 'openai/shims/${Yv}'\``);
  QR = n.auto, Yv = t.kind, mA = t.fetch, t.Request, t.Response, t.Headers, vA = t.FormData, t.Blob, fE = t.File, yA = t.ReadableStream, gA = t.getMultipartRequestOptions, bA = t.getDefaultAgent, SA = t.fileFromPath, xA = t.isFsReadStream;
}
class Kj {
  constructor(n) {
    this.body = n;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}
function Jj({ manuallyImported: t } = {}) {
  const n = t ? "You may need to use polyfills" : "Add one of these imports before your first `import … from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n";
  let i, o, u, f;
  try {
    i = fetch, o = Request, u = Response, f = Headers;
  } catch (p) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${p.message}. ${n}`);
  }
  return {
    kind: "web",
    fetch: i,
    Request: o,
    Response: u,
    Headers: f,
    FormData: (
      // @ts-ignore
      typeof FormData < "u" ? FormData : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${n}`);
        }
      }
    ),
    Blob: typeof Blob < "u" ? Blob : class {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${n}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File < "u" ? File : class {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${n}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream < "u" ? ReadableStream : class {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${n}`);
        }
      }
    ),
    getMultipartRequestOptions: async (p, v) => ({
      ...v,
      body: new Kj(p)
    }),
    getDefaultAgent: (p) => {
    },
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (p) => !1
  };
}
Yv || Qj(Jj(), { auto: !0 });
class pn extends Error {
}
class Ti extends pn {
  constructor(n, i, o, u) {
    super(`${Ti.makeMessage(n, i, o)}`), this.status = n, this.headers = u;
    const f = i;
    this.error = f, this.code = f == null ? void 0 : f.code, this.param = f == null ? void 0 : f.param, this.type = f == null ? void 0 : f.type;
  }
  static makeMessage(n, i, o) {
    const u = i != null && i.message ? typeof i.message == "string" ? i.message : JSON.stringify(i.message) : i ? JSON.stringify(i) : o;
    return n && u ? `${n} ${u}` : n ? `${n} status code (no body)` : u || "(no status code or body)";
  }
  static generate(n, i, o, u) {
    if (!n)
      return new zS({ cause: pE(i) });
    const f = i == null ? void 0 : i.error;
    return n === 400 ? new wA(n, f, o, u) : n === 401 ? new _A(n, f, o, u) : n === 403 ? new EA(n, f, o, u) : n === 404 ? new CA(n, f, o, u) : n === 409 ? new kA(n, f, o, u) : n === 422 ? new TA(n, f, o, u) : n === 429 ? new RA(n, f, o, u) : n >= 500 ? new OA(n, f, o, u) : new Ti(n, f, o, u);
  }
}
class ko extends Ti {
  constructor({ message: n } = {}) {
    super(void 0, void 0, n || "Request was aborted.", void 0), this.status = void 0;
  }
}
class zS extends Ti {
  constructor({ message: n, cause: i }) {
    super(void 0, void 0, n || "Connection error.", void 0), this.status = void 0, i && (this.cause = i);
  }
}
class YE extends zS {
  constructor({ message: n } = {}) {
    super({ message: n ?? "Request timed out." });
  }
}
class wA extends Ti {
  constructor() {
    super(...arguments), this.status = 400;
  }
}
class _A extends Ti {
  constructor() {
    super(...arguments), this.status = 401;
  }
}
class EA extends Ti {
  constructor() {
    super(...arguments), this.status = 403;
  }
}
class CA extends Ti {
  constructor() {
    super(...arguments), this.status = 404;
  }
}
class kA extends Ti {
  constructor() {
    super(...arguments), this.status = 409;
  }
}
class TA extends Ti {
  constructor() {
    super(...arguments), this.status = 422;
  }
}
class RA extends Ti {
  constructor() {
    super(...arguments), this.status = 429;
  }
}
class OA extends Ti {
}
class uu {
  constructor(n, i) {
    this.iterator = n, this.controller = i;
  }
  static fromSSEResponse(n, i) {
    let o = !1;
    const u = new e9();
    async function* f() {
      if (!n.body)
        throw i.abort(), new pn("Attempted to iterate over a response with no body");
      const v = new Zf(), b = KR(n.body);
      for await (const S of b)
        for (const E of v.decode(S)) {
          const w = u.decode(E);
          w && (yield w);
        }
      for (const S of v.flush()) {
        const E = u.decode(S);
        E && (yield E);
      }
    }
    async function* p() {
      if (o)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      o = !0;
      let v = !1;
      try {
        for await (const b of f())
          if (!v) {
            if (b.data.startsWith("[DONE]")) {
              v = !0;
              continue;
            }
            if (b.event === null) {
              let S;
              try {
                S = JSON.parse(b.data);
              } catch (E) {
                throw console.error("Could not parse message into JSON:", b.data), console.error("From chunk:", b.raw), E;
              }
              if (S && S.error)
                throw new Ti(void 0, S.error, void 0, void 0);
              yield S;
            } else {
              let S;
              try {
                S = JSON.parse(b.data);
              } catch (E) {
                throw console.error("Could not parse message into JSON:", b.data), console.error("From chunk:", b.raw), E;
              }
              if (b.event == "error")
                throw new Ti(void 0, S.error, S.message, void 0);
              yield { event: b.event, data: S };
            }
          }
        v = !0;
      } catch (b) {
        if (b instanceof Error && b.name === "AbortError")
          return;
        throw b;
      } finally {
        v || i.abort();
      }
    }
    return new uu(p, i);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(n, i) {
    let o = !1;
    async function* u() {
      const p = new Zf(), v = KR(n);
      for await (const b of v)
        for (const S of p.decode(b))
          yield S;
      for (const b of p.flush())
        yield b;
    }
    async function* f() {
      if (o)
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      o = !0;
      let p = !1;
      try {
        for await (const v of u())
          p || v && (yield JSON.parse(v));
        p = !0;
      } catch (v) {
        if (v instanceof Error && v.name === "AbortError")
          return;
        throw v;
      } finally {
        p || i.abort();
      }
    }
    return new uu(f, i);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const n = [], i = [], o = this.iterator(), u = (f) => ({
      next: () => {
        if (f.length === 0) {
          const p = o.next();
          n.push(p), i.push(p);
        }
        return f.shift();
      }
    });
    return [
      new uu(() => u(n), this.controller),
      new uu(() => u(i), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const n = this;
    let i;
    const o = new TextEncoder();
    return new yA({
      async start() {
        i = n[Symbol.asyncIterator]();
      },
      async pull(u) {
        try {
          const { value: f, done: p } = await i.next();
          if (p)
            return u.close();
          const v = o.encode(JSON.stringify(f) + `
`);
          u.enqueue(v);
        } catch (f) {
          u.error(f);
        }
      },
      async cancel() {
        var u;
        await ((u = i.return) == null ? void 0 : u.call(i));
      }
    });
  }
}
class e9 {
  constructor() {
    this.event = null, this.data = [], this.chunks = [];
  }
  decode(n) {
    if (n.endsWith("\r") && (n = n.substring(0, n.length - 1)), !n) {
      if (!this.event && !this.data.length)
        return null;
      const f = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], f;
    }
    if (this.chunks.push(n), n.startsWith(":"))
      return null;
    let [i, o, u] = t9(n, ":");
    return u.startsWith(" ") && (u = u.substring(1)), i === "event" ? this.event = u : i === "data" && this.data.push(u), null;
  }
}
class Zf {
  constructor() {
    this.buffer = [], this.trailingCR = !1;
  }
  decode(n) {
    let i = this.decodeText(n);
    if (this.trailingCR && (i = "\r" + i, this.trailingCR = !1), i.endsWith("\r") && (this.trailingCR = !0, i = i.slice(0, -1)), !i)
      return [];
    const o = Zf.NEWLINE_CHARS.has(i[i.length - 1] || "");
    let u = i.split(Zf.NEWLINE_REGEXP);
    return o && u.pop(), u.length === 1 && !o ? (this.buffer.push(u[0]), []) : (this.buffer.length > 0 && (u = [this.buffer.join("") + u[0], ...u.slice(1)], this.buffer = []), o || (this.buffer = [u.pop() || ""]), u);
  }
  decodeText(n) {
    if (n == null)
      return "";
    if (typeof n == "string")
      return n;
    if (typeof Buffer < "u") {
      if (n instanceof Buffer)
        return n.toString();
      if (n instanceof Uint8Array)
        return Buffer.from(n).toString();
      throw new pn(`Unexpected: received non-Uint8Array (${n.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder < "u") {
      if (n instanceof Uint8Array || n instanceof ArrayBuffer)
        return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")), this.textDecoder.decode(n);
      throw new pn(`Unexpected: received non-Uint8Array/ArrayBuffer (${n.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new pn("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.");
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR)
      return [];
    const n = [this.buffer.join("")];
    return this.buffer = [], this.trailingCR = !1, n;
  }
}
Zf.NEWLINE_CHARS = /* @__PURE__ */ new Set([`
`, "\r", "\v", "\f", "", "", "", "", "\u2028", "\u2029"]);
Zf.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function t9(t, n) {
  const i = t.indexOf(n);
  return i !== -1 ? [t.substring(0, i), n, t.substring(i + n.length)] : [t, "", ""];
}
function KR(t) {
  if (t[Symbol.asyncIterator])
    return t;
  const n = t.getReader();
  return {
    async next() {
      try {
        const i = await n.read();
        return i != null && i.done && n.releaseLock(), i;
      } catch (i) {
        throw n.releaseLock(), i;
      }
    },
    async return() {
      const i = n.cancel();
      return n.releaseLock(), await i, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
const AA = (t) => t != null && typeof t == "object" && typeof t.url == "string" && typeof t.blob == "function", n9 = (t) => t != null && typeof t == "object" && typeof t.name == "string" && typeof t.lastModified == "number" && DA(t), DA = (t) => t != null && typeof t == "object" && typeof t.size == "number" && typeof t.type == "string" && typeof t.text == "function" && typeof t.slice == "function" && typeof t.arrayBuffer == "function", r9 = (t) => n9(t) || AA(t) || xA(t);
async function MA(t, n, i = {}) {
  var u;
  if (t = await t, AA(t)) {
    const f = await t.blob();
    return n || (n = new URL(t.url).pathname.split(/[\\/]/).pop() ?? "unknown_file"), new fE([f], n, i);
  }
  const o = await i9(t);
  if (n || (n = o9(t) ?? "unknown_file"), !i.type) {
    const f = (u = o[0]) == null ? void 0 : u.type;
    typeof f == "string" && (i = { ...i, type: f });
  }
  return new fE(o, n, i);
}
async function i9(t) {
  var i;
  let n = [];
  if (typeof t == "string" || ArrayBuffer.isView(t) || // includes Uint8Array, Buffer, etc.
  t instanceof ArrayBuffer)
    n.push(t);
  else if (DA(t))
    n.push(await t.arrayBuffer());
  else if (l9(t))
    for await (const o of t)
      n.push(o);
  else
    throw new Error(`Unexpected data type: ${typeof t}; constructor: ${(i = t == null ? void 0 : t.constructor) == null ? void 0 : i.name}; props: ${a9(t)}`);
  return n;
}
function a9(t) {
  return `[${Object.getOwnPropertyNames(t).map((i) => `"${i}"`).join(", ")}]`;
}
function o9(t) {
  var n;
  return O_(t.name) || O_(t.filename) || // For fs.ReadStream
  ((n = O_(t.path)) == null ? void 0 : n.split(/[\\/]/).pop());
}
const O_ = (t) => {
  if (typeof t == "string")
    return t;
  if (typeof Buffer < "u" && t instanceof Buffer)
    return String(t);
}, l9 = (t) => t != null && typeof t == "object" && typeof t[Symbol.asyncIterator] == "function", JR = (t) => t && typeof t == "object" && t.body && t[Symbol.toStringTag] === "MultipartBody", Kv = async (t) => {
  const n = await s9(t.body);
  return gA(n, t);
}, s9 = async (t) => {
  const n = new vA();
  return await Promise.all(Object.entries(t || {}).map(([i, o]) => dE(n, i, o))), n;
}, dE = async (t, n, i) => {
  if (i !== void 0) {
    if (i == null)
      throw new TypeError(`Received null for "${n}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof i == "string" || typeof i == "number" || typeof i == "boolean")
      t.append(n, String(i));
    else if (r9(i)) {
      const o = await MA(i);
      t.append(n, o);
    } else if (Array.isArray(i))
      await Promise.all(i.map((o) => dE(t, n + "[]", o)));
    else if (typeof i == "object")
      await Promise.all(Object.entries(i).map(([o, u]) => dE(t, `${n}[${o}]`, u)));
    else
      throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${i} instead`);
  }
};
var u9 = function(t, n, i, o, u) {
  if (o === "m")
    throw new TypeError("Private method is not writable");
  if (o === "a" && !u)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? t !== n || !u : !n.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? u.call(t, i) : u ? u.value = i : n.set(t, i), i;
}, c9 = function(t, n, i, o) {
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? t !== n || !o : !n.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return i === "m" ? o : i === "a" ? o.call(t) : o ? o.value : n.get(t);
}, fb;
async function NA(t) {
  const { response: n } = t;
  if (t.options.stream)
    return eh("response", n.status, n.url, n.headers, n.body), t.options.__streamClass ? t.options.__streamClass.fromSSEResponse(n, t.controller) : uu.fromSSEResponse(n, t.controller);
  if (n.status === 204)
    return null;
  if (t.options.__binaryResponse)
    return n;
  const i = n.headers.get("content-type");
  if ((i == null ? void 0 : i.includes("application/json")) || (i == null ? void 0 : i.includes("application/vnd.api+json"))) {
    const f = await n.json();
    return eh("response", n.status, n.url, n.headers, f), f;
  }
  const u = await n.text();
  return eh("response", n.status, n.url, n.headers, u), u;
}
class $S extends Promise {
  constructor(n, i = NA) {
    super((o) => {
      o(null);
    }), this.responsePromise = n, this.parseResponse = i;
  }
  _thenUnwrap(n) {
    return new $S(this.responsePromise, async (i) => n(await this.parseResponse(i)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((n) => n.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [n, i] = await Promise.all([this.parse(), this.asResponse()]);
    return { data: n, response: i };
  }
  parse() {
    return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)), this.parsedPromise;
  }
  then(n, i) {
    return this.parse().then(n, i);
  }
  catch(n) {
    return this.parse().catch(n);
  }
  finally(n) {
    return this.parse().finally(n);
  }
}
class f9 {
  constructor({
    baseURL: n,
    maxRetries: i = 2,
    timeout: o = 6e5,
    // 10 minutes
    httpAgent: u,
    fetch: f
  }) {
    this.baseURL = n, this.maxRetries = A_("maxRetries", i), this.timeout = A_("timeout", o), this.httpAgent = u, this.fetch = f ?? mA;
  }
  authHeaders(n) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(n) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...y9(),
      ...this.authHeaders(n)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(n, i) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${x9()}`;
  }
  get(n, i) {
    return this.methodRequest("get", n, i);
  }
  post(n, i) {
    return this.methodRequest("post", n, i);
  }
  patch(n, i) {
    return this.methodRequest("patch", n, i);
  }
  put(n, i) {
    return this.methodRequest("put", n, i);
  }
  delete(n, i) {
    return this.methodRequest("delete", n, i);
  }
  methodRequest(n, i, o) {
    return this.request(Promise.resolve(o).then((u) => ({ method: n, path: i, ...u })));
  }
  getAPIList(n, i, o) {
    return this.requestAPIList(i, { method: "get", path: n, ...o });
  }
  calculateContentLength(n) {
    if (typeof n == "string") {
      if (typeof Buffer < "u")
        return Buffer.byteLength(n, "utf8").toString();
      if (typeof TextEncoder < "u")
        return new TextEncoder().encode(n).length.toString();
    }
    return null;
  }
  buildRequest(n) {
    var N;
    const { method: i, path: o, query: u, headers: f = {} } = n, p = JR(n.body) ? n.body.body : n.body ? JSON.stringify(n.body, null, 2) : null, v = this.calculateContentLength(p), b = this.buildURL(o, u);
    "timeout" in n && A_("timeout", n.timeout);
    const S = n.timeout ?? this.timeout, E = n.httpAgent ?? this.httpAgent ?? bA(b), w = S + 1e3;
    typeof ((N = E == null ? void 0 : E.options) == null ? void 0 : N.timeout) == "number" && w > (E.options.timeout ?? 0) && (E.options.timeout = w), this.idempotencyHeader && i !== "get" && (n.idempotencyKey || (n.idempotencyKey = this.defaultIdempotencyKey()), f[this.idempotencyHeader] = n.idempotencyKey);
    const R = this.buildHeaders({ options: n, headers: f, contentLength: v });
    return { req: {
      method: i,
      ...p && { body: p },
      headers: R,
      ...E && { agent: E },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: n.signal ?? null
    }, url: b, timeout: S };
  }
  buildHeaders({ options: n, headers: i, contentLength: o }) {
    const u = {};
    o && (u["content-length"] = o);
    const f = this.defaultHeaders(n);
    return rO(u, f), rO(u, i), JR(n.body) && Yv !== "node" && delete u["content-type"], this.validateHeaders(u, i), u;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(n) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(n, { url: i, options: o }) {
  }
  parseHeaders(n) {
    return n ? Symbol.iterator in n ? Object.fromEntries(Array.from(n).map((i) => [...i])) : { ...n } : {};
  }
  makeStatusError(n, i, o, u) {
    return Ti.generate(n, i, o, u);
  }
  request(n, i = null) {
    return new $S(this.makeRequest(n, i));
  }
  async makeRequest(n, i) {
    var E, w;
    const o = await n;
    i == null && (i = o.maxRetries ?? this.maxRetries), await this.prepareOptions(o);
    const { req: u, url: f, timeout: p } = this.buildRequest(o);
    if (await this.prepareRequest(u, { url: f, options: o }), eh("request", f, o, u.headers), (E = o.signal) != null && E.aborted)
      throw new ko();
    const v = new AbortController(), b = await this.fetchWithTimeout(f, u, p, v).catch(pE);
    if (b instanceof Error) {
      if ((w = o.signal) != null && w.aborted)
        throw new ko();
      if (i)
        return this.retryRequest(o, i);
      throw b.name === "AbortError" ? new YE() : new zS({ cause: b });
    }
    const S = p9(b.headers);
    if (!b.ok) {
      if (i && this.shouldRetry(b)) {
        const H = `retrying, ${i} attempts remaining`;
        return eh(`response (error; ${H})`, b.status, f, S), this.retryRequest(o, i, S);
      }
      const R = await b.text().catch((H) => pE(H).message), k = g9(R), N = k ? void 0 : R;
      throw eh(`response (error; ${i ? "(error; no more retries left)" : "(error; not retryable)"})`, b.status, f, S, N), this.makeStatusError(b.status, k, N, S);
    }
    return { response: b, options: o, controller: v };
  }
  requestAPIList(n, i) {
    const o = this.makeRequest(i, null);
    return new d9(this, o, n);
  }
  buildURL(n, i) {
    const o = S9(n) ? new URL(n) : new URL(this.baseURL + (this.baseURL.endsWith("/") && n.startsWith("/") ? n.slice(1) : n)), u = this.defaultQuery();
    return zA(u) || (i = { ...u, ...i }), typeof i == "object" && i && !Array.isArray(i) && (o.search = this.stringifyQuery(i)), o.toString();
  }
  stringifyQuery(n) {
    return Object.entries(n).filter(([i, o]) => typeof o < "u").map(([i, o]) => {
      if (typeof o == "string" || typeof o == "number" || typeof o == "boolean")
        return `${encodeURIComponent(i)}=${encodeURIComponent(o)}`;
      if (o === null)
        return `${encodeURIComponent(i)}=`;
      throw new pn(`Cannot stringify type ${typeof o}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(n, i, o, u) {
    const { signal: f, ...p } = i || {};
    f && f.addEventListener("abort", () => u.abort());
    const v = setTimeout(() => u.abort(), o);
    return this.getRequestClient().fetch.call(void 0, n, { signal: u.signal, ...p }).finally(() => {
      clearTimeout(v);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(n) {
    const i = n.headers.get("x-should-retry");
    return i === "true" ? !0 : i === "false" ? !1 : n.status === 408 || n.status === 409 || n.status === 429 || n.status >= 500;
  }
  async retryRequest(n, i, o) {
    let u;
    const f = o == null ? void 0 : o["retry-after-ms"];
    if (f) {
      const v = parseFloat(f);
      Number.isNaN(v) || (u = v);
    }
    const p = o == null ? void 0 : o["retry-after"];
    if (p && !u) {
      const v = parseFloat(p);
      Number.isNaN(v) ? u = Date.parse(p) - Date.now() : u = v * 1e3;
    }
    if (!(u && 0 <= u && u < 60 * 1e3)) {
      const v = n.maxRetries ?? this.maxRetries;
      u = this.calculateDefaultRetryTimeoutMillis(i, v);
    }
    return await PA(u), this.makeRequest(n, i - 1);
  }
  calculateDefaultRetryTimeoutMillis(n, i) {
    const f = i - n, p = Math.min(0.5 * Math.pow(2, f), 8), v = 1 - Math.random() * 0.25;
    return p * v * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Vp}`;
  }
}
class LA {
  constructor(n, i, o, u) {
    fb.set(this, void 0), u9(this, fb, n, "f"), this.options = u, this.response = i, this.body = o;
  }
  hasNextPage() {
    return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
  }
  async getNextPage() {
    const n = this.nextPageInfo();
    if (!n)
      throw new pn("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    const i = { ...this.options };
    if ("params" in n && typeof i.query == "object")
      i.query = { ...i.query, ...n.params };
    else if ("url" in n) {
      const o = [...Object.entries(i.query || {}), ...n.url.searchParams.entries()];
      for (const [u, f] of o)
        n.url.searchParams.set(u, f);
      i.query = void 0, i.path = n.url.toString();
    }
    return await c9(this, fb, "f").requestAPIList(this.constructor, i);
  }
  async *iterPages() {
    let n = this;
    for (yield n; n.hasNextPage(); )
      n = await n.getNextPage(), yield n;
  }
  async *[(fb = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const n of this.iterPages())
      for (const i of n.getPaginatedItems())
        yield i;
  }
}
class d9 extends $S {
  constructor(n, i, o) {
    super(i, async (u) => new o(n, u.response, await NA(u), u.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const n = await this;
    for await (const i of n)
      yield i;
  }
}
const p9 = (t) => new Proxy(Object.fromEntries(
  // @ts-ignore
  t.entries()
), {
  get(n, i) {
    const o = i.toString();
    return n[o.toLowerCase()] || n[o];
  }
}), h9 = {
  method: !0,
  path: !0,
  query: !0,
  body: !0,
  headers: !0,
  maxRetries: !0,
  stream: !0,
  timeout: !0,
  httpAgent: !0,
  signal: !0,
  idempotencyKey: !0,
  __binaryResponse: !0,
  __streamClass: !0
}, fs = (t) => typeof t == "object" && t !== null && !zA(t) && Object.keys(t).every((n) => $A(h9, n)), m9 = () => {
  if (typeof Deno < "u" && Deno.build != null)
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Vp,
      "X-Stainless-OS": tO(Deno.build.os),
      "X-Stainless-Arch": eO(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  if (typeof EdgeRuntime < "u")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Vp,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  if (Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]")
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Vp,
      "X-Stainless-OS": tO(process.platform),
      "X-Stainless-Arch": eO(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  const t = v9();
  return t ? {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Vp,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": `browser:${t.browser}`,
    "X-Stainless-Runtime-Version": t.version
  } : {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": Vp,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function v9() {
  if (typeof navigator > "u" || !navigator)
    return null;
  const t = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key: n, pattern: i } of t) {
    const o = i.exec(navigator.userAgent);
    if (o) {
      const u = o[1] || 0, f = o[2] || 0, p = o[3] || 0;
      return { browser: n, version: `${u}.${f}.${p}` };
    }
  }
  return null;
}
const eO = (t) => t === "x32" ? "x32" : t === "x86_64" || t === "x64" ? "x64" : t === "arm" ? "arm" : t === "aarch64" || t === "arm64" ? "arm64" : t ? `other:${t}` : "unknown", tO = (t) => (t = t.toLowerCase(), t.includes("ios") ? "iOS" : t === "android" ? "Android" : t === "darwin" ? "MacOS" : t === "win32" ? "Windows" : t === "freebsd" ? "FreeBSD" : t === "openbsd" ? "OpenBSD" : t === "linux" ? "Linux" : t ? `Other:${t}` : "Unknown");
let nO;
const y9 = () => nO ?? (nO = m9()), g9 = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return;
  }
}, b9 = new RegExp("^(?:[a-z]+:)?//", "i"), S9 = (t) => b9.test(t), PA = (t) => new Promise((n) => setTimeout(n, t)), A_ = (t, n) => {
  if (typeof n != "number" || !Number.isInteger(n))
    throw new pn(`${t} must be an integer`);
  if (n < 0)
    throw new pn(`${t} must be a positive integer`);
  return n;
}, pE = (t) => t instanceof Error ? t : new Error(t), D_ = (t) => {
  var n, i, o, u, f;
  if (typeof process < "u")
    return ((i = (n = process.env) == null ? void 0 : n[t]) == null ? void 0 : i.trim()) ?? void 0;
  if (typeof Deno < "u")
    return (f = (u = (o = Deno.env) == null ? void 0 : o.get) == null ? void 0 : u.call(o, t)) == null ? void 0 : f.trim();
};
function zA(t) {
  if (!t)
    return !0;
  for (const n in t)
    return !1;
  return !0;
}
function $A(t, n) {
  return Object.prototype.hasOwnProperty.call(t, n);
}
function rO(t, n) {
  for (const i in n) {
    if (!$A(n, i))
      continue;
    const o = i.toLowerCase();
    if (!o)
      continue;
    const u = n[i];
    u === null ? delete t[o] : u !== void 0 && (t[o] = u);
  }
}
function eh(t, ...n) {
  typeof process < "u" && process.env.DEBUG === "true" && console.log(`OpenAI:DEBUG:${t}`, ...n);
}
const x9 = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t) => {
  const n = Math.random() * 16 | 0;
  return (t === "x" ? n : n & 3 | 8).toString(16);
}), w9 = () => (
  // @ts-ignore
  typeof window < "u" && // @ts-ignore
  typeof window.document < "u" && // @ts-ignore
  typeof navigator < "u"
);
function iO(t) {
  return t != null && typeof t == "object" && !Array.isArray(t);
}
class ZE extends LA {
  constructor(n, i, o, u) {
    super(n, i, o, u), this.data = o.data || [], this.object = o.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
}
class pu extends LA {
  constructor(n, i, o, u) {
    super(n, i, o, u), this.data = o.data || [];
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const n = this.nextPageInfo();
    if (!n)
      return null;
    if ("params" in n)
      return n.params;
    const i = Object.fromEntries(n.url.searchParams);
    return Object.keys(i).length ? i : null;
  }
  nextPageInfo() {
    var o;
    const n = this.getPaginatedItems();
    if (!n.length)
      return null;
    const i = (o = n[n.length - 1]) == null ? void 0 : o.id;
    return i ? { params: { after: i } } : null;
  }
}
class lr {
  constructor(n) {
    this._client = n;
  }
}
let Bb = class extends lr {
  create(n, i) {
    return this._client.post("/chat/completions", { body: n, ...i, stream: n.stream ?? !1 });
  }
};
Bb || (Bb = {});
let Hb = class extends lr {
  constructor() {
    super(...arguments), this.completions = new Bb(this._client);
  }
};
(function(t) {
  t.Completions = Bb;
})(Hb || (Hb = {}));
class Vb extends lr {
  /**
   * Generates audio from the input text.
   */
  create(n, i) {
    return this._client.post("/audio/speech", { body: n, ...i, __binaryResponse: !0 });
  }
}
Vb || (Vb = {});
class Wb extends lr {
  /**
   * Transcribes audio into the input language.
   */
  create(n, i) {
    return this._client.post("/audio/transcriptions", Kv({ body: n, ...i }));
  }
}
Wb || (Wb = {});
class Yb extends lr {
  /**
   * Translates audio into English.
   */
  create(n, i) {
    return this._client.post("/audio/translations", Kv({ body: n, ...i }));
  }
}
Yb || (Yb = {});
class Zb extends lr {
  constructor() {
    super(...arguments), this.transcriptions = new Wb(this._client), this.translations = new Yb(this._client), this.speech = new Vb(this._client);
  }
}
(function(t) {
  t.Transcriptions = Wb, t.Translations = Yb, t.Speech = Vb;
})(Zb || (Zb = {}));
let qb = class extends lr {
  /**
   * Create an assistant file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to an
   * [assistant](https://platform.openai.com/docs/api-reference/assistants).
   */
  create(n, i, o) {
    return this._client.post(`/assistants/${n}/files`, {
      body: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Retrieves an AssistantFile.
   */
  retrieve(n, i, o) {
    return this._client.get(`/assistants/${n}/files/${i}`, {
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  list(n, i = {}, o) {
    return fs(i) ? this.list(n, {}, i) : this._client.getAPIList(`/assistants/${n}/files`, qE, {
      query: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Delete an assistant file.
   */
  del(n, i, o) {
    return this._client.delete(`/assistants/${n}/files/${i}`, {
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
};
class qE extends pu {
}
(function(t) {
  t.AssistantFilesPage = qE;
})(qb || (qb = {}));
class Gb extends lr {
  constructor() {
    super(...arguments), this.files = new qb(this._client);
  }
  /**
   * Create an assistant with a model and instructions.
   */
  create(n, i) {
    return this._client.post("/assistants", {
      body: n,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(n, i) {
    return this._client.get(`/assistants/${n}`, {
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(n, i, o) {
    return this._client.post(`/assistants/${n}`, {
      body: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  list(n = {}, i) {
    return fs(n) ? this.list({}, n) : this._client.getAPIList("/assistants", GE, {
      query: n,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(n, i) {
    return this._client.delete(`/assistants/${n}`, {
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
}
class GE extends pu {
}
(function(t) {
  t.AssistantsPage = GE, t.Files = qb, t.AssistantFilesPage = qE;
})(Gb || (Gb = {}));
function aO(t) {
  return typeof t.parse == "function";
}
const th = (t) => (t == null ? void 0 : t.role) === "assistant", jA = (t) => (t == null ? void 0 : t.role) === "function", IA = (t) => (t == null ? void 0 : t.role) === "tool";
var al = function(t, n, i, o, u) {
  if (o === "m")
    throw new TypeError("Private method is not writable");
  if (o === "a" && !u)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? t !== n || !u : !n.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? u.call(t, i) : u ? u.value = i : n.set(t, i), i;
}, rn = function(t, n, i, o) {
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? t !== n || !o : !n.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return i === "m" ? o : i === "a" ? o.call(t) : o ? o.value : n.get(t);
}, Wi, wb, _b, Pv, zv, Eb, $v, lu, jv, Cb, kb, Wp, hE, Xb, mE, vE, yE, gE, FA, bE;
const oO = 10;
class UA {
  constructor() {
    Wi.add(this), this.controller = new AbortController(), wb.set(this, void 0), _b.set(this, () => {
    }), Pv.set(this, () => {
    }), zv.set(this, void 0), Eb.set(this, () => {
    }), $v.set(this, () => {
    }), lu.set(this, {}), this._chatCompletions = [], this.messages = [], jv.set(this, !1), Cb.set(this, !1), kb.set(this, !1), Wp.set(this, !1), gE.set(this, (n) => {
      if (al(this, Cb, !0, "f"), n instanceof Error && n.name === "AbortError" && (n = new ko()), n instanceof ko)
        return al(this, kb, !0, "f"), this._emit("abort", n);
      if (n instanceof pn)
        return this._emit("error", n);
      if (n instanceof Error) {
        const i = new pn(n.message);
        return i.cause = n, this._emit("error", i);
      }
      return this._emit("error", new pn(String(n)));
    }), al(this, wb, new Promise((n, i) => {
      al(this, _b, n, "f"), al(this, Pv, i, "f");
    }), "f"), al(this, zv, new Promise((n, i) => {
      al(this, Eb, n, "f"), al(this, $v, i, "f");
    }), "f"), rn(this, wb, "f").catch(() => {
    }), rn(this, zv, "f").catch(() => {
    });
  }
  _run(n) {
    setTimeout(() => {
      n().then(() => {
        this._emitFinal(), this._emit("end");
      }, rn(this, gE, "f"));
    }, 0);
  }
  _addChatCompletion(n) {
    var o;
    this._chatCompletions.push(n), this._emit("chatCompletion", n);
    const i = (o = n.choices[0]) == null ? void 0 : o.message;
    return i && this._addMessage(i), n;
  }
  _addMessage(n, i = !0) {
    if ("content" in n || (n.content = null), this.messages.push(n), i) {
      if (this._emit("message", n), (jA(n) || IA(n)) && n.content)
        this._emit("functionCallResult", n.content);
      else if (th(n) && n.function_call)
        this._emit("functionCall", n.function_call);
      else if (th(n) && n.tool_calls)
        for (const o of n.tool_calls)
          o.type === "function" && this._emit("functionCall", o.function);
    }
  }
  _connected() {
    this.ended || (rn(this, _b, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return rn(this, jv, "f");
  }
  get errored() {
    return rn(this, Cb, "f");
  }
  get aborted() {
    return rn(this, kb, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(n, i) {
    return (rn(this, lu, "f")[n] || (rn(this, lu, "f")[n] = [])).push({ listener: i }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(n, i) {
    const o = rn(this, lu, "f")[n];
    if (!o)
      return this;
    const u = o.findIndex((f) => f.listener === i);
    return u >= 0 && o.splice(u, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(n, i) {
    return (rn(this, lu, "f")[n] || (rn(this, lu, "f")[n] = [])).push({ listener: i, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(n) {
    return new Promise((i, o) => {
      al(this, Wp, !0, "f"), n !== "error" && this.once("error", o), this.once(n, i);
    });
  }
  async done() {
    al(this, Wp, !0, "f"), await rn(this, zv, "f");
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const n = this._chatCompletions[this._chatCompletions.length - 1];
    if (!n)
      throw new pn("stream ended without producing a ChatCompletion");
    return n;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    return await this.done(), rn(this, Wi, "m", hE).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    return await this.done(), rn(this, Wi, "m", Xb).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    return await this.done(), rn(this, Wi, "m", mE).call(this);
  }
  async finalFunctionCallResult() {
    return await this.done(), rn(this, Wi, "m", vE).call(this);
  }
  async totalUsage() {
    return await this.done(), rn(this, Wi, "m", yE).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(n, ...i) {
    if (rn(this, jv, "f"))
      return;
    n === "end" && (al(this, jv, !0, "f"), rn(this, Eb, "f").call(this));
    const o = rn(this, lu, "f")[n];
    if (o && (rn(this, lu, "f")[n] = o.filter((u) => !u.once), o.forEach(({ listener: u }) => u(...i))), n === "abort") {
      const u = i[0];
      !rn(this, Wp, "f") && !(o != null && o.length) && Promise.reject(u), rn(this, Pv, "f").call(this, u), rn(this, $v, "f").call(this, u), this._emit("end");
      return;
    }
    if (n === "error") {
      const u = i[0];
      !rn(this, Wp, "f") && !(o != null && o.length) && Promise.reject(u), rn(this, Pv, "f").call(this, u), rn(this, $v, "f").call(this, u), this._emit("end");
    }
  }
  _emitFinal() {
    const n = this._chatCompletions[this._chatCompletions.length - 1];
    n && this._emit("finalChatCompletion", n);
    const i = rn(this, Wi, "m", Xb).call(this);
    i && this._emit("finalMessage", i);
    const o = rn(this, Wi, "m", hE).call(this);
    o && this._emit("finalContent", o);
    const u = rn(this, Wi, "m", mE).call(this);
    u && this._emit("finalFunctionCall", u);
    const f = rn(this, Wi, "m", vE).call(this);
    f != null && this._emit("finalFunctionCallResult", f), this._chatCompletions.some((p) => p.usage) && this._emit("totalUsage", rn(this, Wi, "m", yE).call(this));
  }
  async _createChatCompletion(n, i, o) {
    const u = o == null ? void 0 : o.signal;
    u && (u.aborted && this.controller.abort(), u.addEventListener("abort", () => this.controller.abort())), rn(this, Wi, "m", FA).call(this, i);
    const f = await n.create({ ...i, stream: !1 }, { ...o, signal: this.controller.signal });
    return this._connected(), this._addChatCompletion(f);
  }
  async _runChatCompletion(n, i, o) {
    for (const u of i.messages)
      this._addMessage(u, !1);
    return await this._createChatCompletion(n, i, o);
  }
  async _runFunctions(n, i, o) {
    var R;
    const u = "function", { function_call: f = "auto", stream: p, ...v } = i, b = typeof f != "string" && (f == null ? void 0 : f.name), { maxChatCompletions: S = oO } = o || {}, E = {};
    for (const k of i.functions)
      E[k.name || k.function.name] = k;
    const w = i.functions.map((k) => ({
      name: k.name || k.function.name,
      parameters: k.parameters,
      description: k.description
    }));
    for (const k of i.messages)
      this._addMessage(k, !1);
    for (let k = 0; k < S; ++k) {
      const z = (R = (await this._createChatCompletion(n, {
        ...v,
        function_call: f,
        functions: w,
        messages: [...this.messages]
      }, o)).choices[0]) == null ? void 0 : R.message;
      if (!z)
        throw new pn("missing message in ChatCompletion response");
      if (!z.function_call)
        return;
      const { name: I, arguments: H } = z.function_call, q = E[I];
      if (q) {
        if (b && b !== I) {
          const V = `Invalid function_call: ${JSON.stringify(I)}. ${JSON.stringify(b)} requested. Please try again`;
          this._addMessage({ role: u, name: I, content: V });
          continue;
        }
      } else {
        const V = `Invalid function_call: ${JSON.stringify(I)}. Available options are: ${w.map((ue) => JSON.stringify(ue.name)).join(", ")}. Please try again`;
        this._addMessage({ role: u, name: I, content: V });
        continue;
      }
      let G;
      try {
        G = aO(q) ? await q.parse(H) : H;
      } catch (V) {
        this._addMessage({
          role: u,
          name: I,
          content: V instanceof Error ? V.message : String(V)
        });
        continue;
      }
      const te = await q.function(G, this), ee = rn(this, Wi, "m", bE).call(this, te);
      if (this._addMessage({ role: u, name: I, content: ee }), b)
        return;
    }
  }
  async _runTools(n, i, o) {
    var R, k;
    const u = "tool", { tool_choice: f = "auto", stream: p, ...v } = i, b = typeof f != "string" && ((R = f == null ? void 0 : f.function) == null ? void 0 : R.name), { maxChatCompletions: S = oO } = o || {}, E = {};
    for (const N of i.tools)
      N.type === "function" && (E[N.function.name || N.function.function.name] = N.function);
    const w = "tools" in i ? i.tools.map((N) => N.type === "function" ? {
      type: "function",
      function: {
        name: N.function.name || N.function.function.name,
        parameters: N.function.parameters,
        description: N.function.description
      }
    } : N) : void 0;
    for (const N of i.messages)
      this._addMessage(N, !1);
    for (let N = 0; N < S; ++N) {
      const I = (k = (await this._createChatCompletion(n, {
        ...v,
        tool_choice: f,
        tools: w,
        messages: [...this.messages]
      }, o)).choices[0]) == null ? void 0 : k.message;
      if (!I)
        throw new pn("missing message in ChatCompletion response");
      if (!I.tool_calls)
        return;
      for (const H of I.tool_calls) {
        if (H.type !== "function")
          continue;
        const q = H.id, { name: G, arguments: te } = H.function, ee = E[G];
        if (ee) {
          if (b && b !== G) {
            const me = `Invalid tool_call: ${JSON.stringify(G)}. ${JSON.stringify(b)} requested. Please try again`;
            this._addMessage({ role: u, tool_call_id: q, content: me });
            continue;
          }
        } else {
          const me = `Invalid tool_call: ${JSON.stringify(G)}. Available options are: ${w.map((Le) => JSON.stringify(Le.function.name)).join(", ")}. Please try again`;
          this._addMessage({ role: u, tool_call_id: q, content: me });
          continue;
        }
        let V;
        try {
          V = aO(ee) ? await ee.parse(te) : te;
        } catch (me) {
          const Le = me instanceof Error ? me.message : String(me);
          this._addMessage({ role: u, tool_call_id: q, content: Le });
          continue;
        }
        const ue = await ee.function(V, this), we = rn(this, Wi, "m", bE).call(this, ue);
        if (this._addMessage({ role: u, tool_call_id: q, content: we }), b)
          return;
      }
    }
  }
}
wb = /* @__PURE__ */ new WeakMap(), _b = /* @__PURE__ */ new WeakMap(), Pv = /* @__PURE__ */ new WeakMap(), zv = /* @__PURE__ */ new WeakMap(), Eb = /* @__PURE__ */ new WeakMap(), $v = /* @__PURE__ */ new WeakMap(), lu = /* @__PURE__ */ new WeakMap(), jv = /* @__PURE__ */ new WeakMap(), Cb = /* @__PURE__ */ new WeakMap(), kb = /* @__PURE__ */ new WeakMap(), Wp = /* @__PURE__ */ new WeakMap(), gE = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakSet(), hE = function() {
  return rn(this, Wi, "m", Xb).call(this).content ?? null;
}, Xb = function() {
  let n = this.messages.length;
  for (; n-- > 0; ) {
    const i = this.messages[n];
    if (th(i))
      return { ...i, content: i.content ?? null };
  }
  throw new pn("stream ended without producing a ChatCompletionMessage with role=assistant");
}, mE = function() {
  var n, i;
  for (let o = this.messages.length - 1; o >= 0; o--) {
    const u = this.messages[o];
    if (th(u) && (u != null && u.function_call))
      return u.function_call;
    if (th(u) && ((n = u == null ? void 0 : u.tool_calls) != null && n.length))
      return (i = u.tool_calls.at(-1)) == null ? void 0 : i.function;
  }
}, vE = function() {
  for (let n = this.messages.length - 1; n >= 0; n--) {
    const i = this.messages[n];
    if (jA(i) && i.content != null || IA(i) && i.content != null && this.messages.some((o) => {
      var u;
      return o.role === "assistant" && ((u = o.tool_calls) == null ? void 0 : u.some((f) => f.type === "function" && f.id === i.tool_call_id));
    }))
      return i.content;
  }
}, yE = function() {
  const n = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage: i } of this._chatCompletions)
    i && (n.completion_tokens += i.completion_tokens, n.prompt_tokens += i.prompt_tokens, n.total_tokens += i.total_tokens);
  return n;
}, FA = function(n) {
  if (n.n != null && n.n > 1)
    throw new pn("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
}, bE = function(n) {
  return typeof n == "string" ? n : n === void 0 ? "undefined" : JSON.stringify(n);
};
class Jv extends UA {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(n, i, o) {
    const u = new Jv(), f = {
      ...o,
      headers: { ...o == null ? void 0 : o.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return u._run(() => u._runFunctions(n, i, f)), u;
  }
  static runTools(n, i, o) {
    const u = new Jv(), f = {
      ...o,
      headers: { ...o == null ? void 0 : o.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return u._run(() => u._runTools(n, i, f)), u;
  }
  _addMessage(n) {
    super._addMessage(n), th(n) && n.content && this._emit("content", n.content);
  }
}
var ol = function(t, n, i, o) {
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? t !== n || !o : !n.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return i === "m" ? o : i === "a" ? o.call(t) : o ? o.value : n.get(t);
}, M_ = function(t, n, i, o, u) {
  if (o === "m")
    throw new TypeError("Private method is not writable");
  if (o === "a" && !u)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? t !== n || !u : !n.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? u.call(t, i) : u ? u.value = i : n.set(t, i), i;
}, is, Ec, N_, L_, db, lO;
class ey extends UA {
  constructor() {
    super(...arguments), is.add(this), Ec.set(this, void 0);
  }
  get currentChatCompletionSnapshot() {
    return ol(this, Ec, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(n) {
    const i = new ey();
    return i._run(() => i._fromReadableStream(n)), i;
  }
  static createChatCompletion(n, i, o) {
    const u = new ey();
    return u._run(() => u._runChatCompletion(n, { ...i, stream: !0 }, { ...o, headers: { ...o == null ? void 0 : o.headers, "X-Stainless-Helper-Method": "stream" } })), u;
  }
  async _createChatCompletion(n, i, o) {
    var p;
    const u = o == null ? void 0 : o.signal;
    u && (u.aborted && this.controller.abort(), u.addEventListener("abort", () => this.controller.abort())), ol(this, is, "m", N_).call(this);
    const f = await n.create({ ...i, stream: !0 }, { ...o, signal: this.controller.signal });
    this._connected();
    for await (const v of f)
      ol(this, is, "m", L_).call(this, v);
    if ((p = f.controller.signal) != null && p.aborted)
      throw new ko();
    return this._addChatCompletion(ol(this, is, "m", db).call(this));
  }
  async _fromReadableStream(n, i) {
    var p;
    const o = i == null ? void 0 : i.signal;
    o && (o.aborted && this.controller.abort(), o.addEventListener("abort", () => this.controller.abort())), ol(this, is, "m", N_).call(this), this._connected();
    const u = uu.fromReadableStream(n, this.controller);
    let f;
    for await (const v of u)
      f && f !== v.id && this._addChatCompletion(ol(this, is, "m", db).call(this)), ol(this, is, "m", L_).call(this, v), f = v.id;
    if ((p = u.controller.signal) != null && p.aborted)
      throw new ko();
    return this._addChatCompletion(ol(this, is, "m", db).call(this));
  }
  [(Ec = /* @__PURE__ */ new WeakMap(), is = /* @__PURE__ */ new WeakSet(), N_ = function() {
    this.ended || M_(this, Ec, void 0, "f");
  }, L_ = function(i) {
    var p, v, b;
    if (this.ended)
      return;
    const o = ol(this, is, "m", lO).call(this, i);
    this._emit("chunk", i, o);
    const u = (v = (p = i.choices[0]) == null ? void 0 : p.delta) == null ? void 0 : v.content, f = (b = o.choices[0]) == null ? void 0 : b.message;
    u != null && (f == null ? void 0 : f.role) === "assistant" && (f != null && f.content) && this._emit("content", u, f.content);
  }, db = function() {
    if (this.ended)
      throw new pn("stream has ended, this shouldn't happen");
    const i = ol(this, Ec, "f");
    if (!i)
      throw new pn("request ended without sending any chunks");
    return M_(this, Ec, void 0, "f"), _9(i);
  }, lO = function(i) {
    var o, u, f;
    let p = ol(this, Ec, "f");
    const { choices: v, ...b } = i;
    p ? Object.assign(p, b) : p = M_(this, Ec, {
      ...b,
      choices: []
    }, "f");
    for (const { delta: S, finish_reason: E, index: w, logprobs: R = null, ...k } of i.choices) {
      let N = p.choices[w];
      if (N || (N = p.choices[w] = { finish_reason: E, index: w, message: {}, logprobs: R, ...k }), R)
        if (!N.logprobs)
          N.logprobs = Object.assign({}, R);
        else {
          const { content: te, ...ee } = R;
          Object.assign(N.logprobs, ee), te && ((o = N.logprobs).content ?? (o.content = []), N.logprobs.content.push(...te));
        }
      if (E && (N.finish_reason = E), Object.assign(N, k), !S)
        continue;
      const { content: z, function_call: I, role: H, tool_calls: q, ...G } = S;
      if (Object.assign(N.message, G), z && (N.message.content = (N.message.content || "") + z), H && (N.message.role = H), I && (N.message.function_call ? (I.name && (N.message.function_call.name = I.name), I.arguments && ((u = N.message.function_call).arguments ?? (u.arguments = ""), N.message.function_call.arguments += I.arguments)) : N.message.function_call = I), q) {
        N.message.tool_calls || (N.message.tool_calls = []);
        for (const { index: te, id: ee, type: V, function: ue, ...we } of q) {
          const me = (f = N.message.tool_calls)[te] ?? (f[te] = {});
          Object.assign(me, we), ee && (me.id = ee), V && (me.type = V), ue && (me.function ?? (me.function = { arguments: "" })), ue != null && ue.name && (me.function.name = ue.name), ue != null && ue.arguments && (me.function.arguments += ue.arguments);
        }
      }
    }
    return p;
  }, Symbol.asyncIterator)]() {
    const n = [], i = [];
    let o = !1;
    return this.on("chunk", (u) => {
      const f = i.shift();
      f ? f.resolve(u) : n.push(u);
    }), this.on("end", () => {
      o = !0;
      for (const u of i)
        u.resolve(void 0);
      i.length = 0;
    }), this.on("abort", (u) => {
      o = !0;
      for (const f of i)
        f.reject(u);
      i.length = 0;
    }), this.on("error", (u) => {
      o = !0;
      for (const f of i)
        f.reject(u);
      i.length = 0;
    }), {
      next: async () => n.length ? { value: n.shift(), done: !1 } : o ? { value: void 0, done: !0 } : new Promise((f, p) => i.push({ resolve: f, reject: p })).then((f) => f ? { value: f, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new uu(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
}
function _9(t) {
  const { id: n, choices: i, created: o, model: u, system_fingerprint: f, ...p } = t;
  return {
    ...p,
    id: n,
    choices: i.map(({ message: v, finish_reason: b, index: S, logprobs: E, ...w }) => {
      if (!b)
        throw new pn(`missing finish_reason for choice ${S}`);
      const { content: R = null, function_call: k, tool_calls: N, ...z } = v, I = v.role;
      if (!I)
        throw new pn(`missing role for choice ${S}`);
      if (k) {
        const { arguments: H, name: q } = k;
        if (H == null)
          throw new pn(`missing function_call.arguments for choice ${S}`);
        if (!q)
          throw new pn(`missing function_call.name for choice ${S}`);
        return {
          ...w,
          message: { content: R, function_call: { arguments: H, name: q }, role: I },
          finish_reason: b,
          index: S,
          logprobs: E
        };
      }
      return N ? {
        ...w,
        index: S,
        finish_reason: b,
        logprobs: E,
        message: {
          ...z,
          role: I,
          content: R,
          tool_calls: N.map((H, q) => {
            const { function: G, type: te, id: ee, ...V } = H, { arguments: ue, name: we, ...me } = G || {};
            if (ee == null)
              throw new pn(`missing choices[${S}].tool_calls[${q}].id
${pb(t)}`);
            if (te == null)
              throw new pn(`missing choices[${S}].tool_calls[${q}].type
${pb(t)}`);
            if (we == null)
              throw new pn(`missing choices[${S}].tool_calls[${q}].function.name
${pb(t)}`);
            if (ue == null)
              throw new pn(`missing choices[${S}].tool_calls[${q}].function.arguments
${pb(t)}`);
            return { ...V, id: ee, type: te, function: { ...me, name: we, arguments: ue } };
          })
        }
      } : {
        ...w,
        message: { ...z, content: R, role: I },
        finish_reason: b,
        index: S,
        logprobs: E
      };
    }),
    created: o,
    model: u,
    object: "chat.completion",
    ...f ? { system_fingerprint: f } : {}
  };
}
function pb(t) {
  return JSON.stringify(t);
}
class nh extends ey {
  static fromReadableStream(n) {
    const i = new nh();
    return i._run(() => i._fromReadableStream(n)), i;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(n, i, o) {
    const u = new nh(), f = {
      ...o,
      headers: { ...o == null ? void 0 : o.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    return u._run(() => u._runFunctions(n, i, f)), u;
  }
  static runTools(n, i, o) {
    const u = new nh(), f = {
      ...o,
      headers: { ...o == null ? void 0 : o.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    return u._run(() => u._runTools(n, i, f)), u;
  }
}
let BA = class extends lr {
  runFunctions(n, i) {
    return n.stream ? nh.runFunctions(this._client.chat.completions, n, i) : Jv.runFunctions(this._client.chat.completions, n, i);
  }
  runTools(n, i) {
    return n.stream ? nh.runTools(this._client.chat.completions, n, i) : Jv.runTools(this._client.chat.completions, n, i);
  }
  /**
   * Creates a chat completion stream
   */
  stream(n, i) {
    return ey.createChatCompletion(this._client.chat.completions, n, i);
  }
};
class Qb extends lr {
  constructor() {
    super(...arguments), this.completions = new BA(this._client);
  }
}
(function(t) {
  t.Completions = BA;
})(Qb || (Qb = {}));
var ll = function(t, n, i, o, u) {
  if (o === "m")
    throw new TypeError("Private method is not writable");
  if (o === "a" && !u)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? t !== n || !u : !n.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? u.call(t, i) : u ? u.value = i : n.set(t, i), i;
}, dr = function(t, n, i, o) {
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? t !== n || !o : !n.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return i === "m" ? o : i === "a" ? o.call(t) : o ? o.value : n.get(t);
}, Tb, Rb, Iv, Fv, Ob, Uv, su, Bv, Ab, Db, Yp, SE;
class E9 {
  constructor() {
    this.controller = new AbortController(), Tb.set(this, void 0), Rb.set(this, () => {
    }), Iv.set(this, () => {
    }), Fv.set(this, void 0), Ob.set(this, () => {
    }), Uv.set(this, () => {
    }), su.set(this, {}), Bv.set(this, !1), Ab.set(this, !1), Db.set(this, !1), Yp.set(this, !1), SE.set(this, (n) => {
      if (ll(this, Ab, !0, "f"), n instanceof Error && n.name === "AbortError" && (n = new ko()), n instanceof ko)
        return ll(this, Db, !0, "f"), this._emit("abort", n);
      if (n instanceof pn)
        return this._emit("error", n);
      if (n instanceof Error) {
        const i = new pn(n.message);
        return i.cause = n, this._emit("error", i);
      }
      return this._emit("error", new pn(String(n)));
    }), ll(this, Tb, new Promise((n, i) => {
      ll(this, Rb, n, "f"), ll(this, Iv, i, "f");
    }), "f"), ll(this, Fv, new Promise((n, i) => {
      ll(this, Ob, n, "f"), ll(this, Uv, i, "f");
    }), "f"), dr(this, Tb, "f").catch(() => {
    }), dr(this, Fv, "f").catch(() => {
    });
  }
  _run(n) {
    setTimeout(() => {
      n().then(() => {
        this._emit("end");
      }, dr(this, SE, "f"));
    }, 0);
  }
  _addRun(n) {
    return n;
  }
  _connected() {
    this.ended || (dr(this, Rb, "f").call(this), this._emit("connect"));
  }
  get ended() {
    return dr(this, Bv, "f");
  }
  get errored() {
    return dr(this, Ab, "f");
  }
  get aborted() {
    return dr(this, Db, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(n, i) {
    return (dr(this, su, "f")[n] || (dr(this, su, "f")[n] = [])).push({ listener: i }), this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(n, i) {
    const o = dr(this, su, "f")[n];
    if (!o)
      return this;
    const u = o.findIndex((f) => f.listener === i);
    return u >= 0 && o.splice(u, 1), this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(n, i) {
    return (dr(this, su, "f")[n] || (dr(this, su, "f")[n] = [])).push({ listener: i, once: !0 }), this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(n) {
    return new Promise((i, o) => {
      ll(this, Yp, !0, "f"), n !== "error" && this.once("error", o), this.once(n, i);
    });
  }
  async done() {
    ll(this, Yp, !0, "f"), await dr(this, Fv, "f");
  }
  _emit(n, ...i) {
    if (dr(this, Bv, "f"))
      return;
    n === "end" && (ll(this, Bv, !0, "f"), dr(this, Ob, "f").call(this));
    const o = dr(this, su, "f")[n];
    if (o && (dr(this, su, "f")[n] = o.filter((u) => !u.once), o.forEach(({ listener: u }) => u(...i))), n === "abort") {
      const u = i[0];
      !dr(this, Yp, "f") && !(o != null && o.length) && Promise.reject(u), dr(this, Iv, "f").call(this, u), dr(this, Uv, "f").call(this, u), this._emit("end");
      return;
    }
    if (n === "error") {
      const u = i[0];
      !dr(this, Yp, "f") && !(o != null && o.length) && Promise.reject(u), dr(this, Iv, "f").call(this, u), dr(this, Uv, "f").call(this, u), this._emit("end");
    }
  }
  async _threadAssistantStream(n, i, o) {
    return await this._createThreadAssistantStream(i, n, o);
  }
  async _runAssistantStream(n, i, o, u) {
    return await this._createAssistantStream(i, n, o, u);
  }
  async _runToolAssistantStream(n, i, o, u, f) {
    return await this._createToolAssistantStream(o, n, i, u, f);
  }
  async _createThreadAssistantStream(n, i, o) {
    const u = o == null ? void 0 : o.signal;
    u && (u.aborted && this.controller.abort(), u.addEventListener("abort", () => this.controller.abort()));
    const f = await n.createAndRun({ ...i, stream: !1 }, { ...o, signal: this.controller.signal });
    return this._connected(), this._addRun(f);
  }
  async _createToolAssistantStream(n, i, o, u, f) {
    const p = f == null ? void 0 : f.signal;
    p && (p.aborted && this.controller.abort(), p.addEventListener("abort", () => this.controller.abort()));
    const v = await n.submitToolOutputs(i, o, { ...u, stream: !1 }, { ...f, signal: this.controller.signal });
    return this._connected(), this._addRun(v);
  }
  async _createAssistantStream(n, i, o, u) {
    const f = u == null ? void 0 : u.signal;
    f && (f.aborted && this.controller.abort(), f.addEventListener("abort", () => this.controller.abort()));
    const p = await n.create(i, { ...o, stream: !1 }, { ...u, signal: this.controller.signal });
    return this._connected(), this._addRun(p);
  }
}
Tb = /* @__PURE__ */ new WeakMap(), Rb = /* @__PURE__ */ new WeakMap(), Iv = /* @__PURE__ */ new WeakMap(), Fv = /* @__PURE__ */ new WeakMap(), Ob = /* @__PURE__ */ new WeakMap(), Uv = /* @__PURE__ */ new WeakMap(), su = /* @__PURE__ */ new WeakMap(), Bv = /* @__PURE__ */ new WeakMap(), Ab = /* @__PURE__ */ new WeakMap(), Db = /* @__PURE__ */ new WeakMap(), Yp = /* @__PURE__ */ new WeakMap(), SE = /* @__PURE__ */ new WeakMap();
var yt = function(t, n, i, o) {
  if (i === "a" && !o)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? t !== n || !o : !n.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return i === "m" ? o : i === "a" ? o.call(t) : o ? o.value : n.get(t);
}, Qa = function(t, n, i, o, u) {
  if (o === "m")
    throw new TypeError("Private method is not writable");
  if (o === "a" && !u)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? t !== n || !u : !n.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return o === "a" ? u.call(t, i) : u ? u.value = i : n.set(t, i), i;
}, fa, xE, os, Mb, sl, Vf, Gp, Ff, Kb, Ja, Nb, Lb, Zv, Pb, zb, sO, uO, cO, fO, dO, pO, hO;
class cu extends E9 {
  constructor() {
    super(...arguments), fa.add(this), xE.set(this, []), os.set(this, {}), Mb.set(this, {}), sl.set(this, void 0), Vf.set(this, void 0), Gp.set(this, void 0), Ff.set(this, void 0), Kb.set(this, void 0), Ja.set(this, void 0), Nb.set(this, void 0), Lb.set(this, void 0), Zv.set(this, void 0);
  }
  [(xE = /* @__PURE__ */ new WeakMap(), os = /* @__PURE__ */ new WeakMap(), Mb = /* @__PURE__ */ new WeakMap(), sl = /* @__PURE__ */ new WeakMap(), Vf = /* @__PURE__ */ new WeakMap(), Gp = /* @__PURE__ */ new WeakMap(), Ff = /* @__PURE__ */ new WeakMap(), Kb = /* @__PURE__ */ new WeakMap(), Ja = /* @__PURE__ */ new WeakMap(), Nb = /* @__PURE__ */ new WeakMap(), Lb = /* @__PURE__ */ new WeakMap(), Zv = /* @__PURE__ */ new WeakMap(), fa = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const n = [], i = [];
    let o = !1;
    return this.on("event", (u) => {
      const f = i.shift();
      f ? f.resolve(u) : n.push(u);
    }), this.on("end", () => {
      o = !0;
      for (const u of i)
        u.resolve(void 0);
      i.length = 0;
    }), this.on("abort", (u) => {
      o = !0;
      for (const f of i)
        f.reject(u);
      i.length = 0;
    }), this.on("error", (u) => {
      o = !0;
      for (const f of i)
        f.reject(u);
      i.length = 0;
    }), {
      next: async () => n.length ? { value: n.shift(), done: !1 } : o ? { value: void 0, done: !0 } : new Promise((f, p) => i.push({ resolve: f, reject: p })).then((f) => f ? { value: f, done: !1 } : { value: void 0, done: !0 }),
      return: async () => (this.abort(), { value: void 0, done: !0 })
    };
  }
  toReadableStream() {
    return new uu(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
  }
  static createToolAssistantStream(n, i, o, u, f) {
    const p = new cu();
    return p._run(() => p._runToolAssistantStream(n, i, o, u, {
      ...f,
      headers: { ...f == null ? void 0 : f.headers, "X-Stainless-Helper-Method": "stream" }
    })), p;
  }
  async _createToolAssistantStream(n, i, o, u, f) {
    var S;
    const p = f == null ? void 0 : f.signal;
    p && (p.aborted && this.controller.abort(), p.addEventListener("abort", () => this.controller.abort()));
    const v = { ...u, stream: !0 }, b = await n.submitToolOutputs(i, o, v, {
      ...f,
      signal: this.controller.signal
    });
    this._connected();
    for await (const E of b)
      yt(this, fa, "m", Pb).call(this, E);
    if ((S = b.controller.signal) != null && S.aborted)
      throw new ko();
    return this._addRun(yt(this, fa, "m", zb).call(this));
  }
  static createThreadAssistantStream(n, i, o) {
    const u = new cu();
    return u._run(() => u._threadAssistantStream(n, i, {
      ...o,
      headers: { ...o == null ? void 0 : o.headers, "X-Stainless-Helper-Method": "stream" }
    })), u;
  }
  static createAssistantStream(n, i, o, u) {
    const f = new cu();
    return f._run(() => f._runAssistantStream(n, i, o, {
      ...u,
      headers: { ...u == null ? void 0 : u.headers, "X-Stainless-Helper-Method": "stream" }
    })), f;
  }
  currentEvent() {
    return yt(this, Nb, "f");
  }
  currentRun() {
    return yt(this, Lb, "f");
  }
  currentMessageSnapshot() {
    return yt(this, sl, "f");
  }
  currentRunStepSnapshot() {
    return yt(this, Zv, "f");
  }
  async finalRunSteps() {
    return await this.done(), Object.values(yt(this, os, "f"));
  }
  async finalMessages() {
    return await this.done(), Object.values(yt(this, Mb, "f"));
  }
  async finalRun() {
    if (await this.done(), !yt(this, Vf, "f"))
      throw Error("Final run was not received.");
    return yt(this, Vf, "f");
  }
  async _createThreadAssistantStream(n, i, o) {
    var v;
    const u = o == null ? void 0 : o.signal;
    u && (u.aborted && this.controller.abort(), u.addEventListener("abort", () => this.controller.abort()));
    const f = { ...i, stream: !0 }, p = await n.createAndRun(f, { ...o, signal: this.controller.signal });
    this._connected();
    for await (const b of p)
      yt(this, fa, "m", Pb).call(this, b);
    if ((v = p.controller.signal) != null && v.aborted)
      throw new ko();
    return this._addRun(yt(this, fa, "m", zb).call(this));
  }
  async _createAssistantStream(n, i, o, u) {
    var b;
    const f = u == null ? void 0 : u.signal;
    f && (f.aborted && this.controller.abort(), f.addEventListener("abort", () => this.controller.abort()));
    const p = { ...o, stream: !0 }, v = await n.create(i, p, { ...u, signal: this.controller.signal });
    this._connected();
    for await (const S of v)
      yt(this, fa, "m", Pb).call(this, S);
    if ((b = v.controller.signal) != null && b.aborted)
      throw new ko();
    return this._addRun(yt(this, fa, "m", zb).call(this));
  }
  static accumulateDelta(n, i) {
    for (const [o, u] of Object.entries(i)) {
      if (!n.hasOwnProperty(o)) {
        n[o] = u;
        continue;
      }
      let f = n[o];
      if (f == null) {
        n[o] = u;
        continue;
      }
      if (o === "index" || o === "type") {
        n[o] = u;
        continue;
      }
      if (typeof f == "string" && typeof u == "string")
        f += u;
      else if (typeof f == "number" && typeof u == "number")
        f += u;
      else if (iO(f) && iO(u))
        f = this.accumulateDelta(f, u);
      else if (Array.isArray(f) && Array.isArray(u)) {
        if (f.every((p) => typeof p == "string" || typeof p == "number")) {
          f.push(...u);
          continue;
        }
      } else
        throw Error(`Unhandled record type: ${o}, deltaValue: ${u}, accValue: ${f}`);
      n[o] = f;
    }
    return n;
  }
}
Pb = function(n) {
  if (!this.ended)
    switch (Qa(this, Nb, n, "f"), yt(this, fa, "m", cO).call(this, n), n.event) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        yt(this, fa, "m", hO).call(this, n);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        yt(this, fa, "m", uO).call(this, n);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        yt(this, fa, "m", sO).call(this, n);
        break;
      case "error":
        throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    }
}, zb = function() {
  if (this.ended)
    throw new pn("stream has ended, this shouldn't happen");
  if (!yt(this, Vf, "f"))
    throw Error("Final run has been been received");
  return yt(this, Vf, "f");
}, sO = function(n) {
  const [i, o] = yt(this, fa, "m", dO).call(this, n, yt(this, sl, "f"));
  Qa(this, sl, i, "f"), yt(this, Mb, "f")[i.id] = i;
  for (const u of o) {
    const f = i.content[u.index];
    (f == null ? void 0 : f.type) == "text" && this._emit("textCreated", f.text);
  }
  switch (n.event) {
    case "thread.message.created":
      this._emit("messageCreated", n.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      if (this._emit("messageDelta", n.data.delta, i), n.data.delta.content)
        for (const u of n.data.delta.content) {
          if (u.type == "text" && u.text) {
            let f = u.text, p = i.content[u.index];
            if (p && p.type == "text")
              this._emit("textDelta", f, p.text);
            else
              throw Error("The snapshot associated with this text delta is not text or missing");
          }
          if (u.index != yt(this, Gp, "f")) {
            if (yt(this, Ff, "f"))
              switch (yt(this, Ff, "f").type) {
                case "text":
                  this._emit("textDone", yt(this, Ff, "f").text, yt(this, sl, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", yt(this, Ff, "f").image_file, yt(this, sl, "f"));
                  break;
              }
            Qa(this, Gp, u.index, "f");
          }
          Qa(this, Ff, i.content[u.index], "f");
        }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (yt(this, Gp, "f") !== void 0) {
        const u = n.data.content[yt(this, Gp, "f")];
        if (u)
          switch (u.type) {
            case "image_file":
              this._emit("imageFileDone", u.image_file, yt(this, sl, "f"));
              break;
            case "text":
              this._emit("textDone", u.text, yt(this, sl, "f"));
              break;
          }
      }
      yt(this, sl, "f") && this._emit("messageDone", n.data), Qa(this, sl, void 0, "f");
  }
}, uO = function(n) {
  const i = yt(this, fa, "m", fO).call(this, n);
  switch (Qa(this, Zv, i, "f"), n.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", n.data);
      break;
    case "thread.run.step.delta":
      const o = n.data.delta;
      if (o.step_details && o.step_details.type == "tool_calls" && o.step_details.tool_calls && i.step_details.type == "tool_calls")
        for (const f of o.step_details.tool_calls)
          f.index == yt(this, Kb, "f") ? this._emit("toolCallDelta", f, i.step_details.tool_calls[f.index]) : (yt(this, Ja, "f") && this._emit("toolCallDone", yt(this, Ja, "f")), Qa(this, Kb, f.index, "f"), Qa(this, Ja, i.step_details.tool_calls[f.index], "f"), yt(this, Ja, "f") && this._emit("toolCallCreated", yt(this, Ja, "f")));
      this._emit("runStepDelta", n.data.delta, i);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      Qa(this, Zv, void 0, "f"), n.data.step_details.type == "tool_calls" && yt(this, Ja, "f") && (this._emit("toolCallDone", yt(this, Ja, "f")), Qa(this, Ja, void 0, "f")), this._emit("runStepDone", n.data, i);
      break;
  }
}, cO = function(n) {
  yt(this, xE, "f").push(n), this._emit("event", n);
}, fO = function(n) {
  switch (n.event) {
    case "thread.run.step.created":
      return yt(this, os, "f")[n.data.id] = n.data, n.data;
    case "thread.run.step.delta":
      let i = yt(this, os, "f")[n.data.id];
      if (!i)
        throw Error("Received a RunStepDelta before creation of a snapshot");
      let o = n.data;
      if (o.delta) {
        const u = cu.accumulateDelta(i, o.delta);
        yt(this, os, "f")[n.data.id] = u;
      }
      return yt(this, os, "f")[n.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      yt(this, os, "f")[n.data.id] = n.data;
      break;
  }
  if (yt(this, os, "f")[n.data.id])
    return yt(this, os, "f")[n.data.id];
  throw new Error("No snapshot available");
}, dO = function(n, i) {
  let o = [];
  switch (n.event) {
    case "thread.message.created":
      return [n.data, o];
    case "thread.message.delta":
      if (!i)
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      let u = n.data;
      if (u.delta.content)
        for (const f of u.delta.content)
          if (f.index in i.content) {
            let p = i.content[f.index];
            i.content[f.index] = yt(this, fa, "m", pO).call(this, f, p);
          } else
            i.content[f.index] = f, o.push(f);
      return [i, o];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (i)
        return [i, o];
      throw Error("Received thread message event with no existing snapshot");
  }
  throw Error("Tried to accumulate a non-message event");
}, pO = function(n, i) {
  return cu.accumulateDelta(i, n);
}, hO = function(n) {
  switch (Qa(this, Lb, n.data, "f"), n.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      Qa(this, Vf, n.data, "f"), yt(this, Ja, "f") && (this._emit("toolCallDone", yt(this, Ja, "f")), Qa(this, Ja, void 0, "f"));
      break;
  }
};
let Jb = class extends lr {
  /**
   * Retrieves a message file.
   */
  retrieve(n, i, o, u) {
    return this._client.get(`/threads/${n}/messages/${i}/files/${o}`, {
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers }
    });
  }
  list(n, i, o = {}, u) {
    return fs(o) ? this.list(n, i, {}, o) : this._client.getAPIList(`/threads/${n}/messages/${i}/files`, XE, {
      query: o,
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers }
    });
  }
};
class XE extends pu {
}
(function(t) {
  t.MessageFilesPage = XE;
})(Jb || (Jb = {}));
class eS extends lr {
  constructor() {
    super(...arguments), this.files = new Jb(this._client);
  }
  /**
   * Create a message.
   */
  create(n, i, o) {
    return this._client.post(`/threads/${n}/messages`, {
      body: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(n, i, o) {
    return this._client.get(`/threads/${n}/messages/${i}`, {
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(n, i, o, u) {
    return this._client.post(`/threads/${n}/messages/${i}`, {
      body: o,
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers }
    });
  }
  list(n, i = {}, o) {
    return fs(i) ? this.list(n, {}, i) : this._client.getAPIList(`/threads/${n}/messages`, QE, {
      query: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
}
class QE extends pu {
}
(function(t) {
  t.MessagesPage = QE, t.Files = Jb, t.MessageFilesPage = XE;
})(eS || (eS = {}));
class tS extends lr {
  /**
   * Retrieves a run step.
   */
  retrieve(n, i, o, u) {
    return this._client.get(`/threads/${n}/runs/${i}/steps/${o}`, {
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers }
    });
  }
  list(n, i, o = {}, u) {
    return fs(o) ? this.list(n, i, {}, o) : this._client.getAPIList(`/threads/${n}/runs/${i}/steps`, KE, {
      query: o,
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers }
    });
  }
}
class KE extends pu {
}
(function(t) {
  t.RunStepsPage = KE;
})(tS || (tS = {}));
class nS extends lr {
  constructor() {
    super(...arguments), this.steps = new tS(this._client);
  }
  create(n, i, o) {
    return this._client.post(`/threads/${n}/runs`, {
      body: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers },
      stream: i.stream ?? !1
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(n, i, o) {
    return this._client.get(`/threads/${n}/runs/${i}`, {
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(n, i, o, u) {
    return this._client.post(`/threads/${n}/runs/${i}`, {
      body: o,
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers }
    });
  }
  list(n, i = {}, o) {
    return fs(i) ? this.list(n, {}, i) : this._client.getAPIList(`/threads/${n}/runs`, JE, {
      query: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(n, i, o) {
    return this._client.post(`/threads/${n}/runs/${i}/cancel`, {
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Create a Run stream
   */
  createAndStream(n, i, o) {
    return cu.createAssistantStream(n, this._client.beta.threads.runs, i, o);
  }
  submitToolOutputs(n, i, o, u) {
    return this._client.post(`/threads/${n}/runs/${i}/submit_tool_outputs`, {
      body: o,
      ...u,
      headers: { "OpenAI-Beta": "assistants=v1", ...u == null ? void 0 : u.headers },
      stream: o.stream ?? !1
    });
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state.
   */
  submitToolOutputsStream(n, i, o, u) {
    return cu.createToolAssistantStream(n, i, this._client.beta.threads.runs, o, u);
  }
}
class JE extends pu {
}
(function(t) {
  t.RunsPage = JE, t.Steps = tS, t.RunStepsPage = KE;
})(nS || (nS = {}));
class rS extends lr {
  constructor() {
    super(...arguments), this.runs = new nS(this._client), this.messages = new eS(this._client);
  }
  create(n = {}, i) {
    return fs(n) ? this.create({}, n) : this._client.post("/threads", {
      body: n,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(n, i) {
    return this._client.get(`/threads/${n}`, {
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(n, i, o) {
    return this._client.post(`/threads/${n}`, {
      body: i,
      ...o,
      headers: { "OpenAI-Beta": "assistants=v1", ...o == null ? void 0 : o.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(n, i) {
    return this._client.delete(`/threads/${n}`, {
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers }
    });
  }
  createAndRun(n, i) {
    return this._client.post("/threads/runs", {
      body: n,
      ...i,
      headers: { "OpenAI-Beta": "assistants=v1", ...i == null ? void 0 : i.headers },
      stream: n.stream ?? !1
    });
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(n, i) {
    return cu.createThreadAssistantStream(n, this._client.beta.threads, i);
  }
}
(function(t) {
  t.Runs = nS, t.RunsPage = JE, t.Messages = eS, t.MessagesPage = QE;
})(rS || (rS = {}));
class iS extends lr {
  constructor() {
    super(...arguments), this.chat = new Qb(this._client), this.assistants = new Gb(this._client), this.threads = new rS(this._client);
  }
}
(function(t) {
  t.Chat = Qb, t.Assistants = Gb, t.AssistantsPage = GE, t.Threads = rS;
})(iS || (iS = {}));
class aS extends lr {
  create(n, i) {
    return this._client.post("/completions", { body: n, ...i, stream: n.stream ?? !1 });
  }
}
aS || (aS = {});
class oS extends lr {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(n, i) {
    return this._client.post("/embeddings", { body: n, ...i });
  }
}
oS || (oS = {});
class lS extends lr {
  /**
   * Upload a file that can be used across various endpoints. The size of all the
   * files uploaded by one organization can be up to 100 GB.
   *
   * The size of individual files can be a maximum of 512 MB or 2 million tokens for
   * Assistants. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) to
   * learn more about the types of files supported. The Fine-tuning API only supports
   * `.jsonl` files.
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(n, i) {
    return this._client.post("/files", Kv({ body: n, ...i }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(n, i) {
    return this._client.get(`/files/${n}`, i);
  }
  list(n = {}, i) {
    return fs(n) ? this.list({}, n) : this._client.getAPIList("/files", eC, { query: n, ...i });
  }
  /**
   * Delete a file.
   */
  del(n, i) {
    return this._client.delete(`/files/${n}`, i);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(n, i) {
    return this._client.get(`/files/${n}/content`, { ...i, __binaryResponse: !0 });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(n, i) {
    return this._client.get(`/files/${n}/content`, {
      ...i,
      headers: { Accept: "application/json", ...i == null ? void 0 : i.headers }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(n, { pollInterval: i = 5e3, maxWait: o = 30 * 60 * 1e3 } = {}) {
    const u = /* @__PURE__ */ new Set(["processed", "error", "deleted"]), f = Date.now();
    let p = await this.retrieve(n);
    for (; !p.status || !u.has(p.status); )
      if (await PA(i), p = await this.retrieve(n), Date.now() - f > o)
        throw new YE({
          message: `Giving up on waiting for file ${n} to finish processing after ${o} milliseconds.`
        });
    return p;
  }
}
class eC extends ZE {
}
(function(t) {
  t.FileObjectsPage = eC;
})(lS || (lS = {}));
class sS extends lr {
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(n, i) {
    return this._client.post("/fine_tuning/jobs", { body: n, ...i });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(n, i) {
    return this._client.get(`/fine_tuning/jobs/${n}`, i);
  }
  list(n = {}, i) {
    return fs(n) ? this.list({}, n) : this._client.getAPIList("/fine_tuning/jobs", tC, { query: n, ...i });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(n, i) {
    return this._client.post(`/fine_tuning/jobs/${n}/cancel`, i);
  }
  listEvents(n, i = {}, o) {
    return fs(i) ? this.listEvents(n, {}, i) : this._client.getAPIList(`/fine_tuning/jobs/${n}/events`, nC, {
      query: i,
      ...o
    });
  }
}
class tC extends pu {
}
class nC extends pu {
}
(function(t) {
  t.FineTuningJobsPage = tC, t.FineTuningJobEventsPage = nC;
})(sS || (sS = {}));
class uS extends lr {
  constructor() {
    super(...arguments), this.jobs = new sS(this._client);
  }
}
(function(t) {
  t.Jobs = sS, t.FineTuningJobsPage = tC, t.FineTuningJobEventsPage = nC;
})(uS || (uS = {}));
class cS extends lr {
  /**
   * Creates a variation of a given image.
   */
  createVariation(n, i) {
    return this._client.post("/images/variations", Kv({ body: n, ...i }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(n, i) {
    return this._client.post("/images/edits", Kv({ body: n, ...i }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(n, i) {
    return this._client.post("/images/generations", { body: n, ...i });
  }
}
cS || (cS = {});
class fS extends lr {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(n, i) {
    return this._client.get(`/models/${n}`, i);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(n) {
    return this._client.getAPIList("/models", rC, n);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(n, i) {
    return this._client.delete(`/models/${n}`, i);
  }
}
class rC extends ZE {
}
(function(t) {
  t.ModelsPage = rC;
})(fS || (fS = {}));
class dS extends lr {
  /**
   * Classifies if text is potentially harmful.
   */
  create(n, i) {
    return this._client.post("/moderations", { body: n, ...i });
  }
}
dS || (dS = {});
var HA;
class ui extends f9 {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL: n = D_("OPENAI_BASE_URL"), apiKey: i = D_("OPENAI_API_KEY"), organization: o = D_("OPENAI_ORG_ID") ?? null, ...u } = {}) {
    if (i === void 0)
      throw new pn("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    const f = {
      apiKey: i,
      organization: o,
      ...u,
      baseURL: n || "https://api.openai.com/v1"
    };
    if (!f.dangerouslyAllowBrowser && w9())
      throw new pn(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    super({
      baseURL: f.baseURL,
      timeout: f.timeout ?? 6e5,
      httpAgent: f.httpAgent,
      maxRetries: f.maxRetries,
      fetch: f.fetch
    }), this.completions = new aS(this), this.chat = new Hb(this), this.embeddings = new oS(this), this.files = new lS(this), this.images = new cS(this), this.audio = new Zb(this), this.moderations = new dS(this), this.models = new fS(this), this.fineTuning = new uS(this), this.beta = new iS(this), this._options = f, this.apiKey = i, this.organization = o;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(n) {
    return {
      ...super.defaultHeaders(n),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(n) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
HA = ui;
ui.OpenAI = HA;
ui.OpenAIError = pn;
ui.APIError = Ti;
ui.APIConnectionError = zS;
ui.APIConnectionTimeoutError = YE;
ui.APIUserAbortError = ko;
ui.NotFoundError = CA;
ui.ConflictError = kA;
ui.RateLimitError = RA;
ui.BadRequestError = wA;
ui.AuthenticationError = _A;
ui.InternalServerError = OA;
ui.PermissionDeniedError = EA;
ui.UnprocessableEntityError = TA;
(function(t) {
  t.toFile = MA, t.fileFromPath = SA, t.Page = ZE, t.CursorPage = pu, t.Completions = aS, t.Chat = Hb, t.Embeddings = oS, t.Files = lS, t.FileObjectsPage = eC, t.Images = cS, t.Audio = Zb, t.Moderations = dS, t.Models = fS, t.ModelsPage = rC, t.FineTuning = uS, t.Beta = iS;
})(ui || (ui = {}));
const VA = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return R9;
    if (typeof t == "function")
      return jS(t);
    if (typeof t == "object")
      return Array.isArray(t) ? C9(t) : k9(t);
    if (typeof t == "string")
      return T9(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function C9(t) {
  const n = [];
  let i = -1;
  for (; ++i < t.length; )
    n[i] = VA(t[i]);
  return jS(o);
  function o(...u) {
    let f = -1;
    for (; ++f < n.length; )
      if (n[f].apply(this, u))
        return !0;
    return !1;
  }
}
function k9(t) {
  const n = (
    /** @type {Record<string, unknown>} */
    t
  );
  return jS(i);
  function i(o) {
    const u = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      o
    );
    let f;
    for (f in t)
      if (u[f] !== n[f])
        return !1;
    return !0;
  }
}
function T9(t) {
  return jS(n);
  function n(i) {
    return i && i.type === t;
  }
}
function jS(t) {
  return n;
  function n(i, o, u) {
    return !!(O9(i) && t.call(
      this,
      i,
      typeof o == "number" ? o : void 0,
      u || void 0
    ));
  }
}
function R9() {
  return !0;
}
function O9(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const WA = [], A9 = !0, mO = !1, D9 = "skip";
function YA(t, n, i, o) {
  let u;
  typeof n == "function" && typeof i != "function" ? (o = i, i = n) : u = n;
  const f = VA(u), p = o ? -1 : 1;
  v(t, void 0, [])();
  function v(b, S, E) {
    const w = (
      /** @type {Record<string, unknown>} */
      b && typeof b == "object" ? b : {}
    );
    if (typeof w.type == "string") {
      const k = (
        // `hast`
        typeof w.tagName == "string" ? w.tagName : (
          // `xast`
          typeof w.name == "string" ? w.name : void 0
        )
      );
      Object.defineProperty(R, "name", {
        value: "node (" + (b.type + (k ? "<" + k + ">" : "")) + ")"
      });
    }
    return R;
    function R() {
      let k = WA, N, z, I;
      if ((!n || f(b, S, E[E.length - 1] || void 0)) && (k = M9(i(b, E)), k[0] === mO))
        return k;
      if ("children" in b && b.children) {
        const H = (
          /** @type {UnistParent} */
          b
        );
        if (H.children && k[0] !== D9)
          for (z = (o ? H.children.length : -1) + p, I = E.concat(H); z > -1 && z < H.children.length; ) {
            const q = H.children[z];
            if (N = v(q, z, I)(), N[0] === mO)
              return N;
            z = typeof N[1] == "number" ? N[1] : z + p;
          }
      }
      return k;
    }
  }
}
function M9(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [A9, t] : t == null ? WA : [t];
}
async function ZA(t, n, i, { apiKey: o, proxy: u }) {
  return (await new ui({
    apiKey: o,
    dangerouslyAllowBrowser: !0,
    ...u ? {
      baseURL: `${u}/v1`
    } : {}
  }).chat.completions.create({
    model: i,
    messages: t,
    tools: n.length ? n : void 0,
    tool_choice: n.length ? "auto" : void 0
  })).choices;
}
function N9(t) {
  const n = [], i = pA(t[0].message.content || "");
  if (YA(i, "code", (o) => {
    n.push(o.value.trim());
  }), n.length !== 1)
    throw new Error(`invalid code blocks ${JSON.stringify(n)}`);
  return n[0].trim();
}
const L9 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20height='800px'%20width='800px'%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20viewBox='0%200%20512%20512'%20xml:space='preserve'%3e%3ccircle%20style='fill:%23273B7A;'%20cx='256'%20cy='256'%20r='256'/%3e%3cpath%20style='fill:%23121149;'%20d='M511.96,259.153L388.86,136.052l-46.216,47.495l-91.212-91.212L238.77,101l-2.827-2.827l-2.826,9.781%20l92.917,92.665l-39.922,41.027l-88.936-89.598l-18.804,14.931l91.429,91.429l-1.414,1.452l-138.33-138.331l-4.622,6.966%20l-4.515,0.829l139.119,139.119l-39.214,40.301L112.204,201.09l-9.282,7.67l109.066,109.066l-46.183,47.461l-34.833,25.01%20l121.659,121.659c1.122,0.014,2.243,0.043,3.368,0.043C396.331,512,510.267,399.082,511.96,259.153z'/%3e%3cpath%20style='fill:%23FFEDB5;'%20d='M137.675,393.076c-2.426,0-4.853-0.926-6.704-2.777c-3.703-3.701-3.703-9.706,0-13.407%20l160.908-160.908c3.699-3.703,9.707-3.703,13.407,0c3.703,3.701,3.703,9.706,0,13.407L144.377,390.299%20C142.529,392.151,140.1,393.076,137.675,393.076z'/%3e%3cpath%20style='fill:%23FEE187;'%20d='M131.246,390.523c1.814,1.684,4.115,2.553,6.428,2.553c2.426,0,4.853-0.926,6.704-2.777%20l160.908-160.908c3.618-3.617,3.675-9.414,0.224-13.133L131.246,390.523z'/%3e%3cpath%20style='fill:%23FFC61B;'%20d='M389.68,144.329l-12.135,35.785c-1.062,3.131-0.515,6.584,1.462,9.235l22.599,30.282%20c4.98,6.673,0.147,16.16-8.18,16.053l-37.783-0.483c-3.306-0.043-6.422,1.545-8.33,4.244l-21.818,30.851%20c-4.808,6.797-15.324,5.132-17.794-2.819l-11.216-36.083c-0.981-3.156-3.453-5.63-6.611-6.611l-36.083-11.216%20c-7.951-2.472-9.616-12.988-2.819-17.794l30.851-21.818c2.7-1.908,4.287-5.023,4.244-8.33l-0.483-37.783%20c-0.107-8.325,9.38-13.159,16.053-8.18l30.282,22.599c2.65,1.977,6.103,2.524,9.235,1.462l35.785-12.135%20C384.826,128.915,392.354,136.444,389.68,144.329z'/%3e%3cpath%20style='fill:%23EAA22F;'%20d='M379.008,189.347c-1.977-2.65-2.524-6.103-1.462-9.235l12.135-35.785%20c1.293-3.813,0.188-7.53-2.177-10.062l-93.272,93.272c1.014,1.088,1.8,2.395,2.255,3.856l11.216,36.083%20c2.472,7.951,12.988,9.616,17.794,2.819l21.818-30.851c1.908-2.7,5.023-4.287,8.33-4.244l37.783,0.483%20c8.325,0.107,13.159-9.38,8.18-16.053L379.008,189.347z'/%3e%3cg%3e%3ccircle%20style='fill:%23FFEDB5;'%20cx='241.778'%20cy='99.556'%20r='12.067'/%3e%3ccircle%20style='fill:%23FFEDB5;'%20cx='187.044'%20cy='158.599'%20r='12.067'/%3e%3ccircle%20style='fill:%23FFEDB5;'%20cx='125.845'%20cy='125.845'%20r='6.034'/%3e%3ccircle%20style='fill:%23FFEDB5;'%20cx='107.744'%20cy='205.145'%20r='6.034'/%3e%3c/g%3e%3c/svg%3e";
function P9({ apiConfig: t, onClose: n }) {
  const [i, o] = L.useState(null), [u, f] = L.useState(""), p = (E) => {
    var R, k;
    const w = (k = (R = E.target) == null ? void 0 : R.files) == null ? void 0 : k[0];
    if (w) {
      const N = new FileReader();
      N.onload = (z) => {
        o(z.target.result);
      }, N.readAsDataURL(w);
    }
  }, [v, b] = L.useState(!1), S = L.useCallback(() => {
    b(!0), ZA(
      [
        {
          role: "system",
          content: Zz
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: u
            },
            ...[i].filter(Boolean).map(
              (E) => ({
                type: "image_url",
                image_url: {
                  url: E
                }
              })
            )
          ]
        }
      ],
      [],
      "gpt-4-vision-preview",
      t
    ).then((E) => {
      const w = JSON.parse(N9(E));
      ss.saveSchema(w), n();
    }).finally(() => {
      b(!1);
    });
  }, [t, n, u, i]);
  return /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
    /* @__PURE__ */ oe.jsx(Qv, { children: /* @__PURE__ */ oe.jsx(BE, { children: "描述 UI 需求" }) }),
    /* @__PURE__ */ oe.jsxs("div", { className: "flex flex-col gap-4 p-4", children: [
      /* @__PURE__ */ oe.jsxs("div", { className: "rounded-lg overflow-hidden p-1", children: [
        /* @__PURE__ */ oe.jsx(
          hy,
          {
            className: "w-full h-32 p-4 resize-none",
            placeholder: "描述您的代码生成需求，可包含图像或文本",
            value: u,
            onChange: (E) => f(E.currentTarget.value),
            disabled: v
          }
        ),
        /* @__PURE__ */ oe.jsxs("div", { className: "", children: [
          /* @__PURE__ */ oe.jsxs("div", { className: "flex items-center mt-1", children: [
            /* @__PURE__ */ oe.jsx(qv, { htmlFor: "picture", children: /* @__PURE__ */ oe.jsx(d8, { size: 20, className: "mr-2" }) }),
            /* @__PURE__ */ oe.jsx(
              ah,
              {
                id: "picture",
                type: "file",
                onChange: p,
                disabled: v
              }
            )
          ] }),
          i && /* @__PURE__ */ oe.jsx(
            "img",
            {
              src: i,
              alt: "Uploaded Preview",
              className: "rounded-md object-contain w-[160px] h-auto mt-1"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ oe.jsx(
        Qp,
        {
          variant: "default",
          onClick: () => S(),
          disabled: v,
          children: v ? "生成中..." : "生成"
        }
      )
    ] })
  ] });
}
const z9 = L.forwardRef((t, n) => /* @__PURE__ */ oe.jsx("img", { src: L9, ref: n, ...t, width: 24, height: 24 }));
function $9(t) {
  const [n, i] = L.useState(!1), [o, u] = L.useState(0), [f, p] = L.useState(localStorage.getItem("api-key") || ""), [v, b] = L.useState(
    localStorage.getItem("api-proxy") || ""
  );
  L.useEffect(() => {
    localStorage.setItem("api-key", f);
  }, [f]), L.useEffect(() => {
    localStorage.setItem("api-proxy", v);
  }, [v]);
  const [S, E] = L.useState(!1), w = () => E(!S), R = [
    /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
      /* @__PURE__ */ oe.jsx(Qv, { children: /* @__PURE__ */ oe.jsx(BE, { children: "填写 LLM API 信息" }) }),
      /* @__PURE__ */ oe.jsxs("div", { className: "flex flex-col gap-4 p-4", children: [
        /* @__PURE__ */ oe.jsxs("div", { children: [
          /* @__PURE__ */ oe.jsx(qv, { htmlFor: "api-key", children: "OpenAI API Key" }),
          /* @__PURE__ */ oe.jsxs("div", { className: "flex items-center gap-2 mt-2", children: [
            /* @__PURE__ */ oe.jsx(
              ah,
              {
                id: "api-key",
                type: S ? "text" : "password",
                value: f,
                onChange: (k) => p(k.currentTarget.value)
              }
            ),
            /* @__PURE__ */ oe.jsx(
              "button",
              {
                type: "button",
                onClick: w,
                className: "p-2 text-gray-500 hover:text-gray-700 focus:outline-none",
                "aria-label": S ? "Hide API Key" : "Show API Key",
                children: S ? /* @__PURE__ */ oe.jsx(c8, { size: 20 }) : /* @__PURE__ */ oe.jsx(f8, { size: 20 })
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ oe.jsxs("div", { children: [
          /* @__PURE__ */ oe.jsx(qv, { htmlFor: "proxy", children: "Proxy (Optional)" }),
          /* @__PURE__ */ oe.jsx(
            ah,
            {
              className: "mt-2",
              id: "proxy",
              type: "text",
              placeholder: "http://proxyserver:port",
              value: v,
              onChange: (k) => b(k.currentTarget.value)
            }
          )
        ] }),
        /* @__PURE__ */ oe.jsx(Qp, { variant: "default", onClick: () => u(1), children: "下一步" })
      ] })
    ] }),
    /* @__PURE__ */ oe.jsx(
      t.Component,
      {
        apiConfig: { apiKey: f, proxy: v },
        onClose: () => i(!1)
      }
    )
  ];
  return /* @__PURE__ */ oe.jsxs(Hz, { open: n, onOpenChange: i, children: [
    /* @__PURE__ */ oe.jsx(Vz, { asChild: !0, children: /* @__PURE__ */ oe.jsx(t.Trigger, {}) }),
    /* @__PURE__ */ oe.jsx(eA, { children: R[o] })
  ] });
}
var Hv = {}, Ov = DS;
if (process.env.NODE_ENV === "production")
  Hv.createRoot = Ov.createRoot, Hv.hydrateRoot = Ov.hydrateRoot;
else {
  var hb = Ov.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Hv.createRoot = function(t, n) {
    hb.usingClientEntryPoint = !0;
    try {
      return Ov.createRoot(t, n);
    } finally {
      hb.usingClientEntryPoint = !1;
    }
  }, Hv.hydrateRoot = function(t, n, i) {
    hb.usingClientEntryPoint = !0;
    try {
      return Ov.hydrateRoot(t, n, i);
    } finally {
      hb.usingClientEntryPoint = !1;
    }
  };
}
function qA(t, n) {
  class i extends HTMLElement {
    constructor() {
      super();
      cR(this, "root");
      this.root = null;
    }
    connectedCallback() {
      this.root = Hv.createRoot(this), this.root.render(
        /* @__PURE__ */ oe.jsx($9, { Component: t, Trigger: n })
      );
    }
    disconnectedCallback() {
      this.root && this.root.unmount();
    }
  }
  return i;
}
customElements.define("ai-plugin-page-creator", qA(P9, z9));
const j9 = {}, GA = (t, n) => {
  const i = t.__vccOpts || t;
  for (const [o, u] of n)
    i[o] = u;
  return i;
};
function I9(t, n, i, o, u, f) {
  const p = v4("ai-plugin-page-creator");
  return y4(), g4("div", null, [
    b4(p)
  ]);
}
const F9 = /* @__PURE__ */ GA(j9, [["render", I9]]);
var wE = { exports: {} }, P_ = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vO;
function U9() {
  if (vO)
    return P_;
  vO = 1;
  var t = L;
  function n(w, R) {
    return w === R && (w !== 0 || 1 / w === 1 / R) || w !== w && R !== R;
  }
  var i = typeof Object.is == "function" ? Object.is : n, o = t.useState, u = t.useEffect, f = t.useLayoutEffect, p = t.useDebugValue;
  function v(w, R) {
    var k = R(), N = o({ inst: { value: k, getSnapshot: R } }), z = N[0].inst, I = N[1];
    return f(function() {
      z.value = k, z.getSnapshot = R, b(z) && I({ inst: z });
    }, [w, k, R]), u(function() {
      return b(z) && I({ inst: z }), w(function() {
        b(z) && I({ inst: z });
      });
    }, [w]), p(k), k;
  }
  function b(w) {
    var R = w.getSnapshot;
    w = w.value;
    try {
      var k = R();
      return !i(w, k);
    } catch {
      return !0;
    }
  }
  function S(w, R) {
    return R();
  }
  var E = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? S : v;
  return P_.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : E, P_;
}
var z_ = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yO;
function B9() {
  return yO || (yO = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = L, n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function i(G) {
      {
        for (var te = arguments.length, ee = new Array(te > 1 ? te - 1 : 0), V = 1; V < te; V++)
          ee[V - 1] = arguments[V];
        o("error", G, ee);
      }
    }
    function o(G, te, ee) {
      {
        var V = n.ReactDebugCurrentFrame, ue = V.getStackAddendum();
        ue !== "" && (te += "%s", ee = ee.concat([ue]));
        var we = ee.map(function(me) {
          return String(me);
        });
        we.unshift("Warning: " + te), Function.prototype.apply.call(console[G], console, we);
      }
    }
    function u(G, te) {
      return G === te && (G !== 0 || 1 / G === 1 / te) || G !== G && te !== te;
    }
    var f = typeof Object.is == "function" ? Object.is : u, p = t.useState, v = t.useEffect, b = t.useLayoutEffect, S = t.useDebugValue, E = !1, w = !1;
    function R(G, te, ee) {
      E || t.startTransition !== void 0 && (E = !0, i("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var V = te();
      if (!w) {
        var ue = te();
        f(V, ue) || (i("The result of getSnapshot should be cached to avoid an infinite loop"), w = !0);
      }
      var we = p({
        inst: {
          value: V,
          getSnapshot: te
        }
      }), me = we[0].inst, Le = we[1];
      return b(function() {
        me.value = V, me.getSnapshot = te, k(me) && Le({
          inst: me
        });
      }, [G, V, te]), v(function() {
        k(me) && Le({
          inst: me
        });
        var xe = function() {
          k(me) && Le({
            inst: me
          });
        };
        return G(xe);
      }, [G]), S(V), V;
    }
    function k(G) {
      var te = G.getSnapshot, ee = G.value;
      try {
        var V = te();
        return !f(ee, V);
      } catch {
        return !0;
      }
    }
    function N(G, te, ee) {
      return te();
    }
    var z = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", I = !z, H = I ? N : R, q = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : H;
    z_.useSyncExternalStore = q, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), z_;
}
process.env.NODE_ENV === "production" ? wE.exports = U9() : wE.exports = B9();
var iC = wE.exports, H9 = L.useLayoutEffect;
function V9() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
}
function W9() {
  const t = V9();
  if (t.__xstate__)
    return t.__xstate__;
}
const Y9 = (t) => {
  if (typeof window > "u")
    return;
  const n = W9();
  n && n.register(t);
};
class gO {
  constructor(n) {
    this._process = n, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(n) {
    const i = {
      value: n,
      next: null
    };
    if (this._current) {
      this._last.next = i, this._last = i;
      return;
    }
    this._current = i, this._last = i, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const n = this._current;
      this._process(n.value), this._current = n.next;
    }
    this._last = null;
  }
}
const XA = ".", Z9 = "", QA = "", q9 = "#", G9 = "*", KA = "xstate.init", pS = "xstate.stop";
function X9(t, n) {
  return {
    type: `xstate.after.${t}.${n}`
  };
}
function _E(t, n) {
  return {
    type: `xstate.done.state.${t}`,
    output: n
  };
}
function Q9(t, n) {
  return {
    type: `xstate.done.actor.${t}`,
    output: n
  };
}
function K9(t, n) {
  return {
    type: `xstate.error.actor.${t}`,
    error: n
  };
}
function JA(t) {
  return {
    type: KA,
    input: t
  };
}
function au(t) {
  setTimeout(() => {
    throw t;
  });
}
const J9 = typeof Symbol == "function" && Symbol.observable || "@@observable";
function bO(t, n) {
  return `${t.sessionId}.${n}`;
}
let e7 = 0;
function t7(t, n) {
  const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new Set(), p = {}, v = n.clock, b = {
    schedule: (w, R, k, N, z = Math.random().toString(36).slice(2)) => {
      const I = {
        source: w,
        target: R,
        event: k,
        delay: N,
        id: z,
        startedAt: Date.now()
      }, H = bO(w, z);
      E._snapshot._scheduledEvents[H] = I;
      const q = v.setTimeout(() => {
        delete p[H], delete E._snapshot._scheduledEvents[H], E._relay(w, R, k);
      }, N);
      p[H] = q;
    },
    cancel: (w, R) => {
      const k = bO(w, R), N = p[k];
      delete p[k], delete E._snapshot._scheduledEvents[k], v.clearTimeout(N);
    },
    cancelAll: (w) => {
      for (const R in E._snapshot._scheduledEvents) {
        const k = E._snapshot._scheduledEvents[R];
        k.source === w && b.cancel(w, k.id);
      }
    }
  }, S = (w) => {
    if (!f.size)
      return;
    const R = {
      ...w,
      rootId: t.sessionId
    };
    f.forEach((k) => {
      var N;
      return (N = k.next) == null ? void 0 : N.call(k, R);
    });
  }, E = {
    _snapshot: {
      _scheduledEvents: ((n == null ? void 0 : n.snapshot) && n.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${e7++}`,
    _register: (w, R) => (i.set(w, R), w),
    _unregister: (w) => {
      i.delete(w.sessionId);
      const R = u.get(w);
      R !== void 0 && (o.delete(R), u.delete(w));
    },
    get: (w) => o.get(w),
    _set: (w, R) => {
      const k = o.get(w);
      if (k && k !== R)
        throw new Error(`Actor with system ID '${w}' already exists.`);
      o.set(w, R), u.set(R, w);
    },
    inspect: (w) => {
      f.add(w);
    },
    _sendInspectionEvent: S,
    _relay: (w, R, k) => {
      E._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: w,
        actorRef: R,
        event: k
      }), R._send(k);
    },
    scheduler: b,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...E._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const w = E._snapshot._scheduledEvents;
      E._snapshot._scheduledEvents = {};
      for (const R in w) {
        const {
          source: k,
          target: N,
          event: z,
          delay: I,
          id: H
        } = w[R];
        b.schedule(k, N, z, I, H);
      }
    }
  };
  return E;
}
function e3(t, n) {
  const i = SO(t), o = SO(n);
  return typeof o == "string" ? typeof i == "string" ? o === i : !1 : typeof i == "string" ? i in o : Object.keys(i).every((u) => u in o ? e3(i[u], o[u]) : !1);
}
function aC(t) {
  if (n3(t))
    return t;
  let n = [], i = "";
  for (let o = 0; o < t.length; o++) {
    switch (t.charCodeAt(o)) {
      case 92:
        i += t[o + 1], o++;
        continue;
      case 46:
        n.push(i), i = "";
        continue;
    }
    i += t[o];
  }
  return n.push(i), n;
}
function SO(t) {
  if (M7(t))
    return t.value;
  if (typeof t != "string")
    return t;
  const n = aC(t);
  return n7(n);
}
function n7(t) {
  if (t.length === 1)
    return t[0];
  const n = {};
  let i = n;
  for (let o = 0; o < t.length - 1; o++)
    if (o === t.length - 2)
      i[t[o]] = t[o + 1];
    else {
      const u = i;
      i = {}, u[t[o]] = i;
    }
  return n;
}
function xO(t, n) {
  const i = {}, o = Object.keys(t);
  for (let u = 0; u < o.length; u++) {
    const f = o[u];
    i[f] = n(t[f], f, t, u);
  }
  return i;
}
function t3(t) {
  return n3(t) ? t : [t];
}
function Tc(t) {
  return t === void 0 ? [] : t3(t);
}
function EE(t, n, i, o) {
  return typeof t == "function" ? t({
    context: n,
    event: i,
    self: o
  }) : t;
}
function n3(t) {
  return Array.isArray(t);
}
function r7(t) {
  return t.type.startsWith("xstate.error.actor");
}
function Zp(t) {
  return t3(t).map((n) => typeof n > "u" || typeof n == "string" ? {
    target: n
  } : n);
}
function r3(t) {
  if (!(t === void 0 || t === Z9))
    return Tc(t);
}
function wO(t, n, i) {
  var f, p, v;
  const o = typeof t == "object", u = o ? t : void 0;
  return {
    next: (f = o ? t.next : t) == null ? void 0 : f.bind(u),
    error: (p = o ? t.error : n) == null ? void 0 : p.bind(u),
    complete: (v = o ? t.complete : i) == null ? void 0 : v.bind(u)
  };
}
function _O(t, n) {
  return `${n}.${t}`;
}
function oC(t, n) {
  const i = n.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!i)
    return t.implementations.actors[n];
  const [, o, u] = i, p = t.getStateNodeById(u).config.invoke;
  return (Array.isArray(p) ? p[o] : p).src;
}
const lC = 1;
let ca = /* @__PURE__ */ function(t) {
  return t[t.NotStarted = 0] = "NotStarted", t[t.Running = 1] = "Running", t[t.Stopped = 2] = "Stopped", t;
}({});
const i7 = {
  clock: {
    setTimeout: (t, n) => setTimeout(t, n),
    clearTimeout: (t) => clearTimeout(t)
  },
  logger: console.log.bind(console),
  devTools: !1
};
class a7 {
  /**
   * Creates a new actor instance for the given logic with the provided options, if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(n, i) {
    this.logic = n, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new gO(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = ca.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const o = {
      ...i7,
      ...i
    }, {
      clock: u,
      logger: f,
      parent: p,
      syncSnapshot: v,
      id: b,
      systemId: S,
      inspect: E
    } = o;
    this.system = p ? p.system : t7(this, {
      clock: u
    }), E && !p && this.system.inspect(wO(E)), this.sessionId = this.system._bookId(), this.id = b ?? this.sessionId, this.logger = f, this.clock = u, this._parent = p, this._syncSnapshot = v, this.options = o, this.src = o.src ?? n, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (w) => {
        this._deferred.push(w);
      },
      system: this.system,
      stopChild: (w) => {
        if (w._parent !== this)
          throw new Error(`Cannot stop child actor ${w.id} of ${this.id} because it is not a child`);
        w._stop();
      },
      emit: (w) => {
        const R = this.eventListeners.get(w.type);
        if (R)
          for (const k of Array.from(R))
            k(w);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), S && (this._systemId = S, this.system._set(S, this)), this._initState((i == null ? void 0 : i.snapshot) ?? (i == null ? void 0 : i.state)), S && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(n) {
    var i;
    try {
      this._snapshot = n ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(n, this._actorScope) : n : this.logic.getInitialSnapshot(this._actorScope, (i = this.options) == null ? void 0 : i.input);
    } catch (o) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: o
      };
    }
  }
  update(n, i) {
    var u, f;
    this._snapshot = n;
    let o;
    for (; o = this._deferred.shift(); )
      try {
        o();
      } catch (p) {
        this._deferred.length = 0, this._snapshot = {
          ...n,
          status: "error",
          error: p
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const p of this.observers)
          try {
            (u = p.next) == null || u.call(p, n);
          } catch (v) {
            au(v);
          }
        break;
      case "done":
        for (const p of this.observers)
          try {
            (f = p.next) == null || f.call(p, n);
          } catch (v) {
            au(v);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = Q9(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: i,
      snapshot: n
    });
  }
  /**
   * Subscribe an observer to an actor’s snapshot values.
   *
   * @remarks
   * The observer will receive the actor’s snapshot value when it is emitted. The observer can be:
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest snapshot
   *
   * @example
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   },
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object that has an `.unsubscribe()` method. You can call `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest snapshot, or an observer object whose `.next(snapshot)` method receives the latest snapshot
   */
  subscribe(n, i, o) {
    var f;
    const u = wO(n, i, o);
    if (this._processingStatus !== ca.Stopped)
      this.observers.add(u);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            (f = u.complete) == null || f.call(u);
          } catch (p) {
            au(p);
          }
          break;
        case "error": {
          const p = this._snapshot.error;
          if (!u.error)
            au(p);
          else
            try {
              u.error(p);
            } catch (v) {
              au(v);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(u);
      }
    };
  }
  on(n, i) {
    let o = this.eventListeners.get(n);
    o || (o = /* @__PURE__ */ new Set(), this.eventListeners.set(n, o));
    const u = i.bind(void 0);
    return o.add(u), {
      unsubscribe: () => {
        o.delete(u);
      }
    };
  }
  /**
   * Starts the Actor from the initial state
   */
  start() {
    if (this._processingStatus === ca.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (o) => {
        o.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot: o
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = ca.Running;
    const n = JA(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: n
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, n), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (o) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: o
        }, this._error(o), this;
      }
    return this.update(this._snapshot, n), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(n) {
    let i, o;
    try {
      i = this.logic.transition(this._snapshot, n, this._actorScope);
    } catch (u) {
      o = {
        err: u
      };
    }
    if (o) {
      const {
        err: u
      } = o;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: u
      }, this._error(u);
      return;
    }
    this.update(i, n), n.type === pS && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === ca.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ca.NotStarted ? (this._processingStatus = ca.Stopped, this) : (this.mailbox.enqueue({
      type: pS
    }), this));
  }
  /**
   * Stops the Actor and unsubscribe all listeners.
   */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    var n;
    for (const i of this.observers)
      try {
        (n = i.complete) == null || n.call(i);
      } catch (o) {
        au(o);
      }
    this.observers.clear();
  }
  _reportError(n) {
    if (!this.observers.size) {
      this._parent || au(n);
      return;
    }
    let i = !1;
    for (const o of this.observers) {
      const u = o.error;
      i || (i = !u);
      try {
        u == null || u(n);
      } catch (f) {
        au(f);
      }
    }
    this.observers.clear(), i && au(n);
  }
  _error(n) {
    this._stopProcedure(), this._reportError(n), this._parent && this.system._relay(this, this._parent, K9(this.id, n));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== ca.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new gO(this._process.bind(this)), this._processingStatus = ca.Stopped, this.system._unregister(this), this);
  }
  /**
   * @internal
   */
  _send(n) {
    this._processingStatus !== ca.Stopped && this.mailbox.enqueue(n);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(n) {
    this.system._relay(void 0, this, n);
  }
  attachDevTools() {
    const {
      devTools: n
    } = this.options;
    n && (typeof n == "function" ? n : Y9)(this);
  }
  toJSON() {
    return {
      xstate$$type: lC,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from {@link Actor.getSnapshot}. Persisted state represents the internal state of the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   *
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(n) {
    return this.logic.getPersistedSnapshot(this._snapshot, n);
  }
  [J9]() {
    return this;
  }
  /**
   * Read an actor’s snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change.
   * An actor may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with `fromCallback`, will not emit snapshots.
   *
   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function oh(t, ...[n]) {
  return new a7(t, n);
}
function o7(t, n, i, o, {
  sendId: u
}) {
  const f = typeof u == "function" ? u(i, o) : u;
  return [n, f];
}
function l7(t, n) {
  t.defer(() => {
    t.system.scheduler.cancel(t.self, n);
  });
}
function s7(t) {
  function n(i, o) {
  }
  return n.type = "xstate.cancel", n.sendId = t, n.resolve = o7, n.execute = l7, n;
}
function u7(t, n, i, o, {
  id: u,
  systemId: f,
  src: p,
  input: v,
  syncSnapshot: b
}) {
  const S = typeof p == "string" ? oC(n.machine, p) : p, E = typeof u == "function" ? u(i) : u;
  let w;
  return S && (w = oh(S, {
    id: E,
    src: p,
    parent: t.self,
    syncSnapshot: b,
    systemId: f,
    input: typeof v == "function" ? v({
      context: n.context,
      event: i.event,
      self: t.self
    }) : v
  })), [qf(n, {
    children: {
      ...n.children,
      [E]: w
    }
  }), {
    id: u,
    actorRef: w
  }];
}
function c7(t, {
  id: n,
  actorRef: i
}) {
  i && t.defer(() => {
    i._processingStatus !== ca.Stopped && i.start();
  });
}
function f7(...[t, {
  id: n,
  systemId: i,
  input: o,
  syncSnapshot: u = !1
} = {}]) {
  function f(p, v) {
  }
  return f.type = "snapshot.spawnChild", f.id = n, f.systemId = i, f.src = t, f.input = o, f.syncSnapshot = u, f.resolve = u7, f.execute = c7, f;
}
function d7(t, n, i, o, {
  actorRef: u
}) {
  const f = typeof u == "function" ? u(i, o) : u, p = typeof f == "string" ? n.children[f] : f;
  let v = n.children;
  return p && (v = {
    ...v
  }, delete v[p.id]), [qf(n, {
    children: v
  }), p];
}
function p7(t, n) {
  if (n) {
    if (t.system._unregister(n), n._processingStatus !== ca.Running) {
      t.stopChild(n);
      return;
    }
    t.defer(() => {
      t.stopChild(n);
    });
  }
}
function i3(t) {
  function n(i, o) {
  }
  return n.type = "xstate.stopChild", n.actorRef = t, n.resolve = d7, n.execute = p7, n;
}
function sC(t, n, i, o) {
  const {
    machine: u
  } = o, f = typeof t == "function", p = f ? t : u.implementations.guards[typeof t == "string" ? t : t.type];
  if (!f && !p)
    throw new Error(`Guard '${typeof t == "string" ? t : t.type}' is not implemented.'.`);
  if (typeof p != "function")
    return sC(p, n, i, o);
  const v = {
    context: n,
    event: i
  }, b = f || typeof t == "string" ? void 0 : "params" in t ? typeof t.params == "function" ? t.params({
    context: n,
    event: i
  }) : t.params : void 0;
  return "check" in p ? p.check(
    o,
    v,
    p
    // this holds all params
  ) : p(v, b);
}
const uC = (t) => t.type === "atomic" || t.type === "final";
function lh(t) {
  return Object.values(t.states).filter((n) => n.type !== "history");
}
function my(t, n) {
  const i = [];
  if (n === t)
    return i;
  let o = t.parent;
  for (; o && o !== n; )
    i.push(o), o = o.parent;
  return i;
}
function hS(t) {
  const n = new Set(t), i = o3(n);
  for (const o of n)
    if (o.type === "compound" && (!i.get(o) || !i.get(o).length))
      EO(o).forEach((u) => n.add(u));
    else if (o.type === "parallel") {
      for (const u of lh(o))
        if (u.type !== "history" && !n.has(u)) {
          const f = EO(u);
          for (const p of f)
            n.add(p);
        }
    }
  for (const o of n) {
    let u = o.parent;
    for (; u; )
      n.add(u), u = u.parent;
  }
  return n;
}
function a3(t, n) {
  const i = n.get(t);
  if (!i)
    return {};
  if (t.type === "compound") {
    const u = i[0];
    if (u) {
      if (uC(u))
        return u.key;
    } else
      return {};
  }
  const o = {};
  for (const u of i)
    o[u.key] = a3(u, n);
  return o;
}
function o3(t) {
  const n = /* @__PURE__ */ new Map();
  for (const i of t)
    n.has(i) || n.set(i, []), i.parent && (n.has(i.parent) || n.set(i.parent, []), n.get(i.parent).push(i));
  return n;
}
function l3(t, n) {
  const i = hS(n);
  return a3(t, o3(i));
}
function cC(t, n) {
  return n.type === "compound" ? lh(n).some((i) => i.type === "final" && t.has(i)) : n.type === "parallel" ? lh(n).every((i) => cC(t, i)) : n.type === "final";
}
const IS = (t) => t[0] === q9;
function h7(t, n) {
  return t.transitions.get(n) || [...t.transitions.keys()].filter((o) => {
    if (o === G9)
      return !0;
    if (!o.endsWith(".*"))
      return !1;
    const u = o.split("."), f = n.split(".");
    for (let p = 0; p < u.length; p++) {
      const v = u[p], b = f[p];
      if (v === "*")
        return p === u.length - 1;
      if (v !== b)
        return !1;
    }
    return !0;
  }).sort((o, u) => u.length - o.length).flatMap((o) => t.transitions.get(o));
}
function m7(t) {
  const n = t.config.after;
  if (!n)
    return [];
  const i = (u, f) => {
    const p = X9(u, t.id), v = p.type;
    return t.entry.push(jb(p, {
      id: v,
      delay: u
    })), t.exit.push(s7(v)), v;
  };
  return Object.keys(n).flatMap((u, f) => {
    const p = n[u], v = typeof p == "string" ? {
      target: p
    } : p, b = Number.isNaN(+u) ? u : +u, S = i(b);
    return Tc(v).map((E) => ({
      ...E,
      event: S,
      delay: b
    }));
  }).map((u) => {
    const {
      delay: f
    } = u;
    return {
      ...Uf(t, u.event, u),
      delay: f
    };
  });
}
function Uf(t, n, i) {
  const o = r3(i.target), u = i.reenter ?? !1, f = g7(t, o), p = {
    ...i,
    actions: Tc(i.actions),
    guard: i.guard,
    target: f,
    source: t,
    reenter: u,
    eventType: n,
    toJSON: () => ({
      ...p,
      source: `#${t.id}`,
      target: f ? f.map((v) => `#${v.id}`) : void 0
    })
  };
  return p;
}
function v7(t) {
  const n = /* @__PURE__ */ new Map();
  if (t.config.on)
    for (const i of Object.keys(t.config.on)) {
      if (i === QA)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const o = t.config.on[i];
      n.set(i, Zp(o).map((u) => Uf(t, i, u)));
    }
  if (t.config.onDone) {
    const i = `xstate.done.state.${t.id}`;
    n.set(i, Zp(t.config.onDone).map((o) => Uf(t, i, o)));
  }
  for (const i of t.invoke) {
    if (i.onDone) {
      const o = `xstate.done.actor.${i.id}`;
      n.set(o, Zp(i.onDone).map((u) => Uf(t, o, u)));
    }
    if (i.onError) {
      const o = `xstate.error.actor.${i.id}`;
      n.set(o, Zp(i.onError).map((u) => Uf(t, o, u)));
    }
    if (i.onSnapshot) {
      const o = `xstate.snapshot.${i.id}`;
      n.set(o, Zp(i.onSnapshot).map((u) => Uf(t, o, u)));
    }
  }
  for (const i of t.after) {
    let o = n.get(i.eventType);
    o || (o = [], n.set(i.eventType, o)), o.push(i);
  }
  return n;
}
function y7(t, n) {
  const i = typeof n == "string" ? t.states[n] : n ? t.states[n.target] : void 0;
  if (!i && n)
    throw new Error(`Initial state node "${n}" not found on parent state node #${t.id}`);
  const o = {
    source: t,
    actions: !n || typeof n == "string" ? [] : Tc(n.actions),
    eventType: null,
    reenter: !1,
    target: i ? [i] : [],
    toJSON: () => ({
      ...o,
      source: `#${t.id}`,
      target: i ? [`#${i.id}`] : []
    })
  };
  return o;
}
function g7(t, n) {
  if (n !== void 0)
    return n.map((i) => {
      if (typeof i != "string")
        return i;
      if (IS(i))
        return t.machine.getStateNodeById(i);
      const o = i[0] === XA;
      if (o && !t.parent)
        return mS(t, i.slice(1));
      const u = o ? t.key + i : i;
      if (t.parent)
        try {
          return mS(t.parent, u);
        } catch (f) {
          throw new Error(`Invalid transition definition for state node '${t.id}':
${f.message}`);
        }
      else
        throw new Error(`Invalid target: "${i}" is not a valid target from the root node. Did you mean ".${i}"?`);
    });
}
function s3(t) {
  const n = r3(t.config.target);
  return n ? {
    target: n.map((i) => typeof i == "string" ? mS(t.parent, i) : i)
  } : t.parent.initial;
}
function Wf(t) {
  return t.type === "history";
}
function EO(t) {
  const n = u3(t);
  for (const i of n)
    for (const o of my(i, t))
      n.add(o);
  return n;
}
function u3(t) {
  const n = /* @__PURE__ */ new Set();
  function i(o) {
    if (!n.has(o)) {
      if (n.add(o), o.type === "compound")
        i(o.initial.target[0]);
      else if (o.type === "parallel")
        for (const u of lh(o))
          i(u);
    }
  }
  return i(t), n;
}
function sh(t, n) {
  if (IS(n))
    return t.machine.getStateNodeById(n);
  if (!t.states)
    throw new Error(`Unable to retrieve child state '${n}' from '${t.id}'; no child states exist.`);
  const i = t.states[n];
  if (!i)
    throw new Error(`Child state '${n}' does not exist on '${t.id}'`);
  return i;
}
function mS(t, n) {
  if (typeof n == "string" && IS(n))
    try {
      return t.machine.getStateNodeById(n);
    } catch {
    }
  const i = aC(n).slice();
  let o = t;
  for (; i.length; ) {
    const u = i.shift();
    if (!u.length)
      break;
    o = sh(o, u);
  }
  return o;
}
function vS(t, n) {
  if (typeof n == "string") {
    const u = t.states[n];
    if (!u)
      throw new Error(`State '${n}' does not exist on '${t.id}'`);
    return [t, u];
  }
  const i = Object.keys(n), o = i.map((u) => sh(t, u)).filter(Boolean);
  return [t.machine.root, t].concat(o, i.reduce((u, f) => {
    const p = sh(t, f);
    if (!p)
      return u;
    const v = vS(p, n[f]);
    return u.concat(v);
  }, []));
}
function b7(t, n, i, o) {
  const f = sh(t, n).next(i, o);
  return !f || !f.length ? t.next(i, o) : f;
}
function S7(t, n, i, o) {
  const u = Object.keys(n), f = sh(t, u[0]), p = fC(f, n[u[0]], i, o);
  return !p || !p.length ? t.next(i, o) : p;
}
function x7(t, n, i, o) {
  const u = [];
  for (const f of Object.keys(n)) {
    const p = n[f];
    if (!p)
      continue;
    const v = sh(t, f), b = fC(v, p, i, o);
    b && u.push(...b);
  }
  return u.length ? u : t.next(i, o);
}
function fC(t, n, i, o) {
  return typeof n == "string" ? b7(t, n, i, o) : Object.keys(n).length === 1 ? S7(t, n, i, o) : x7(t, n, i, o);
}
function w7(t) {
  return Object.keys(t.states).map((n) => t.states[n]).filter((n) => n.type === "history");
}
function Rc(t, n) {
  let i = t;
  for (; i.parent && i.parent !== n; )
    i = i.parent;
  return i.parent === n;
}
function _7(t, n) {
  const i = new Set(t), o = new Set(n);
  for (const u of i)
    if (o.has(u))
      return !0;
  for (const u of o)
    if (i.has(u))
      return !0;
  return !1;
}
function c3(t, n, i) {
  const o = /* @__PURE__ */ new Set();
  for (const u of t) {
    let f = !1;
    const p = /* @__PURE__ */ new Set();
    for (const v of o)
      if (_7(CE([u], n, i), CE([v], n, i)))
        if (Rc(u.source, v.source))
          p.add(v);
        else {
          f = !0;
          break;
        }
    if (!f) {
      for (const v of p)
        o.delete(v);
      o.add(u);
    }
  }
  return Array.from(o);
}
function E7(t) {
  const [n, ...i] = t;
  for (const o of my(n, void 0))
    if (i.every((u) => Rc(u, o)))
      return o;
}
function dC(t, n) {
  if (!t.target)
    return [];
  const i = /* @__PURE__ */ new Set();
  for (const o of t.target)
    if (Wf(o))
      if (n[o.id])
        for (const u of n[o.id])
          i.add(u);
      else
        for (const u of dC(s3(o), n))
          i.add(u);
    else
      i.add(o);
  return [...i];
}
function f3(t, n) {
  const i = dC(t, n);
  if (!i)
    return;
  if (!t.reenter && i.every((u) => u === t.source || Rc(u, t.source)))
    return t.source;
  const o = E7(i.concat(t.source));
  if (o)
    return o;
  if (!t.reenter)
    return t.source.machine.root;
}
function CE(t, n, i) {
  var u;
  const o = /* @__PURE__ */ new Set();
  for (const f of t)
    if ((u = f.target) != null && u.length) {
      const p = f3(f, i);
      f.reenter && f.source === p && o.add(p);
      for (const v of n)
        Rc(v, p) && o.add(v);
    }
  return [...o];
}
function C7(t, n) {
  if (t.length !== n.size)
    return !1;
  for (const i of t)
    if (!n.has(i))
      return !1;
  return !0;
}
function kE(t, n, i, o, u, f) {
  if (!t.length)
    return n;
  const p = new Set(n._nodes);
  let v = n.historyValue;
  const b = c3(t, p, v);
  let S = n;
  u || ([S, v] = O7(S, o, i, b, p, v, f)), S = uh(S, o, i, b.flatMap((w) => w.actions), f), S = T7(S, o, i, b, p, f, v, u);
  const E = [...p];
  S.status === "done" && (S = uh(S, o, i, E.sort((w, R) => R.order - w.order).flatMap((w) => w.exit), f));
  try {
    return v === n.historyValue && C7(n._nodes, p) ? S : qf(S, {
      _nodes: E,
      historyValue: v
    });
  } catch (w) {
    throw w;
  }
}
function k7(t, n, i, o, u) {
  if (o.output === void 0)
    return;
  const f = _E(u.id, u.output !== void 0 && u.parent ? EE(u.output, t.context, n, i.self) : void 0);
  return EE(o.output, t.context, f, i.self);
}
function T7(t, n, i, o, u, f, p, v) {
  let b = t;
  const S = /* @__PURE__ */ new Set(), E = /* @__PURE__ */ new Set();
  R7(o, p, E, S), v && E.add(t.machine.root);
  const w = /* @__PURE__ */ new Set();
  for (const R of [...S].sort((k, N) => k.order - N.order)) {
    u.add(R);
    const k = [];
    k.push(...R.entry);
    for (const N of R.invoke)
      k.push(f7(N.src, {
        ...N,
        syncSnapshot: !!N.onSnapshot
      }));
    if (E.has(R)) {
      const N = R.initial.actions;
      k.push(...N);
    }
    if (b = uh(b, n, i, k, f, R.invoke.map((N) => N.id)), R.type === "final") {
      const N = R.parent;
      let z = (N == null ? void 0 : N.type) === "parallel" ? N : N == null ? void 0 : N.parent, I = z || R;
      for ((N == null ? void 0 : N.type) === "compound" && f.push(_E(N.id, R.output !== void 0 ? EE(R.output, b.context, n, i.self) : void 0)); (z == null ? void 0 : z.type) === "parallel" && !w.has(z) && cC(u, z); )
        w.add(z), f.push(_E(z.id)), I = z, z = z.parent;
      if (z)
        continue;
      b = qf(b, {
        status: "done",
        output: k7(b, n, i, b.machine.root, I)
      });
    }
  }
  return b;
}
function R7(t, n, i, o) {
  for (const u of t) {
    const f = f3(u, n);
    for (const v of u.target || [])
      !Wf(v) && // if the target is different than the source then it will *definitely* be entered
      (u.source !== v || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      u.source !== f || // reentering transitions always enter the target, even if it's the source itself
      u.reenter) && (o.add(v), i.add(v)), Xp(v, n, i, o);
    const p = dC(u, n);
    for (const v of p) {
      const b = my(v, f);
      (f == null ? void 0 : f.type) === "parallel" && b.push(f), d3(o, n, i, b, !u.source.parent && u.reenter ? void 0 : f);
    }
  }
}
function Xp(t, n, i, o) {
  var u;
  if (Wf(t))
    if (n[t.id]) {
      const f = n[t.id];
      for (const p of f)
        o.add(p), Xp(p, n, i, o);
      for (const p of f)
        $_(p, t.parent, o, n, i);
    } else {
      const f = s3(t);
      for (const p of f.target)
        o.add(p), f === ((u = t.parent) == null ? void 0 : u.initial) && i.add(t.parent), Xp(p, n, i, o);
      for (const p of f.target)
        $_(p, t.parent, o, n, i);
    }
  else if (t.type === "compound") {
    const [f] = t.initial.target;
    Wf(f) || (o.add(f), i.add(f)), Xp(f, n, i, o), $_(f, t, o, n, i);
  } else if (t.type === "parallel")
    for (const f of lh(t).filter((p) => !Wf(p)))
      [...o].some((p) => Rc(p, f)) || (Wf(f) || (o.add(f), i.add(f)), Xp(f, n, i, o));
}
function d3(t, n, i, o, u) {
  for (const f of o)
    if ((!u || Rc(f, u)) && t.add(f), f.type === "parallel")
      for (const p of lh(f).filter((v) => !Wf(v)))
        [...t].some((v) => Rc(v, p)) || (t.add(p), Xp(p, n, i, t));
}
function $_(t, n, i, o, u) {
  d3(i, o, u, my(t, n));
}
function O7(t, n, i, o, u, f, p) {
  let v = t;
  const b = CE(o, u, f);
  b.sort((E, w) => w.order - E.order);
  let S;
  for (const E of b)
    for (const w of w7(E)) {
      let R;
      w.history === "deep" ? R = (k) => uC(k) && Rc(k, E) : R = (k) => k.parent === E, S ?? (S = {
        ...f
      }), S[w.id] = Array.from(u).filter(R);
    }
  for (const E of b)
    v = uh(v, n, i, [...E.exit, ...E.invoke.map((w) => i3(w.id))], p), u.delete(E);
  return [v, S || f];
}
function p3(t, n, i, o, u, f) {
  const {
    machine: p
  } = t;
  let v = t;
  for (const b of o) {
    let k = function() {
      i.system._sendInspectionEvent({
        type: "@xstate.action",
        actorRef: i.self,
        action: {
          type: typeof b == "string" ? b : typeof b == "object" ? b.type : b.name || "(anonymous)",
          params: R
        }
      }), E(w, R);
    };
    const S = typeof b == "function", E = S ? b : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      p.implementations.actions[typeof b == "string" ? b : b.type]
    );
    if (!E)
      continue;
    const w = {
      context: v.context,
      event: n,
      self: i.self,
      system: i.system
    }, R = S || typeof b == "string" ? void 0 : "params" in b ? typeof b.params == "function" ? b.params({
      context: v.context,
      event: n
    }) : b.params : void 0;
    if (!("resolve" in E)) {
      i.self._processingStatus === ca.Running ? k() : i.defer(() => {
        k();
      });
      continue;
    }
    const N = E, [z, I, H] = N.resolve(
      i,
      v,
      w,
      R,
      E,
      // this holds all params
      u
    );
    v = z, "retryResolve" in N && (f == null || f.push([N, I])), "execute" in N && (i.self._processingStatus === ca.Running ? N.execute(i, I) : i.defer(N.execute.bind(null, i, I))), H && (v = p3(v, n, i, H, u, f));
  }
  return v;
}
function uh(t, n, i, o, u, f) {
  const p = f ? [] : void 0, v = p3(t, n, i, o, {
    internalQueue: u,
    deferredActorIds: f
  }, p);
  return p == null || p.forEach(([b, S]) => {
    b.retryResolve(i, v, S);
  }), v;
}
function j_(t, n, i, o = []) {
  let u = t;
  const f = [];
  function p(S, E, w) {
    i.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: i.self,
      event: E,
      snapshot: S,
      _transitions: w
    }), f.push(S);
  }
  if (n.type === pS)
    return u = qf(CO(u, n, i), {
      status: "stopped"
    }), p(u, n, []), {
      snapshot: u,
      microstates: f
    };
  let v = n;
  if (v.type !== KA) {
    const S = v, E = r7(S), w = kO(S, u);
    if (E && !w.length)
      return u = qf(t, {
        status: "error",
        error: S.error
      }), p(u, S, []), {
        snapshot: u,
        microstates: f
      };
    u = kE(
      w,
      t,
      i,
      v,
      !1,
      // isInitial
      o
    ), p(u, S, w);
  }
  let b = !0;
  for (; u.status === "active"; ) {
    let S = b ? A7(u, v) : [];
    const E = S.length ? u : void 0;
    if (!S.length) {
      if (!o.length)
        break;
      v = o.shift(), S = kO(v, u);
    }
    u = kE(S, u, i, v, !1, o), b = u !== E, p(u, v, S);
  }
  return u.status !== "active" && CO(u, v, i), {
    snapshot: u,
    microstates: f
  };
}
function CO(t, n, i) {
  return uh(t, n, i, Object.values(t.children).map((o) => i3(o)), []);
}
function kO(t, n) {
  return n.machine.getTransitionData(n, t);
}
function A7(t, n) {
  const i = /* @__PURE__ */ new Set(), o = t._nodes.filter(uC);
  for (const u of o)
    e:
      for (const f of [u].concat(my(u, void 0)))
        if (f.always) {
          for (const p of f.always)
            if (p.guard === void 0 || sC(p.guard, t.context, n, t)) {
              i.add(p);
              break e;
            }
        }
  return c3(Array.from(i), new Set(t._nodes), t.historyValue);
}
function D7(t, n) {
  const i = hS(vS(t, n));
  return l3(t, [...i]);
}
function M7(t) {
  return !!t && typeof t == "object" && "machine" in t && "value" in t;
}
const N7 = function(n) {
  return e3(n, this.value);
}, L7 = function(n) {
  return this.tags.has(n);
}, P7 = function(n) {
  const i = this.machine.getTransitionData(this, n);
  return !!(i != null && i.length) && // Check that at least one transition is not forbidden
  i.some((o) => o.target !== void 0 || o.actions.length);
}, z7 = function() {
  const {
    _nodes: n,
    tags: i,
    machine: o,
    getMeta: u,
    toJSON: f,
    can: p,
    hasTag: v,
    matches: b,
    ...S
  } = this;
  return {
    ...S,
    tags: Array.from(i)
  };
}, $7 = function() {
  return this._nodes.reduce((n, i) => (i.meta !== void 0 && (n[i.id] = i.meta), n), {});
};
function $b(t, n) {
  return {
    status: t.status,
    output: t.output,
    error: t.error,
    machine: n,
    context: t.context,
    _nodes: t._nodes,
    value: l3(n.root, t._nodes),
    tags: new Set(t._nodes.flatMap((i) => i.tags)),
    children: t.children,
    historyValue: t.historyValue || {},
    matches: N7,
    hasTag: L7,
    can: P7,
    getMeta: $7,
    toJSON: z7
  };
}
function qf(t, n = {}) {
  return $b({
    ...t,
    ...n
  }, t.machine);
}
function j7(t, n) {
  const {
    _nodes: i,
    tags: o,
    machine: u,
    children: f,
    context: p,
    can: v,
    hasTag: b,
    matches: S,
    getMeta: E,
    toJSON: w,
    ...R
  } = t, k = {};
  for (const z in f) {
    const I = f[z];
    k[z] = {
      snapshot: I.getPersistedSnapshot(n),
      src: I.src,
      systemId: I._systemId,
      syncSnapshot: I._syncSnapshot
    };
  }
  return {
    ...R,
    context: h3(p),
    children: k
  };
}
function h3(t) {
  let n;
  for (const i in t) {
    const o = t[i];
    if (o && typeof o == "object")
      if ("sessionId" in o && "send" in o && "ref" in o)
        n ?? (n = Array.isArray(t) ? t.slice() : {
          ...t
        }), n[i] = {
          xstate$$type: lC,
          id: o.id
        };
      else {
        const u = h3(o);
        u !== o && (n ?? (n = Array.isArray(t) ? t.slice() : {
          ...t
        }), n[i] = u);
      }
  }
  return n ?? t;
}
function I7(t, n, i, o, {
  event: u,
  id: f,
  delay: p
}, {
  internalQueue: v
}) {
  const b = n.machine.implementations.delays;
  if (typeof u == "string")
    throw new Error(`Only event objects may be used with raise; use raise({ type: "${u}" }) instead`);
  const S = typeof u == "function" ? u(i, o) : u;
  let E;
  if (typeof p == "string") {
    const w = b && b[p];
    E = typeof w == "function" ? w(i, o) : w;
  } else
    E = typeof p == "function" ? p(i, o) : p;
  return typeof E != "number" && v.push(S), [n, {
    event: S,
    id: f,
    delay: E
  }];
}
function F7(t, n) {
  const {
    event: i,
    delay: o,
    id: u
  } = n;
  if (typeof o == "number") {
    t.defer(() => {
      const f = t.self;
      t.system.scheduler.schedule(f, f, i, o, u);
    });
    return;
  }
}
function jb(t, n) {
  function i(o, u) {
  }
  return i.type = "xstate.raise", i.event = t, i.id = n == null ? void 0 : n.id, i.delay = n == null ? void 0 : n.delay, i.resolve = I7, i.execute = F7, i;
}
const TO = "xstate.promise.resolve", RO = "xstate.promise.reject";
function OO(t) {
  return {
    config: t,
    transition: (i, o) => {
      if (i.status !== "active")
        return i;
      switch (o.type) {
        case TO: {
          const u = o.data;
          return {
            ...i,
            status: "done",
            output: u,
            input: void 0
          };
        }
        case RO:
          return {
            ...i,
            status: "error",
            error: o.data,
            input: void 0
          };
        case pS:
          return {
            ...i,
            status: "stopped",
            input: void 0
          };
        default:
          return i;
      }
    },
    start: (i, {
      self: o,
      system: u
    }) => {
      if (i.status !== "active")
        return;
      Promise.resolve(t({
        input: i.input,
        system: u,
        self: o
      })).then((p) => {
        o.getSnapshot().status === "active" && u._relay(o, o, {
          type: TO,
          data: p
        });
      }, (p) => {
        o.getSnapshot().status === "active" && u._relay(o, o, {
          type: RO,
          data: p
        });
      });
    },
    getInitialSnapshot: (i, o) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input: o
    }),
    getPersistedSnapshot: (i) => i,
    restoreSnapshot: (i) => i
  };
}
function U7(t, {
  machine: n,
  context: i
}, o, u) {
  const f = (p, v = {}) => {
    const {
      systemId: b,
      input: S
    } = v;
    if (typeof p == "string") {
      const E = oC(n, p);
      if (!E)
        throw new Error(`Actor logic '${p}' not implemented in machine '${n.id}'`);
      const w = oh(E, {
        id: v.id,
        parent: t.self,
        syncSnapshot: v.syncSnapshot,
        input: typeof S == "function" ? S({
          context: i,
          event: o,
          self: t.self
        }) : S,
        src: p,
        systemId: b
      });
      return u[w.id] = w, w;
    } else
      return oh(p, {
        id: v.id,
        parent: t.self,
        syncSnapshot: v.syncSnapshot,
        input: v.input,
        src: p,
        systemId: b
      });
  };
  return (p, v) => {
    const b = f(p, v);
    return u[b.id] = b, t.defer(() => {
      b._processingStatus !== ca.Stopped && b.start();
    }), b;
  };
}
function B7(t, n, i, o, {
  assignment: u
}) {
  if (!n.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const f = {}, p = {
    context: n.context,
    event: i.event,
    spawn: U7(t, n, i.event, f),
    self: t.self,
    system: t.system
  };
  let v = {};
  if (typeof u == "function")
    v = u(p, o);
  else
    for (const S of Object.keys(u)) {
      const E = u[S];
      v[S] = typeof E == "function" ? E(p, o) : E;
    }
  const b = Object.assign({}, n.context, v);
  return [qf(n, {
    context: b,
    children: Object.keys(f).length ? {
      ...n.children,
      ...f
    } : n.children
  })];
}
function Ib(t) {
  function n(i, o) {
  }
  return n.type = "xstate.assign", n.assignment = t, n.resolve = B7, n;
}
const AO = /* @__PURE__ */ new WeakMap();
function Bp(t, n, i) {
  let o = AO.get(t);
  return o ? n in o || (o[n] = i()) : (o = {
    [n]: i()
  }, AO.set(t, o)), o[n];
}
const H7 = {}, Av = (t) => typeof t == "string" ? {
  type: t
} : typeof t == "function" ? "resolve" in t ? {
  type: t.type
} : {
  type: t.name
} : t;
class pC {
  constructor(n, i) {
    if (this.config = n, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = i._parent, this.key = i._key, this.machine = i._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(XA), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? xO(this.config.states, (o, u) => new pC(o, {
      _parent: this,
      _key: u,
      _machine: this.machine
    })) : H7, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = Tc(this.config.entry).slice(), this.exit = Tc(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = Tc(n.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = v7(this), this.config.always && (this.always = Zp(this.config.always).map((n) => Uf(this, QA, n))), Object.keys(this.states).forEach((n) => {
      this.states[n]._initialize();
    });
  }
  /**
   * The well-structured state node definition.
   */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(Av),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((n) => `#${n.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(Av),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: xO(this.states, (n) => n.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((n) => ({
        ...n,
        actions: n.actions.map(Av)
      })),
      entry: this.entry.map(Av),
      exit: this.exit.map(Av),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /**
   * The logic invoked as actors by this state node.
   */
  get invoke() {
    return Bp(this, "invoke", () => Tc(this.config.invoke).map((n, i) => {
      const {
        src: o,
        systemId: u
      } = n, f = n.id ?? _O(this.id, i), p = typeof o == "string" ? o : `xstate.invoke.${_O(this.id, i)}`;
      return {
        ...n,
        src: p,
        id: f,
        systemId: u,
        toJSON() {
          const {
            onDone: v,
            onError: b,
            ...S
          } = n;
          return {
            ...S,
            type: "xstate.invoke",
            src: p,
            id: f
          };
        }
      };
    }));
  }
  /**
   * The mapping of events to transitions.
   */
  get on() {
    return Bp(this, "on", () => [...this.transitions].flatMap(([i, o]) => o.map((u) => [i, u])).reduce((i, [o, u]) => (i[o] = i[o] || [], i[o].push(u), i), {}));
  }
  get after() {
    return Bp(this, "delayedTransitions", () => m7(this));
  }
  get initial() {
    return Bp(this, "initial", () => y7(this, this.config.initial));
  }
  /** @internal */
  next(n, i) {
    const o = i.type, u = [];
    let f;
    const p = Bp(this, `candidates-${o}`, () => h7(this, o));
    for (const v of p) {
      const {
        guard: b
      } = v, S = n.context;
      let E = !1;
      try {
        E = !b || sC(b, S, i, n);
      } catch (w) {
        const R = typeof b == "string" ? b : typeof b == "object" ? b.type : void 0;
        throw new Error(`Unable to evaluate guard ${R ? `'${R}' ` : ""}in transition for event '${o}' in state node '${this.id}':
${w.message}`);
      }
      if (E) {
        u.push(...v.actions), f = v;
        break;
      }
    }
    return f ? [f] : void 0;
  }
  /**
   * All the event types accepted by this state node and its descendants.
   */
  get events() {
    return Bp(this, "events", () => {
      const {
        states: n
      } = this, i = new Set(this.ownEvents);
      if (n)
        for (const o of Object.keys(n)) {
          const u = n[o];
          if (u.states)
            for (const f of u.events)
              i.add(`${f}`);
        }
      return Array.from(i);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const n = new Set([...this.transitions.keys()].filter((i) => this.transitions.get(i).some((o) => !(!o.target && !o.actions.length && !o.reenter))));
    return Array.from(n);
  }
}
const V7 = "#";
class hC {
  constructor(n, i) {
    this.config = n, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.__TResolvedTypesMeta = void 0, this.id = n.id || "(machine)", this.implementations = {
      actors: (i == null ? void 0 : i.actors) ?? {},
      actions: (i == null ? void 0 : i.actions) ?? {},
      delays: (i == null ? void 0 : i.delays) ?? {},
      guards: (i == null ? void 0 : i.guards) ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new pC(n, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations
   * and merges the `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)
   *  to recursively merge with the existing options.
   *
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(n) {
    const {
      actions: i,
      guards: o,
      actors: u,
      delays: f
    } = this.implementations;
    return new hC(this.config, {
      actions: {
        ...i,
        ...n.actions
      },
      guards: {
        ...o,
        ...n.guards
      },
      actors: {
        ...u,
        ...n.actors
      },
      delays: {
        ...f,
        ...n.delays
      }
    });
  }
  resolveState(n) {
    const i = D7(this.root, n.value), o = hS(vS(this.root, i));
    return $b({
      _nodes: [...o],
      context: n.context || {},
      children: {},
      status: cC(o, this.root) ? "done" : n.status || "active",
      output: n.output,
      error: n.error,
      historyValue: n.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received `event`.
   * Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(n, i, o) {
    return j_(n, i, o).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`.
   * Calculates a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(n, i, o) {
    return j_(n, i, o).microstates;
  }
  getTransitionData(n, i) {
    return fC(this.root, n.value, n, i) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps.
   * This "pre-initial" state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(n, i, o) {
    const {
      context: u
    } = this.config, f = $b({
      context: typeof u != "function" && u ? u : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof u == "function" ? uh(f, i, n, [Ib(({
      spawn: v,
      event: b,
      self: S
    }) => u({
      spawn: v,
      input: b.input,
      self: S
    }))], o) : f;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.
   */
  getInitialSnapshot(n, i) {
    const o = JA(i), u = [], f = this.getPreInitialState(n, o, u), p = kE([{
      target: [...u3(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], f, n, o, !0, u), {
      snapshot: v
    } = j_(p, o, n, u);
    return v;
  }
  start(n) {
    Object.values(n.children).forEach((i) => {
      i.getSnapshot().status === "active" && i.start();
    });
  }
  getStateNodeById(n) {
    const i = aC(n), o = i.slice(1), u = IS(i[0]) ? i[0].slice(V7.length) : i[0], f = this.idMap.get(u);
    if (!f)
      throw new Error(`Child state node '#${u}' does not exist on machine '${this.id}'`);
    return mS(f, o);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(n, i) {
    return j7(n, i);
  }
  restoreSnapshot(n, i) {
    const o = {}, u = n.children;
    Object.keys(u).forEach((b) => {
      const S = u[b], E = S.snapshot, w = S.src, R = typeof w == "string" ? oC(this, w) : w;
      if (!R)
        return;
      const k = oh(R, {
        id: b,
        parent: i.self,
        syncSnapshot: S.syncSnapshot,
        snapshot: E,
        src: w,
        systemId: S.systemId
      });
      o[b] = k;
    });
    const f = $b({
      ...n,
      children: o,
      _nodes: Array.from(hS(vS(this.root, n.value)))
    }, this);
    let p = /* @__PURE__ */ new Set();
    function v(b, S) {
      if (!p.has(b)) {
        p.add(b);
        for (let E in b) {
          const w = b[E];
          if (w && typeof w == "object") {
            if ("xstate$$type" in w && w.xstate$$type === lC) {
              b[E] = S[w.id];
              continue;
            }
            v(w, S);
          }
        }
      }
    }
    return v(f.context, o), f;
  }
}
function W7(t, n) {
  return new hC(t, n);
}
function Y7({
  schemas: t,
  actors: n,
  actions: i,
  guards: o,
  delays: u
}) {
  return {
    createMachine: (f) => W7({
      ...f,
      schemas: t
    }, {
      actors: n,
      actions: i,
      guards: o,
      delays: u
    })
  };
}
var I_ = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DO;
function Z7() {
  if (DO)
    return I_;
  DO = 1;
  var t = L, n = iC;
  function i(S, E) {
    return S === E && (S !== 0 || 1 / S === 1 / E) || S !== S && E !== E;
  }
  var o = typeof Object.is == "function" ? Object.is : i, u = n.useSyncExternalStore, f = t.useRef, p = t.useEffect, v = t.useMemo, b = t.useDebugValue;
  return I_.useSyncExternalStoreWithSelector = function(S, E, w, R, k) {
    var N = f(null);
    if (N.current === null) {
      var z = { hasValue: !1, value: null };
      N.current = z;
    } else
      z = N.current;
    N = v(function() {
      function H(V) {
        if (!q) {
          if (q = !0, G = V, V = R(V), k !== void 0 && z.hasValue) {
            var ue = z.value;
            if (k(ue, V))
              return te = ue;
          }
          return te = V;
        }
        if (ue = te, o(G, V))
          return ue;
        var we = R(V);
        return k !== void 0 && k(ue, we) ? ue : (G = V, te = we);
      }
      var q = !1, G, te, ee = w === void 0 ? null : w;
      return [function() {
        return H(E());
      }, ee === null ? void 0 : function() {
        return H(ee());
      }];
    }, [E, w, R, k]);
    var I = u(S, N[0], N[1]);
    return p(function() {
      z.hasValue = !0, z.value = I;
    }, [I]), b(I), I;
  }, I_;
}
var F_ = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var MO;
function q7() {
  return MO || (MO = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = L, n = iC;
    function i(E, w) {
      return E === w && (E !== 0 || 1 / E === 1 / w) || E !== E && w !== w;
    }
    var o = typeof Object.is == "function" ? Object.is : i, u = n.useSyncExternalStore, f = t.useRef, p = t.useEffect, v = t.useMemo, b = t.useDebugValue;
    function S(E, w, R, k, N) {
      var z = f(null), I;
      z.current === null ? (I = {
        hasValue: !1,
        value: null
      }, z.current = I) : I = z.current;
      var H = v(function() {
        var ee = !1, V, ue, we = function(ve) {
          if (!ee) {
            ee = !0, V = ve;
            var Pe = k(ve);
            if (N !== void 0 && I.hasValue) {
              var Ue = I.value;
              if (N(Ue, Pe))
                return ue = Ue, Ue;
            }
            return ue = Pe, Pe;
          }
          var We = V, at = ue;
          if (o(We, ve))
            return at;
          var Te = k(ve);
          return N !== void 0 && N(at, Te) ? at : (V = ve, ue = Te, Te);
        }, me = R === void 0 ? null : R, Le = function() {
          return we(w());
        }, xe = me === null ? void 0 : function() {
          return we(me());
        };
        return [Le, xe];
      }, [w, R, k, N]), q = H[0], G = H[1], te = u(E, q, G);
      return p(function() {
        I.hasValue = !0, I.value = te;
      }, [te]), b(te), te;
    }
    F_.useSyncExternalStoreWithSelector = S, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), F_;
}
process.env.NODE_ENV === "production" ? Z7() : q7();
const m3 = (t, n) => {
  n(t);
  const i = t.getSnapshot().children;
  i && Object.values(i).forEach((o) => {
    m3(o, n);
  });
};
function G7(t) {
  var o, u;
  const n = [];
  m3(t, (f) => {
    n.push([f, f.getSnapshot()]), f.observers = /* @__PURE__ */ new Set();
  });
  const i = (u = (o = t.system).getSnapshot) == null ? void 0 : u.call(o);
  t.stop(), t.system._snapshot = i, n.forEach(([f, p]) => {
    f._processingStatus = 0, f._snapshot = p;
  });
}
function X7(t, n) {
  let [[i, o], u] = L.useState(() => {
    const f = oh(t, n);
    return [t.config, f];
  });
  if (t.config !== i) {
    const f = oh(t, {
      ...n,
      snapshot: o.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    u([t.config, f]), o = f;
  }
  return H9(() => {
    o.logic.implementations = t.implementations;
  }), o;
}
function Q7(t, n = {}) {
  const i = X7(t, n), o = L.useCallback(() => i.getSnapshot(), [i]), u = L.useCallback((p) => {
    const {
      unsubscribe: v
    } = i.subscribe(p);
    return v;
  }, [i]), f = iC.useSyncExternalStore(u, o, o);
  return L.useEffect(() => (i.start(), () => {
    G7(i);
  }), [i]), [f, i.send, i];
}
function K7(t, n = {}) {
  return Q7(t, n);
}
var Sn;
(function(t) {
  t.assertEqual = (u) => u;
  function n(u) {
  }
  t.assertIs = n;
  function i(u) {
    throw new Error();
  }
  t.assertNever = i, t.arrayToEnum = (u) => {
    const f = {};
    for (const p of u)
      f[p] = p;
    return f;
  }, t.getValidEnumValues = (u) => {
    const f = t.objectKeys(u).filter((v) => typeof u[u[v]] != "number"), p = {};
    for (const v of f)
      p[v] = u[v];
    return t.objectValues(p);
  }, t.objectValues = (u) => t.objectKeys(u).map(function(f) {
    return u[f];
  }), t.objectKeys = typeof Object.keys == "function" ? (u) => Object.keys(u) : (u) => {
    const f = [];
    for (const p in u)
      Object.prototype.hasOwnProperty.call(u, p) && f.push(p);
    return f;
  }, t.find = (u, f) => {
    for (const p of u)
      if (f(p))
        return p;
  }, t.isInteger = typeof Number.isInteger == "function" ? (u) => Number.isInteger(u) : (u) => typeof u == "number" && isFinite(u) && Math.floor(u) === u;
  function o(u, f = " | ") {
    return u.map((p) => typeof p == "string" ? `'${p}'` : p).join(f);
  }
  t.joinValues = o, t.jsonStringifyReplacer = (u, f) => typeof f == "bigint" ? f.toString() : f;
})(Sn || (Sn = {}));
var TE;
(function(t) {
  t.mergeShapes = (n, i) => ({
    ...n,
    ...i
    // second overwrites first
  });
})(TE || (TE = {}));
const Qe = Sn.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), kc = (t) => {
  switch (typeof t) {
    case "undefined":
      return Qe.undefined;
    case "string":
      return Qe.string;
    case "number":
      return isNaN(t) ? Qe.nan : Qe.number;
    case "boolean":
      return Qe.boolean;
    case "function":
      return Qe.function;
    case "bigint":
      return Qe.bigint;
    case "symbol":
      return Qe.symbol;
    case "object":
      return Array.isArray(t) ? Qe.array : t === null ? Qe.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? Qe.promise : typeof Map < "u" && t instanceof Map ? Qe.map : typeof Set < "u" && t instanceof Set ? Qe.set : typeof Date < "u" && t instanceof Date ? Qe.date : Qe.object;
    default:
      return Qe.unknown;
  }
}, Ne = Sn.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), J7 = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class cl extends Error {
  constructor(n) {
    super(), this.issues = [], this.addIssue = (o) => {
      this.issues = [...this.issues, o];
    }, this.addIssues = (o = []) => {
      this.issues = [...this.issues, ...o];
    };
    const i = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, i) : this.__proto__ = i, this.name = "ZodError", this.issues = n;
  }
  get errors() {
    return this.issues;
  }
  format(n) {
    const i = n || function(f) {
      return f.message;
    }, o = { _errors: [] }, u = (f) => {
      for (const p of f.issues)
        if (p.code === "invalid_union")
          p.unionErrors.map(u);
        else if (p.code === "invalid_return_type")
          u(p.returnTypeError);
        else if (p.code === "invalid_arguments")
          u(p.argumentsError);
        else if (p.path.length === 0)
          o._errors.push(i(p));
        else {
          let v = o, b = 0;
          for (; b < p.path.length; ) {
            const S = p.path[b];
            b === p.path.length - 1 ? (v[S] = v[S] || { _errors: [] }, v[S]._errors.push(i(p))) : v[S] = v[S] || { _errors: [] }, v = v[S], b++;
          }
        }
    };
    return u(this), o;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Sn.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(n = (i) => i.message) {
    const i = {}, o = [];
    for (const u of this.issues)
      u.path.length > 0 ? (i[u.path[0]] = i[u.path[0]] || [], i[u.path[0]].push(n(u))) : o.push(n(u));
    return { formErrors: o, fieldErrors: i };
  }
  get formErrors() {
    return this.flatten();
  }
}
cl.create = (t) => new cl(t);
const ty = (t, n) => {
  let i;
  switch (t.code) {
    case Ne.invalid_type:
      t.received === Qe.undefined ? i = "Required" : i = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Ne.invalid_literal:
      i = `Invalid literal value, expected ${JSON.stringify(t.expected, Sn.jsonStringifyReplacer)}`;
      break;
    case Ne.unrecognized_keys:
      i = `Unrecognized key(s) in object: ${Sn.joinValues(t.keys, ", ")}`;
      break;
    case Ne.invalid_union:
      i = "Invalid input";
      break;
    case Ne.invalid_union_discriminator:
      i = `Invalid discriminator value. Expected ${Sn.joinValues(t.options)}`;
      break;
    case Ne.invalid_enum_value:
      i = `Invalid enum value. Expected ${Sn.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Ne.invalid_arguments:
      i = "Invalid function arguments";
      break;
    case Ne.invalid_return_type:
      i = "Invalid function return type";
      break;
    case Ne.invalid_date:
      i = "Invalid date";
      break;
    case Ne.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (i = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (i = `${i} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? i = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? i = `Invalid input: must end with "${t.validation.endsWith}"` : Sn.assertNever(t.validation) : t.validation !== "regex" ? i = `Invalid ${t.validation}` : i = "Invalid";
      break;
    case Ne.too_small:
      t.type === "array" ? i = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? i = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? i = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? i = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : i = "Invalid input";
      break;
    case Ne.too_big:
      t.type === "array" ? i = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? i = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? i = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? i = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? i = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : i = "Invalid input";
      break;
    case Ne.custom:
      i = "Invalid input";
      break;
    case Ne.invalid_intersection_types:
      i = "Intersection results could not be merged";
      break;
    case Ne.not_multiple_of:
      i = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Ne.not_finite:
      i = "Number must be finite";
      break;
    default:
      i = n.defaultError, Sn.assertNever(t);
  }
  return { message: i };
};
let v3 = ty;
function eI(t) {
  v3 = t;
}
function yS() {
  return v3;
}
const gS = (t) => {
  const { data: n, path: i, errorMaps: o, issueData: u } = t, f = [...i, ...u.path || []], p = {
    ...u,
    path: f
  };
  let v = "";
  const b = o.filter((S) => !!S).slice().reverse();
  for (const S of b)
    v = S(p, { data: n, defaultError: v }).message;
  return {
    ...u,
    path: f,
    message: u.message || v
  };
}, tI = [];
function Je(t, n) {
  const i = gS({
    issueData: n,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      yS(),
      ty
      // then global default map
    ].filter((o) => !!o)
  });
  t.common.issues.push(i);
}
class Zi {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(n, i) {
    const o = [];
    for (const u of i) {
      if (u.status === "aborted")
        return $t;
      u.status === "dirty" && n.dirty(), o.push(u.value);
    }
    return { status: n.value, value: o };
  }
  static async mergeObjectAsync(n, i) {
    const o = [];
    for (const u of i)
      o.push({
        key: await u.key,
        value: await u.value
      });
    return Zi.mergeObjectSync(n, o);
  }
  static mergeObjectSync(n, i) {
    const o = {};
    for (const u of i) {
      const { key: f, value: p } = u;
      if (f.status === "aborted" || p.status === "aborted")
        return $t;
      f.status === "dirty" && n.dirty(), p.status === "dirty" && n.dirty(), f.value !== "__proto__" && (typeof p.value < "u" || u.alwaysSet) && (o[f.value] = p.value);
    }
    return { status: n.value, value: o };
  }
}
const $t = Object.freeze({
  status: "aborted"
}), y3 = (t) => ({ status: "dirty", value: t }), da = (t) => ({ status: "valid", value: t }), RE = (t) => t.status === "aborted", OE = (t) => t.status === "dirty", ny = (t) => t.status === "valid", bS = (t) => typeof Promise < "u" && t instanceof Promise;
var St;
(function(t) {
  t.errToObj = (n) => typeof n == "string" ? { message: n } : n || {}, t.toString = (n) => typeof n == "string" ? n : n == null ? void 0 : n.message;
})(St || (St = {}));
class ds {
  constructor(n, i, o, u) {
    this._cachedPath = [], this.parent = n, this.data = i, this._path = o, this._key = u;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const NO = (t, n) => {
  if (ny(n))
    return { success: !0, data: n.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const i = new cl(t.common.issues);
      return this._error = i, this._error;
    }
  };
};
function jt(t) {
  if (!t)
    return {};
  const { errorMap: n, invalid_type_error: i, required_error: o, description: u } = t;
  if (n && (i || o))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return n ? { errorMap: n, description: u } : { errorMap: (p, v) => p.code !== "invalid_type" ? { message: v.defaultError } : typeof v.data > "u" ? { message: o ?? v.defaultError } : { message: i ?? v.defaultError }, description: u };
}
class Yt {
  constructor(n) {
    this.spa = this.safeParseAsync, this._def = n, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(n) {
    return kc(n.data);
  }
  _getOrReturnCtx(n, i) {
    return i || {
      common: n.parent.common,
      data: n.data,
      parsedType: kc(n.data),
      schemaErrorMap: this._def.errorMap,
      path: n.path,
      parent: n.parent
    };
  }
  _processInputParams(n) {
    return {
      status: new Zi(),
      ctx: {
        common: n.parent.common,
        data: n.data,
        parsedType: kc(n.data),
        schemaErrorMap: this._def.errorMap,
        path: n.path,
        parent: n.parent
      }
    };
  }
  _parseSync(n) {
    const i = this._parse(n);
    if (bS(i))
      throw new Error("Synchronous parse encountered promise.");
    return i;
  }
  _parseAsync(n) {
    const i = this._parse(n);
    return Promise.resolve(i);
  }
  parse(n, i) {
    const o = this.safeParse(n, i);
    if (o.success)
      return o.data;
    throw o.error;
  }
  safeParse(n, i) {
    var o;
    const u = {
      common: {
        issues: [],
        async: (o = i == null ? void 0 : i.async) !== null && o !== void 0 ? o : !1,
        contextualErrorMap: i == null ? void 0 : i.errorMap
      },
      path: (i == null ? void 0 : i.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: n,
      parsedType: kc(n)
    }, f = this._parseSync({ data: n, path: u.path, parent: u });
    return NO(u, f);
  }
  async parseAsync(n, i) {
    const o = await this.safeParseAsync(n, i);
    if (o.success)
      return o.data;
    throw o.error;
  }
  async safeParseAsync(n, i) {
    const o = {
      common: {
        issues: [],
        contextualErrorMap: i == null ? void 0 : i.errorMap,
        async: !0
      },
      path: (i == null ? void 0 : i.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: n,
      parsedType: kc(n)
    }, u = this._parse({ data: n, path: o.path, parent: o }), f = await (bS(u) ? u : Promise.resolve(u));
    return NO(o, f);
  }
  refine(n, i) {
    const o = (u) => typeof i == "string" || typeof i > "u" ? { message: i } : typeof i == "function" ? i(u) : i;
    return this._refinement((u, f) => {
      const p = n(u), v = () => f.addIssue({
        code: Ne.custom,
        ...o(u)
      });
      return typeof Promise < "u" && p instanceof Promise ? p.then((b) => b ? !0 : (v(), !1)) : p ? !0 : (v(), !1);
    });
  }
  refinement(n, i) {
    return this._refinement((o, u) => n(o) ? !0 : (u.addIssue(typeof i == "function" ? i(o, u) : i), !1));
  }
  _refinement(n) {
    return new dl({
      schema: this,
      typeName: Me.ZodEffects,
      effect: { type: "refinement", refinement: n }
    });
  }
  superRefine(n) {
    return this._refinement(n);
  }
  optional() {
    return fu.create(this, this._def);
  }
  nullable() {
    return Qf.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return fl.create(this, this._def);
  }
  promise() {
    return fh.create(this, this._def);
  }
  or(n) {
    return oy.create([this, n], this._def);
  }
  and(n) {
    return ly.create(this, n, this._def);
  }
  transform(n) {
    return new dl({
      ...jt(this._def),
      schema: this,
      typeName: Me.ZodEffects,
      effect: { type: "transform", transform: n }
    });
  }
  default(n) {
    const i = typeof n == "function" ? n : () => n;
    return new dy({
      ...jt(this._def),
      innerType: this,
      defaultValue: i,
      typeName: Me.ZodDefault
    });
  }
  brand() {
    return new b3({
      typeName: Me.ZodBranded,
      type: this,
      ...jt(this._def)
    });
  }
  catch(n) {
    const i = typeof n == "function" ? n : () => n;
    return new _S({
      ...jt(this._def),
      innerType: this,
      catchValue: i,
      typeName: Me.ZodCatch
    });
  }
  describe(n) {
    const i = this.constructor;
    return new i({
      ...this._def,
      description: n
    });
  }
  pipe(n) {
    return vy.create(this, n);
  }
  readonly() {
    return CS.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const nI = /^c[^\s-]{8,}$/i, rI = /^[a-z][a-z0-9]*$/, iI = /^[0-9A-HJKMNP-TV-Z]{26}$/, aI = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, oI = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, lI = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let U_;
const sI = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, uI = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, cI = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function fI(t, n) {
  return !!((n === "v4" || !n) && sI.test(t) || (n === "v6" || !n) && uI.test(t));
}
class ul extends Yt {
  _parse(n) {
    if (this._def.coerce && (n.data = String(n.data)), this._getType(n) !== Qe.string) {
      const f = this._getOrReturnCtx(n);
      return Je(
        f,
        {
          code: Ne.invalid_type,
          expected: Qe.string,
          received: f.parsedType
        }
        //
      ), $t;
    }
    const o = new Zi();
    let u;
    for (const f of this._def.checks)
      if (f.kind === "min")
        n.data.length < f.value && (u = this._getOrReturnCtx(n, u), Je(u, {
          code: Ne.too_small,
          minimum: f.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: f.message
        }), o.dirty());
      else if (f.kind === "max")
        n.data.length > f.value && (u = this._getOrReturnCtx(n, u), Je(u, {
          code: Ne.too_big,
          maximum: f.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: f.message
        }), o.dirty());
      else if (f.kind === "length") {
        const p = n.data.length > f.value, v = n.data.length < f.value;
        (p || v) && (u = this._getOrReturnCtx(n, u), p ? Je(u, {
          code: Ne.too_big,
          maximum: f.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: f.message
        }) : v && Je(u, {
          code: Ne.too_small,
          minimum: f.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: f.message
        }), o.dirty());
      } else if (f.kind === "email")
        oI.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "email",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty());
      else if (f.kind === "emoji")
        U_ || (U_ = new RegExp(lI, "u")), U_.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "emoji",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty());
      else if (f.kind === "uuid")
        aI.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "uuid",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty());
      else if (f.kind === "cuid")
        nI.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "cuid",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty());
      else if (f.kind === "cuid2")
        rI.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "cuid2",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty());
      else if (f.kind === "ulid")
        iI.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "ulid",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty());
      else if (f.kind === "url")
        try {
          new URL(n.data);
        } catch {
          u = this._getOrReturnCtx(n, u), Je(u, {
            validation: "url",
            code: Ne.invalid_string,
            message: f.message
          }), o.dirty();
        }
      else
        f.kind === "regex" ? (f.regex.lastIndex = 0, f.regex.test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "regex",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty())) : f.kind === "trim" ? n.data = n.data.trim() : f.kind === "includes" ? n.data.includes(f.value, f.position) || (u = this._getOrReturnCtx(n, u), Je(u, {
          code: Ne.invalid_string,
          validation: { includes: f.value, position: f.position },
          message: f.message
        }), o.dirty()) : f.kind === "toLowerCase" ? n.data = n.data.toLowerCase() : f.kind === "toUpperCase" ? n.data = n.data.toUpperCase() : f.kind === "startsWith" ? n.data.startsWith(f.value) || (u = this._getOrReturnCtx(n, u), Je(u, {
          code: Ne.invalid_string,
          validation: { startsWith: f.value },
          message: f.message
        }), o.dirty()) : f.kind === "endsWith" ? n.data.endsWith(f.value) || (u = this._getOrReturnCtx(n, u), Je(u, {
          code: Ne.invalid_string,
          validation: { endsWith: f.value },
          message: f.message
        }), o.dirty()) : f.kind === "datetime" ? cI(f).test(n.data) || (u = this._getOrReturnCtx(n, u), Je(u, {
          code: Ne.invalid_string,
          validation: "datetime",
          message: f.message
        }), o.dirty()) : f.kind === "ip" ? fI(n.data, f.version) || (u = this._getOrReturnCtx(n, u), Je(u, {
          validation: "ip",
          code: Ne.invalid_string,
          message: f.message
        }), o.dirty()) : Sn.assertNever(f);
    return { status: o.value, value: n.data };
  }
  _regex(n, i, o) {
    return this.refinement((u) => n.test(u), {
      validation: i,
      code: Ne.invalid_string,
      ...St.errToObj(o)
    });
  }
  _addCheck(n) {
    return new ul({
      ...this._def,
      checks: [...this._def.checks, n]
    });
  }
  email(n) {
    return this._addCheck({ kind: "email", ...St.errToObj(n) });
  }
  url(n) {
    return this._addCheck({ kind: "url", ...St.errToObj(n) });
  }
  emoji(n) {
    return this._addCheck({ kind: "emoji", ...St.errToObj(n) });
  }
  uuid(n) {
    return this._addCheck({ kind: "uuid", ...St.errToObj(n) });
  }
  cuid(n) {
    return this._addCheck({ kind: "cuid", ...St.errToObj(n) });
  }
  cuid2(n) {
    return this._addCheck({ kind: "cuid2", ...St.errToObj(n) });
  }
  ulid(n) {
    return this._addCheck({ kind: "ulid", ...St.errToObj(n) });
  }
  ip(n) {
    return this._addCheck({ kind: "ip", ...St.errToObj(n) });
  }
  datetime(n) {
    var i;
    return typeof n == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: n
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (n == null ? void 0 : n.precision) > "u" ? null : n == null ? void 0 : n.precision,
      offset: (i = n == null ? void 0 : n.offset) !== null && i !== void 0 ? i : !1,
      ...St.errToObj(n == null ? void 0 : n.message)
    });
  }
  regex(n, i) {
    return this._addCheck({
      kind: "regex",
      regex: n,
      ...St.errToObj(i)
    });
  }
  includes(n, i) {
    return this._addCheck({
      kind: "includes",
      value: n,
      position: i == null ? void 0 : i.position,
      ...St.errToObj(i == null ? void 0 : i.message)
    });
  }
  startsWith(n, i) {
    return this._addCheck({
      kind: "startsWith",
      value: n,
      ...St.errToObj(i)
    });
  }
  endsWith(n, i) {
    return this._addCheck({
      kind: "endsWith",
      value: n,
      ...St.errToObj(i)
    });
  }
  min(n, i) {
    return this._addCheck({
      kind: "min",
      value: n,
      ...St.errToObj(i)
    });
  }
  max(n, i) {
    return this._addCheck({
      kind: "max",
      value: n,
      ...St.errToObj(i)
    });
  }
  length(n, i) {
    return this._addCheck({
      kind: "length",
      value: n,
      ...St.errToObj(i)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(n) {
    return this.min(1, St.errToObj(n));
  }
  trim() {
    return new ul({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ul({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ul({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((n) => n.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((n) => n.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((n) => n.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((n) => n.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((n) => n.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((n) => n.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((n) => n.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((n) => n.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((n) => n.kind === "ip");
  }
  get minLength() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "min" && (n === null || i.value > n) && (n = i.value);
    return n;
  }
  get maxLength() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "max" && (n === null || i.value < n) && (n = i.value);
    return n;
  }
}
ul.create = (t) => {
  var n;
  return new ul({
    checks: [],
    typeName: Me.ZodString,
    coerce: (n = t == null ? void 0 : t.coerce) !== null && n !== void 0 ? n : !1,
    ...jt(t)
  });
};
function dI(t, n) {
  const i = (t.toString().split(".")[1] || "").length, o = (n.toString().split(".")[1] || "").length, u = i > o ? i : o, f = parseInt(t.toFixed(u).replace(".", "")), p = parseInt(n.toFixed(u).replace(".", ""));
  return f % p / Math.pow(10, u);
}
class Oc extends Yt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(n) {
    if (this._def.coerce && (n.data = Number(n.data)), this._getType(n) !== Qe.number) {
      const f = this._getOrReturnCtx(n);
      return Je(f, {
        code: Ne.invalid_type,
        expected: Qe.number,
        received: f.parsedType
      }), $t;
    }
    let o;
    const u = new Zi();
    for (const f of this._def.checks)
      f.kind === "int" ? Sn.isInteger(n.data) || (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.invalid_type,
        expected: "integer",
        received: "float",
        message: f.message
      }), u.dirty()) : f.kind === "min" ? (f.inclusive ? n.data < f.value : n.data <= f.value) && (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.too_small,
        minimum: f.value,
        type: "number",
        inclusive: f.inclusive,
        exact: !1,
        message: f.message
      }), u.dirty()) : f.kind === "max" ? (f.inclusive ? n.data > f.value : n.data >= f.value) && (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.too_big,
        maximum: f.value,
        type: "number",
        inclusive: f.inclusive,
        exact: !1,
        message: f.message
      }), u.dirty()) : f.kind === "multipleOf" ? dI(n.data, f.value) !== 0 && (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.not_multiple_of,
        multipleOf: f.value,
        message: f.message
      }), u.dirty()) : f.kind === "finite" ? Number.isFinite(n.data) || (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.not_finite,
        message: f.message
      }), u.dirty()) : Sn.assertNever(f);
    return { status: u.value, value: n.data };
  }
  gte(n, i) {
    return this.setLimit("min", n, !0, St.toString(i));
  }
  gt(n, i) {
    return this.setLimit("min", n, !1, St.toString(i));
  }
  lte(n, i) {
    return this.setLimit("max", n, !0, St.toString(i));
  }
  lt(n, i) {
    return this.setLimit("max", n, !1, St.toString(i));
  }
  setLimit(n, i, o, u) {
    return new Oc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: n,
          value: i,
          inclusive: o,
          message: St.toString(u)
        }
      ]
    });
  }
  _addCheck(n) {
    return new Oc({
      ...this._def,
      checks: [...this._def.checks, n]
    });
  }
  int(n) {
    return this._addCheck({
      kind: "int",
      message: St.toString(n)
    });
  }
  positive(n) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: St.toString(n)
    });
  }
  negative(n) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: St.toString(n)
    });
  }
  nonpositive(n) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: St.toString(n)
    });
  }
  nonnegative(n) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: St.toString(n)
    });
  }
  multipleOf(n, i) {
    return this._addCheck({
      kind: "multipleOf",
      value: n,
      message: St.toString(i)
    });
  }
  finite(n) {
    return this._addCheck({
      kind: "finite",
      message: St.toString(n)
    });
  }
  safe(n) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: St.toString(n)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: St.toString(n)
    });
  }
  get minValue() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "min" && (n === null || i.value > n) && (n = i.value);
    return n;
  }
  get maxValue() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "max" && (n === null || i.value < n) && (n = i.value);
    return n;
  }
  get isInt() {
    return !!this._def.checks.find((n) => n.kind === "int" || n.kind === "multipleOf" && Sn.isInteger(n.value));
  }
  get isFinite() {
    let n = null, i = null;
    for (const o of this._def.checks) {
      if (o.kind === "finite" || o.kind === "int" || o.kind === "multipleOf")
        return !0;
      o.kind === "min" ? (i === null || o.value > i) && (i = o.value) : o.kind === "max" && (n === null || o.value < n) && (n = o.value);
    }
    return Number.isFinite(i) && Number.isFinite(n);
  }
}
Oc.create = (t) => new Oc({
  checks: [],
  typeName: Me.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...jt(t)
});
class Ac extends Yt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(n) {
    if (this._def.coerce && (n.data = BigInt(n.data)), this._getType(n) !== Qe.bigint) {
      const f = this._getOrReturnCtx(n);
      return Je(f, {
        code: Ne.invalid_type,
        expected: Qe.bigint,
        received: f.parsedType
      }), $t;
    }
    let o;
    const u = new Zi();
    for (const f of this._def.checks)
      f.kind === "min" ? (f.inclusive ? n.data < f.value : n.data <= f.value) && (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.too_small,
        type: "bigint",
        minimum: f.value,
        inclusive: f.inclusive,
        message: f.message
      }), u.dirty()) : f.kind === "max" ? (f.inclusive ? n.data > f.value : n.data >= f.value) && (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.too_big,
        type: "bigint",
        maximum: f.value,
        inclusive: f.inclusive,
        message: f.message
      }), u.dirty()) : f.kind === "multipleOf" ? n.data % f.value !== BigInt(0) && (o = this._getOrReturnCtx(n, o), Je(o, {
        code: Ne.not_multiple_of,
        multipleOf: f.value,
        message: f.message
      }), u.dirty()) : Sn.assertNever(f);
    return { status: u.value, value: n.data };
  }
  gte(n, i) {
    return this.setLimit("min", n, !0, St.toString(i));
  }
  gt(n, i) {
    return this.setLimit("min", n, !1, St.toString(i));
  }
  lte(n, i) {
    return this.setLimit("max", n, !0, St.toString(i));
  }
  lt(n, i) {
    return this.setLimit("max", n, !1, St.toString(i));
  }
  setLimit(n, i, o, u) {
    return new Ac({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: n,
          value: i,
          inclusive: o,
          message: St.toString(u)
        }
      ]
    });
  }
  _addCheck(n) {
    return new Ac({
      ...this._def,
      checks: [...this._def.checks, n]
    });
  }
  positive(n) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: St.toString(n)
    });
  }
  negative(n) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: St.toString(n)
    });
  }
  nonpositive(n) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: St.toString(n)
    });
  }
  nonnegative(n) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: St.toString(n)
    });
  }
  multipleOf(n, i) {
    return this._addCheck({
      kind: "multipleOf",
      value: n,
      message: St.toString(i)
    });
  }
  get minValue() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "min" && (n === null || i.value > n) && (n = i.value);
    return n;
  }
  get maxValue() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "max" && (n === null || i.value < n) && (n = i.value);
    return n;
  }
}
Ac.create = (t) => {
  var n;
  return new Ac({
    checks: [],
    typeName: Me.ZodBigInt,
    coerce: (n = t == null ? void 0 : t.coerce) !== null && n !== void 0 ? n : !1,
    ...jt(t)
  });
};
class ry extends Yt {
  _parse(n) {
    if (this._def.coerce && (n.data = !!n.data), this._getType(n) !== Qe.boolean) {
      const o = this._getOrReturnCtx(n);
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.boolean,
        received: o.parsedType
      }), $t;
    }
    return da(n.data);
  }
}
ry.create = (t) => new ry({
  typeName: Me.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...jt(t)
});
class Gf extends Yt {
  _parse(n) {
    if (this._def.coerce && (n.data = new Date(n.data)), this._getType(n) !== Qe.date) {
      const f = this._getOrReturnCtx(n);
      return Je(f, {
        code: Ne.invalid_type,
        expected: Qe.date,
        received: f.parsedType
      }), $t;
    }
    if (isNaN(n.data.getTime())) {
      const f = this._getOrReturnCtx(n);
      return Je(f, {
        code: Ne.invalid_date
      }), $t;
    }
    const o = new Zi();
    let u;
    for (const f of this._def.checks)
      f.kind === "min" ? n.data.getTime() < f.value && (u = this._getOrReturnCtx(n, u), Je(u, {
        code: Ne.too_small,
        message: f.message,
        inclusive: !0,
        exact: !1,
        minimum: f.value,
        type: "date"
      }), o.dirty()) : f.kind === "max" ? n.data.getTime() > f.value && (u = this._getOrReturnCtx(n, u), Je(u, {
        code: Ne.too_big,
        message: f.message,
        inclusive: !0,
        exact: !1,
        maximum: f.value,
        type: "date"
      }), o.dirty()) : Sn.assertNever(f);
    return {
      status: o.value,
      value: new Date(n.data.getTime())
    };
  }
  _addCheck(n) {
    return new Gf({
      ...this._def,
      checks: [...this._def.checks, n]
    });
  }
  min(n, i) {
    return this._addCheck({
      kind: "min",
      value: n.getTime(),
      message: St.toString(i)
    });
  }
  max(n, i) {
    return this._addCheck({
      kind: "max",
      value: n.getTime(),
      message: St.toString(i)
    });
  }
  get minDate() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "min" && (n === null || i.value > n) && (n = i.value);
    return n != null ? new Date(n) : null;
  }
  get maxDate() {
    let n = null;
    for (const i of this._def.checks)
      i.kind === "max" && (n === null || i.value < n) && (n = i.value);
    return n != null ? new Date(n) : null;
  }
}
Gf.create = (t) => new Gf({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: Me.ZodDate,
  ...jt(t)
});
class SS extends Yt {
  _parse(n) {
    if (this._getType(n) !== Qe.symbol) {
      const o = this._getOrReturnCtx(n);
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.symbol,
        received: o.parsedType
      }), $t;
    }
    return da(n.data);
  }
}
SS.create = (t) => new SS({
  typeName: Me.ZodSymbol,
  ...jt(t)
});
class iy extends Yt {
  _parse(n) {
    if (this._getType(n) !== Qe.undefined) {
      const o = this._getOrReturnCtx(n);
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.undefined,
        received: o.parsedType
      }), $t;
    }
    return da(n.data);
  }
}
iy.create = (t) => new iy({
  typeName: Me.ZodUndefined,
  ...jt(t)
});
class ay extends Yt {
  _parse(n) {
    if (this._getType(n) !== Qe.null) {
      const o = this._getOrReturnCtx(n);
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.null,
        received: o.parsedType
      }), $t;
    }
    return da(n.data);
  }
}
ay.create = (t) => new ay({
  typeName: Me.ZodNull,
  ...jt(t)
});
class ch extends Yt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(n) {
    return da(n.data);
  }
}
ch.create = (t) => new ch({
  typeName: Me.ZodAny,
  ...jt(t)
});
class Yf extends Yt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(n) {
    return da(n.data);
  }
}
Yf.create = (t) => new Yf({
  typeName: Me.ZodUnknown,
  ...jt(t)
});
class du extends Yt {
  _parse(n) {
    const i = this._getOrReturnCtx(n);
    return Je(i, {
      code: Ne.invalid_type,
      expected: Qe.never,
      received: i.parsedType
    }), $t;
  }
}
du.create = (t) => new du({
  typeName: Me.ZodNever,
  ...jt(t)
});
class xS extends Yt {
  _parse(n) {
    if (this._getType(n) !== Qe.undefined) {
      const o = this._getOrReturnCtx(n);
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.void,
        received: o.parsedType
      }), $t;
    }
    return da(n.data);
  }
}
xS.create = (t) => new xS({
  typeName: Me.ZodVoid,
  ...jt(t)
});
class fl extends Yt {
  _parse(n) {
    const { ctx: i, status: o } = this._processInputParams(n), u = this._def;
    if (i.parsedType !== Qe.array)
      return Je(i, {
        code: Ne.invalid_type,
        expected: Qe.array,
        received: i.parsedType
      }), $t;
    if (u.exactLength !== null) {
      const p = i.data.length > u.exactLength.value, v = i.data.length < u.exactLength.value;
      (p || v) && (Je(i, {
        code: p ? Ne.too_big : Ne.too_small,
        minimum: v ? u.exactLength.value : void 0,
        maximum: p ? u.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: u.exactLength.message
      }), o.dirty());
    }
    if (u.minLength !== null && i.data.length < u.minLength.value && (Je(i, {
      code: Ne.too_small,
      minimum: u.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: u.minLength.message
    }), o.dirty()), u.maxLength !== null && i.data.length > u.maxLength.value && (Je(i, {
      code: Ne.too_big,
      maximum: u.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: u.maxLength.message
    }), o.dirty()), i.common.async)
      return Promise.all([...i.data].map((p, v) => u.type._parseAsync(new ds(i, p, i.path, v)))).then((p) => Zi.mergeArray(o, p));
    const f = [...i.data].map((p, v) => u.type._parseSync(new ds(i, p, i.path, v)));
    return Zi.mergeArray(o, f);
  }
  get element() {
    return this._def.type;
  }
  min(n, i) {
    return new fl({
      ...this._def,
      minLength: { value: n, message: St.toString(i) }
    });
  }
  max(n, i) {
    return new fl({
      ...this._def,
      maxLength: { value: n, message: St.toString(i) }
    });
  }
  length(n, i) {
    return new fl({
      ...this._def,
      exactLength: { value: n, message: St.toString(i) }
    });
  }
  nonempty(n) {
    return this.min(1, n);
  }
}
fl.create = (t, n) => new fl({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Me.ZodArray,
  ...jt(n)
});
function qp(t) {
  if (t instanceof pr) {
    const n = {};
    for (const i in t.shape) {
      const o = t.shape[i];
      n[i] = fu.create(qp(o));
    }
    return new pr({
      ...t._def,
      shape: () => n
    });
  } else
    return t instanceof fl ? new fl({
      ...t._def,
      type: qp(t.element)
    }) : t instanceof fu ? fu.create(qp(t.unwrap())) : t instanceof Qf ? Qf.create(qp(t.unwrap())) : t instanceof ps ? ps.create(t.items.map((n) => qp(n))) : t;
}
class pr extends Yt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const n = this._def.shape(), i = Sn.objectKeys(n);
    return this._cached = { shape: n, keys: i };
  }
  _parse(n) {
    if (this._getType(n) !== Qe.object) {
      const S = this._getOrReturnCtx(n);
      return Je(S, {
        code: Ne.invalid_type,
        expected: Qe.object,
        received: S.parsedType
      }), $t;
    }
    const { status: o, ctx: u } = this._processInputParams(n), { shape: f, keys: p } = this._getCached(), v = [];
    if (!(this._def.catchall instanceof du && this._def.unknownKeys === "strip"))
      for (const S in u.data)
        p.includes(S) || v.push(S);
    const b = [];
    for (const S of p) {
      const E = f[S], w = u.data[S];
      b.push({
        key: { status: "valid", value: S },
        value: E._parse(new ds(u, w, u.path, S)),
        alwaysSet: S in u.data
      });
    }
    if (this._def.catchall instanceof du) {
      const S = this._def.unknownKeys;
      if (S === "passthrough")
        for (const E of v)
          b.push({
            key: { status: "valid", value: E },
            value: { status: "valid", value: u.data[E] }
          });
      else if (S === "strict")
        v.length > 0 && (Je(u, {
          code: Ne.unrecognized_keys,
          keys: v
        }), o.dirty());
      else if (S !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const S = this._def.catchall;
      for (const E of v) {
        const w = u.data[E];
        b.push({
          key: { status: "valid", value: E },
          value: S._parse(
            new ds(u, w, u.path, E)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: E in u.data
        });
      }
    }
    return u.common.async ? Promise.resolve().then(async () => {
      const S = [];
      for (const E of b) {
        const w = await E.key;
        S.push({
          key: w,
          value: await E.value,
          alwaysSet: E.alwaysSet
        });
      }
      return S;
    }).then((S) => Zi.mergeObjectSync(o, S)) : Zi.mergeObjectSync(o, b);
  }
  get shape() {
    return this._def.shape();
  }
  strict(n) {
    return St.errToObj, new pr({
      ...this._def,
      unknownKeys: "strict",
      ...n !== void 0 ? {
        errorMap: (i, o) => {
          var u, f, p, v;
          const b = (p = (f = (u = this._def).errorMap) === null || f === void 0 ? void 0 : f.call(u, i, o).message) !== null && p !== void 0 ? p : o.defaultError;
          return i.code === "unrecognized_keys" ? {
            message: (v = St.errToObj(n).message) !== null && v !== void 0 ? v : b
          } : {
            message: b
          };
        }
      } : {}
    });
  }
  strip() {
    return new pr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new pr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(n) {
    return new pr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...n
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(n) {
    return new pr({
      unknownKeys: n._def.unknownKeys,
      catchall: n._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...n._def.shape()
      }),
      typeName: Me.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(n, i) {
    return this.augment({ [n]: i });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(n) {
    return new pr({
      ...this._def,
      catchall: n
    });
  }
  pick(n) {
    const i = {};
    return Sn.objectKeys(n).forEach((o) => {
      n[o] && this.shape[o] && (i[o] = this.shape[o]);
    }), new pr({
      ...this._def,
      shape: () => i
    });
  }
  omit(n) {
    const i = {};
    return Sn.objectKeys(this.shape).forEach((o) => {
      n[o] || (i[o] = this.shape[o]);
    }), new pr({
      ...this._def,
      shape: () => i
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return qp(this);
  }
  partial(n) {
    const i = {};
    return Sn.objectKeys(this.shape).forEach((o) => {
      const u = this.shape[o];
      n && !n[o] ? i[o] = u : i[o] = u.optional();
    }), new pr({
      ...this._def,
      shape: () => i
    });
  }
  required(n) {
    const i = {};
    return Sn.objectKeys(this.shape).forEach((o) => {
      if (n && !n[o])
        i[o] = this.shape[o];
      else {
        let f = this.shape[o];
        for (; f instanceof fu; )
          f = f._def.innerType;
        i[o] = f;
      }
    }), new pr({
      ...this._def,
      shape: () => i
    });
  }
  keyof() {
    return g3(Sn.objectKeys(this.shape));
  }
}
pr.create = (t, n) => new pr({
  shape: () => t,
  unknownKeys: "strip",
  catchall: du.create(),
  typeName: Me.ZodObject,
  ...jt(n)
});
pr.strictCreate = (t, n) => new pr({
  shape: () => t,
  unknownKeys: "strict",
  catchall: du.create(),
  typeName: Me.ZodObject,
  ...jt(n)
});
pr.lazycreate = (t, n) => new pr({
  shape: t,
  unknownKeys: "strip",
  catchall: du.create(),
  typeName: Me.ZodObject,
  ...jt(n)
});
class oy extends Yt {
  _parse(n) {
    const { ctx: i } = this._processInputParams(n), o = this._def.options;
    function u(f) {
      for (const v of f)
        if (v.result.status === "valid")
          return v.result;
      for (const v of f)
        if (v.result.status === "dirty")
          return i.common.issues.push(...v.ctx.common.issues), v.result;
      const p = f.map((v) => new cl(v.ctx.common.issues));
      return Je(i, {
        code: Ne.invalid_union,
        unionErrors: p
      }), $t;
    }
    if (i.common.async)
      return Promise.all(o.map(async (f) => {
        const p = {
          ...i,
          common: {
            ...i.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await f._parseAsync({
            data: i.data,
            path: i.path,
            parent: p
          }),
          ctx: p
        };
      })).then(u);
    {
      let f;
      const p = [];
      for (const b of o) {
        const S = {
          ...i,
          common: {
            ...i.common,
            issues: []
          },
          parent: null
        }, E = b._parseSync({
          data: i.data,
          path: i.path,
          parent: S
        });
        if (E.status === "valid")
          return E;
        E.status === "dirty" && !f && (f = { result: E, ctx: S }), S.common.issues.length && p.push(S.common.issues);
      }
      if (f)
        return i.common.issues.push(...f.ctx.common.issues), f.result;
      const v = p.map((b) => new cl(b));
      return Je(i, {
        code: Ne.invalid_union,
        unionErrors: v
      }), $t;
    }
  }
  get options() {
    return this._def.options;
  }
}
oy.create = (t, n) => new oy({
  options: t,
  typeName: Me.ZodUnion,
  ...jt(n)
});
const Fb = (t) => t instanceof uy ? Fb(t.schema) : t instanceof dl ? Fb(t.innerType()) : t instanceof cy ? [t.value] : t instanceof Dc ? t.options : t instanceof fy ? Object.keys(t.enum) : t instanceof dy ? Fb(t._def.innerType) : t instanceof iy ? [void 0] : t instanceof ay ? [null] : null;
class FS extends Yt {
  _parse(n) {
    const { ctx: i } = this._processInputParams(n);
    if (i.parsedType !== Qe.object)
      return Je(i, {
        code: Ne.invalid_type,
        expected: Qe.object,
        received: i.parsedType
      }), $t;
    const o = this.discriminator, u = i.data[o], f = this.optionsMap.get(u);
    return f ? i.common.async ? f._parseAsync({
      data: i.data,
      path: i.path,
      parent: i
    }) : f._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }) : (Je(i, {
      code: Ne.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [o]
    }), $t);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(n, i, o) {
    const u = /* @__PURE__ */ new Map();
    for (const f of i) {
      const p = Fb(f.shape[n]);
      if (!p)
        throw new Error(`A discriminator value for key \`${n}\` could not be extracted from all schema options`);
      for (const v of p) {
        if (u.has(v))
          throw new Error(`Discriminator property ${String(n)} has duplicate value ${String(v)}`);
        u.set(v, f);
      }
    }
    return new FS({
      typeName: Me.ZodDiscriminatedUnion,
      discriminator: n,
      options: i,
      optionsMap: u,
      ...jt(o)
    });
  }
}
function AE(t, n) {
  const i = kc(t), o = kc(n);
  if (t === n)
    return { valid: !0, data: t };
  if (i === Qe.object && o === Qe.object) {
    const u = Sn.objectKeys(n), f = Sn.objectKeys(t).filter((v) => u.indexOf(v) !== -1), p = { ...t, ...n };
    for (const v of f) {
      const b = AE(t[v], n[v]);
      if (!b.valid)
        return { valid: !1 };
      p[v] = b.data;
    }
    return { valid: !0, data: p };
  } else if (i === Qe.array && o === Qe.array) {
    if (t.length !== n.length)
      return { valid: !1 };
    const u = [];
    for (let f = 0; f < t.length; f++) {
      const p = t[f], v = n[f], b = AE(p, v);
      if (!b.valid)
        return { valid: !1 };
      u.push(b.data);
    }
    return { valid: !0, data: u };
  } else
    return i === Qe.date && o === Qe.date && +t == +n ? { valid: !0, data: t } : { valid: !1 };
}
class ly extends Yt {
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n), u = (f, p) => {
      if (RE(f) || RE(p))
        return $t;
      const v = AE(f.value, p.value);
      return v.valid ? ((OE(f) || OE(p)) && i.dirty(), { status: i.value, value: v.data }) : (Je(o, {
        code: Ne.invalid_intersection_types
      }), $t);
    };
    return o.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: o.data,
        path: o.path,
        parent: o
      }),
      this._def.right._parseAsync({
        data: o.data,
        path: o.path,
        parent: o
      })
    ]).then(([f, p]) => u(f, p)) : u(this._def.left._parseSync({
      data: o.data,
      path: o.path,
      parent: o
    }), this._def.right._parseSync({
      data: o.data,
      path: o.path,
      parent: o
    }));
  }
}
ly.create = (t, n, i) => new ly({
  left: t,
  right: n,
  typeName: Me.ZodIntersection,
  ...jt(i)
});
class ps extends Yt {
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n);
    if (o.parsedType !== Qe.array)
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.array,
        received: o.parsedType
      }), $t;
    if (o.data.length < this._def.items.length)
      return Je(o, {
        code: Ne.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), $t;
    !this._def.rest && o.data.length > this._def.items.length && (Je(o, {
      code: Ne.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), i.dirty());
    const f = [...o.data].map((p, v) => {
      const b = this._def.items[v] || this._def.rest;
      return b ? b._parse(new ds(o, p, o.path, v)) : null;
    }).filter((p) => !!p);
    return o.common.async ? Promise.all(f).then((p) => Zi.mergeArray(i, p)) : Zi.mergeArray(i, f);
  }
  get items() {
    return this._def.items;
  }
  rest(n) {
    return new ps({
      ...this._def,
      rest: n
    });
  }
}
ps.create = (t, n) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ps({
    items: t,
    typeName: Me.ZodTuple,
    rest: null,
    ...jt(n)
  });
};
class sy extends Yt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n);
    if (o.parsedType !== Qe.object)
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.object,
        received: o.parsedType
      }), $t;
    const u = [], f = this._def.keyType, p = this._def.valueType;
    for (const v in o.data)
      u.push({
        key: f._parse(new ds(o, v, o.path, v)),
        value: p._parse(new ds(o, o.data[v], o.path, v))
      });
    return o.common.async ? Zi.mergeObjectAsync(i, u) : Zi.mergeObjectSync(i, u);
  }
  get element() {
    return this._def.valueType;
  }
  static create(n, i, o) {
    return i instanceof Yt ? new sy({
      keyType: n,
      valueType: i,
      typeName: Me.ZodRecord,
      ...jt(o)
    }) : new sy({
      keyType: ul.create(),
      valueType: n,
      typeName: Me.ZodRecord,
      ...jt(i)
    });
  }
}
class wS extends Yt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n);
    if (o.parsedType !== Qe.map)
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.map,
        received: o.parsedType
      }), $t;
    const u = this._def.keyType, f = this._def.valueType, p = [...o.data.entries()].map(([v, b], S) => ({
      key: u._parse(new ds(o, v, o.path, [S, "key"])),
      value: f._parse(new ds(o, b, o.path, [S, "value"]))
    }));
    if (o.common.async) {
      const v = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const b of p) {
          const S = await b.key, E = await b.value;
          if (S.status === "aborted" || E.status === "aborted")
            return $t;
          (S.status === "dirty" || E.status === "dirty") && i.dirty(), v.set(S.value, E.value);
        }
        return { status: i.value, value: v };
      });
    } else {
      const v = /* @__PURE__ */ new Map();
      for (const b of p) {
        const S = b.key, E = b.value;
        if (S.status === "aborted" || E.status === "aborted")
          return $t;
        (S.status === "dirty" || E.status === "dirty") && i.dirty(), v.set(S.value, E.value);
      }
      return { status: i.value, value: v };
    }
  }
}
wS.create = (t, n, i) => new wS({
  valueType: n,
  keyType: t,
  typeName: Me.ZodMap,
  ...jt(i)
});
class Xf extends Yt {
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n);
    if (o.parsedType !== Qe.set)
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.set,
        received: o.parsedType
      }), $t;
    const u = this._def;
    u.minSize !== null && o.data.size < u.minSize.value && (Je(o, {
      code: Ne.too_small,
      minimum: u.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: u.minSize.message
    }), i.dirty()), u.maxSize !== null && o.data.size > u.maxSize.value && (Je(o, {
      code: Ne.too_big,
      maximum: u.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: u.maxSize.message
    }), i.dirty());
    const f = this._def.valueType;
    function p(b) {
      const S = /* @__PURE__ */ new Set();
      for (const E of b) {
        if (E.status === "aborted")
          return $t;
        E.status === "dirty" && i.dirty(), S.add(E.value);
      }
      return { status: i.value, value: S };
    }
    const v = [...o.data.values()].map((b, S) => f._parse(new ds(o, b, o.path, S)));
    return o.common.async ? Promise.all(v).then((b) => p(b)) : p(v);
  }
  min(n, i) {
    return new Xf({
      ...this._def,
      minSize: { value: n, message: St.toString(i) }
    });
  }
  max(n, i) {
    return new Xf({
      ...this._def,
      maxSize: { value: n, message: St.toString(i) }
    });
  }
  size(n, i) {
    return this.min(n, i).max(n, i);
  }
  nonempty(n) {
    return this.min(1, n);
  }
}
Xf.create = (t, n) => new Xf({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: Me.ZodSet,
  ...jt(n)
});
class rh extends Yt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(n) {
    const { ctx: i } = this._processInputParams(n);
    if (i.parsedType !== Qe.function)
      return Je(i, {
        code: Ne.invalid_type,
        expected: Qe.function,
        received: i.parsedType
      }), $t;
    function o(v, b) {
      return gS({
        data: v,
        path: i.path,
        errorMaps: [
          i.common.contextualErrorMap,
          i.schemaErrorMap,
          yS(),
          ty
        ].filter((S) => !!S),
        issueData: {
          code: Ne.invalid_arguments,
          argumentsError: b
        }
      });
    }
    function u(v, b) {
      return gS({
        data: v,
        path: i.path,
        errorMaps: [
          i.common.contextualErrorMap,
          i.schemaErrorMap,
          yS(),
          ty
        ].filter((S) => !!S),
        issueData: {
          code: Ne.invalid_return_type,
          returnTypeError: b
        }
      });
    }
    const f = { errorMap: i.common.contextualErrorMap }, p = i.data;
    if (this._def.returns instanceof fh) {
      const v = this;
      return da(async function(...b) {
        const S = new cl([]), E = await v._def.args.parseAsync(b, f).catch((k) => {
          throw S.addIssue(o(b, k)), S;
        }), w = await Reflect.apply(p, this, E);
        return await v._def.returns._def.type.parseAsync(w, f).catch((k) => {
          throw S.addIssue(u(w, k)), S;
        });
      });
    } else {
      const v = this;
      return da(function(...b) {
        const S = v._def.args.safeParse(b, f);
        if (!S.success)
          throw new cl([o(b, S.error)]);
        const E = Reflect.apply(p, this, S.data), w = v._def.returns.safeParse(E, f);
        if (!w.success)
          throw new cl([u(E, w.error)]);
        return w.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...n) {
    return new rh({
      ...this._def,
      args: ps.create(n).rest(Yf.create())
    });
  }
  returns(n) {
    return new rh({
      ...this._def,
      returns: n
    });
  }
  implement(n) {
    return this.parse(n);
  }
  strictImplement(n) {
    return this.parse(n);
  }
  static create(n, i, o) {
    return new rh({
      args: n || ps.create([]).rest(Yf.create()),
      returns: i || Yf.create(),
      typeName: Me.ZodFunction,
      ...jt(o)
    });
  }
}
class uy extends Yt {
  get schema() {
    return this._def.getter();
  }
  _parse(n) {
    const { ctx: i } = this._processInputParams(n);
    return this._def.getter()._parse({ data: i.data, path: i.path, parent: i });
  }
}
uy.create = (t, n) => new uy({
  getter: t,
  typeName: Me.ZodLazy,
  ...jt(n)
});
class cy extends Yt {
  _parse(n) {
    if (n.data !== this._def.value) {
      const i = this._getOrReturnCtx(n);
      return Je(i, {
        received: i.data,
        code: Ne.invalid_literal,
        expected: this._def.value
      }), $t;
    }
    return { status: "valid", value: n.data };
  }
  get value() {
    return this._def.value;
  }
}
cy.create = (t, n) => new cy({
  value: t,
  typeName: Me.ZodLiteral,
  ...jt(n)
});
function g3(t, n) {
  return new Dc({
    values: t,
    typeName: Me.ZodEnum,
    ...jt(n)
  });
}
class Dc extends Yt {
  _parse(n) {
    if (typeof n.data != "string") {
      const i = this._getOrReturnCtx(n), o = this._def.values;
      return Je(i, {
        expected: Sn.joinValues(o),
        received: i.parsedType,
        code: Ne.invalid_type
      }), $t;
    }
    if (this._def.values.indexOf(n.data) === -1) {
      const i = this._getOrReturnCtx(n), o = this._def.values;
      return Je(i, {
        received: i.data,
        code: Ne.invalid_enum_value,
        options: o
      }), $t;
    }
    return da(n.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const n = {};
    for (const i of this._def.values)
      n[i] = i;
    return n;
  }
  get Values() {
    const n = {};
    for (const i of this._def.values)
      n[i] = i;
    return n;
  }
  get Enum() {
    const n = {};
    for (const i of this._def.values)
      n[i] = i;
    return n;
  }
  extract(n) {
    return Dc.create(n);
  }
  exclude(n) {
    return Dc.create(this.options.filter((i) => !n.includes(i)));
  }
}
Dc.create = g3;
class fy extends Yt {
  _parse(n) {
    const i = Sn.getValidEnumValues(this._def.values), o = this._getOrReturnCtx(n);
    if (o.parsedType !== Qe.string && o.parsedType !== Qe.number) {
      const u = Sn.objectValues(i);
      return Je(o, {
        expected: Sn.joinValues(u),
        received: o.parsedType,
        code: Ne.invalid_type
      }), $t;
    }
    if (i.indexOf(n.data) === -1) {
      const u = Sn.objectValues(i);
      return Je(o, {
        received: o.data,
        code: Ne.invalid_enum_value,
        options: u
      }), $t;
    }
    return da(n.data);
  }
  get enum() {
    return this._def.values;
  }
}
fy.create = (t, n) => new fy({
  values: t,
  typeName: Me.ZodNativeEnum,
  ...jt(n)
});
class fh extends Yt {
  unwrap() {
    return this._def.type;
  }
  _parse(n) {
    const { ctx: i } = this._processInputParams(n);
    if (i.parsedType !== Qe.promise && i.common.async === !1)
      return Je(i, {
        code: Ne.invalid_type,
        expected: Qe.promise,
        received: i.parsedType
      }), $t;
    const o = i.parsedType === Qe.promise ? i.data : Promise.resolve(i.data);
    return da(o.then((u) => this._def.type.parseAsync(u, {
      path: i.path,
      errorMap: i.common.contextualErrorMap
    })));
  }
}
fh.create = (t, n) => new fh({
  type: t,
  typeName: Me.ZodPromise,
  ...jt(n)
});
class dl extends Yt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Me.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n), u = this._def.effect || null, f = {
      addIssue: (p) => {
        Je(o, p), p.fatal ? i.abort() : i.dirty();
      },
      get path() {
        return o.path;
      }
    };
    if (f.addIssue = f.addIssue.bind(f), u.type === "preprocess") {
      const p = u.transform(o.data, f);
      return o.common.issues.length ? {
        status: "dirty",
        value: o.data
      } : o.common.async ? Promise.resolve(p).then((v) => this._def.schema._parseAsync({
        data: v,
        path: o.path,
        parent: o
      })) : this._def.schema._parseSync({
        data: p,
        path: o.path,
        parent: o
      });
    }
    if (u.type === "refinement") {
      const p = (v) => {
        const b = u.refinement(v, f);
        if (o.common.async)
          return Promise.resolve(b);
        if (b instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return v;
      };
      if (o.common.async === !1) {
        const v = this._def.schema._parseSync({
          data: o.data,
          path: o.path,
          parent: o
        });
        return v.status === "aborted" ? $t : (v.status === "dirty" && i.dirty(), p(v.value), { status: i.value, value: v.value });
      } else
        return this._def.schema._parseAsync({ data: o.data, path: o.path, parent: o }).then((v) => v.status === "aborted" ? $t : (v.status === "dirty" && i.dirty(), p(v.value).then(() => ({ status: i.value, value: v.value }))));
    }
    if (u.type === "transform")
      if (o.common.async === !1) {
        const p = this._def.schema._parseSync({
          data: o.data,
          path: o.path,
          parent: o
        });
        if (!ny(p))
          return p;
        const v = u.transform(p.value, f);
        if (v instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: i.value, value: v };
      } else
        return this._def.schema._parseAsync({ data: o.data, path: o.path, parent: o }).then((p) => ny(p) ? Promise.resolve(u.transform(p.value, f)).then((v) => ({ status: i.value, value: v })) : p);
    Sn.assertNever(u);
  }
}
dl.create = (t, n, i) => new dl({
  schema: t,
  typeName: Me.ZodEffects,
  effect: n,
  ...jt(i)
});
dl.createWithPreprocess = (t, n, i) => new dl({
  schema: n,
  effect: { type: "preprocess", transform: t },
  typeName: Me.ZodEffects,
  ...jt(i)
});
class fu extends Yt {
  _parse(n) {
    return this._getType(n) === Qe.undefined ? da(void 0) : this._def.innerType._parse(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
fu.create = (t, n) => new fu({
  innerType: t,
  typeName: Me.ZodOptional,
  ...jt(n)
});
class Qf extends Yt {
  _parse(n) {
    return this._getType(n) === Qe.null ? da(null) : this._def.innerType._parse(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Qf.create = (t, n) => new Qf({
  innerType: t,
  typeName: Me.ZodNullable,
  ...jt(n)
});
class dy extends Yt {
  _parse(n) {
    const { ctx: i } = this._processInputParams(n);
    let o = i.data;
    return i.parsedType === Qe.undefined && (o = this._def.defaultValue()), this._def.innerType._parse({
      data: o,
      path: i.path,
      parent: i
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
dy.create = (t, n) => new dy({
  innerType: t,
  typeName: Me.ZodDefault,
  defaultValue: typeof n.default == "function" ? n.default : () => n.default,
  ...jt(n)
});
class _S extends Yt {
  _parse(n) {
    const { ctx: i } = this._processInputParams(n), o = {
      ...i,
      common: {
        ...i.common,
        issues: []
      }
    }, u = this._def.innerType._parse({
      data: o.data,
      path: o.path,
      parent: {
        ...o
      }
    });
    return bS(u) ? u.then((f) => ({
      status: "valid",
      value: f.status === "valid" ? f.value : this._def.catchValue({
        get error() {
          return new cl(o.common.issues);
        },
        input: o.data
      })
    })) : {
      status: "valid",
      value: u.status === "valid" ? u.value : this._def.catchValue({
        get error() {
          return new cl(o.common.issues);
        },
        input: o.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
_S.create = (t, n) => new _S({
  innerType: t,
  typeName: Me.ZodCatch,
  catchValue: typeof n.catch == "function" ? n.catch : () => n.catch,
  ...jt(n)
});
class ES extends Yt {
  _parse(n) {
    if (this._getType(n) !== Qe.nan) {
      const o = this._getOrReturnCtx(n);
      return Je(o, {
        code: Ne.invalid_type,
        expected: Qe.nan,
        received: o.parsedType
      }), $t;
    }
    return { status: "valid", value: n.data };
  }
}
ES.create = (t) => new ES({
  typeName: Me.ZodNaN,
  ...jt(t)
});
const pI = Symbol("zod_brand");
class b3 extends Yt {
  _parse(n) {
    const { ctx: i } = this._processInputParams(n), o = i.data;
    return this._def.type._parse({
      data: o,
      path: i.path,
      parent: i
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class vy extends Yt {
  _parse(n) {
    const { status: i, ctx: o } = this._processInputParams(n);
    if (o.common.async)
      return (async () => {
        const f = await this._def.in._parseAsync({
          data: o.data,
          path: o.path,
          parent: o
        });
        return f.status === "aborted" ? $t : f.status === "dirty" ? (i.dirty(), y3(f.value)) : this._def.out._parseAsync({
          data: f.value,
          path: o.path,
          parent: o
        });
      })();
    {
      const u = this._def.in._parseSync({
        data: o.data,
        path: o.path,
        parent: o
      });
      return u.status === "aborted" ? $t : u.status === "dirty" ? (i.dirty(), {
        status: "dirty",
        value: u.value
      }) : this._def.out._parseSync({
        data: u.value,
        path: o.path,
        parent: o
      });
    }
  }
  static create(n, i) {
    return new vy({
      in: n,
      out: i,
      typeName: Me.ZodPipeline
    });
  }
}
class CS extends Yt {
  _parse(n) {
    const i = this._def.innerType._parse(n);
    return ny(i) && (i.value = Object.freeze(i.value)), i;
  }
}
CS.create = (t, n) => new CS({
  innerType: t,
  typeName: Me.ZodReadonly,
  ...jt(n)
});
const S3 = (t, n = {}, i) => t ? ch.create().superRefine((o, u) => {
  var f, p;
  if (!t(o)) {
    const v = typeof n == "function" ? n(o) : typeof n == "string" ? { message: n } : n, b = (p = (f = v.fatal) !== null && f !== void 0 ? f : i) !== null && p !== void 0 ? p : !0, S = typeof v == "string" ? { message: v } : v;
    u.addIssue({ code: "custom", ...S, fatal: b });
  }
}) : ch.create(), hI = {
  object: pr.lazycreate
};
var Me;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(Me || (Me = {}));
const mI = (t, n = {
  message: `Input not instance of ${t.name}`
}) => S3((i) => i instanceof t, n), x3 = ul.create, w3 = Oc.create, vI = ES.create, yI = Ac.create, _3 = ry.create, gI = Gf.create, bI = SS.create, SI = iy.create, xI = ay.create, wI = ch.create, _I = Yf.create, EI = du.create, CI = xS.create, kI = fl.create, TI = pr.create, RI = pr.strictCreate, OI = oy.create, AI = FS.create, DI = ly.create, MI = ps.create, NI = sy.create, LI = wS.create, PI = Xf.create, zI = rh.create, $I = uy.create, jI = cy.create, II = Dc.create, FI = fy.create, UI = fh.create, LO = dl.create, BI = fu.create, HI = Qf.create, VI = dl.createWithPreprocess, WI = vy.create, YI = () => x3().optional(), ZI = () => w3().optional(), qI = () => _3().optional(), GI = {
  string: (t) => ul.create({ ...t, coerce: !0 }),
  number: (t) => Oc.create({ ...t, coerce: !0 }),
  boolean: (t) => ry.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => Ac.create({ ...t, coerce: !0 }),
  date: (t) => Gf.create({ ...t, coerce: !0 })
}, XI = $t;
var ki = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ty,
  setErrorMap: eI,
  getErrorMap: yS,
  makeIssue: gS,
  EMPTY_PATH: tI,
  addIssueToContext: Je,
  ParseStatus: Zi,
  INVALID: $t,
  DIRTY: y3,
  OK: da,
  isAborted: RE,
  isDirty: OE,
  isValid: ny,
  isAsync: bS,
  get util() {
    return Sn;
  },
  get objectUtil() {
    return TE;
  },
  ZodParsedType: Qe,
  getParsedType: kc,
  ZodType: Yt,
  ZodString: ul,
  ZodNumber: Oc,
  ZodBigInt: Ac,
  ZodBoolean: ry,
  ZodDate: Gf,
  ZodSymbol: SS,
  ZodUndefined: iy,
  ZodNull: ay,
  ZodAny: ch,
  ZodUnknown: Yf,
  ZodNever: du,
  ZodVoid: xS,
  ZodArray: fl,
  ZodObject: pr,
  ZodUnion: oy,
  ZodDiscriminatedUnion: FS,
  ZodIntersection: ly,
  ZodTuple: ps,
  ZodRecord: sy,
  ZodMap: wS,
  ZodSet: Xf,
  ZodFunction: rh,
  ZodLazy: uy,
  ZodLiteral: cy,
  ZodEnum: Dc,
  ZodNativeEnum: fy,
  ZodPromise: fh,
  ZodEffects: dl,
  ZodTransformer: dl,
  ZodOptional: fu,
  ZodNullable: Qf,
  ZodDefault: dy,
  ZodCatch: _S,
  ZodNaN: ES,
  BRAND: pI,
  ZodBranded: b3,
  ZodPipeline: vy,
  ZodReadonly: CS,
  custom: S3,
  Schema: Yt,
  ZodSchema: Yt,
  late: hI,
  get ZodFirstPartyTypeKind() {
    return Me;
  },
  coerce: GI,
  any: wI,
  array: kI,
  bigint: yI,
  boolean: _3,
  date: gI,
  discriminatedUnion: AI,
  effect: LO,
  enum: II,
  function: zI,
  instanceof: mI,
  intersection: DI,
  lazy: $I,
  literal: jI,
  map: LI,
  nan: vI,
  nativeEnum: FI,
  never: EI,
  null: xI,
  nullable: HI,
  number: w3,
  object: TI,
  oboolean: qI,
  onumber: ZI,
  optional: BI,
  ostring: YI,
  pipeline: WI,
  preprocess: VI,
  promise: UI,
  record: NI,
  set: PI,
  strictObject: RI,
  string: x3,
  symbol: bI,
  transformer: LO,
  tuple: MI,
  undefined: SI,
  union: OI,
  unknown: _I,
  void: CI,
  NEVER: XI,
  ZodIssueCode: Ne,
  quotelessJson: J7,
  ZodError: cl
});
function E3(t, n, i, o) {
  o != null && o.errorMessages && i && (t.errorMessage = {
    ...t.errorMessage,
    [n]: i
  });
}
function Pn(t, n, i, o, u) {
  t[n] = i, E3(t, n, o, u);
}
const QI = Symbol("Let zodToJsonSchema decide on which parser to use"), PO = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  emailStrategy: "format:email"
}, KI = (t) => typeof t == "string" ? {
  ...PO,
  name: t
} : {
  ...PO,
  ...t
};
function JI() {
  return {};
}
function eF(t, n) {
  var o, u;
  const i = {
    type: "array"
  };
  return ((u = (o = t.type) == null ? void 0 : o._def) == null ? void 0 : u.typeName) !== Me.ZodAny && (i.items = xn(t.type._def, {
    ...n,
    currentPath: [...n.currentPath, "items"]
  })), t.minLength && Pn(i, "minItems", t.minLength.value, t.minLength.message, n), t.maxLength && Pn(i, "maxItems", t.maxLength.value, t.maxLength.message, n), t.exactLength && (Pn(i, "minItems", t.exactLength.value, t.exactLength.message, n), Pn(i, "maxItems", t.exactLength.value, t.exactLength.message, n)), i;
}
function tF(t, n) {
  const i = {
    type: "integer",
    format: "int64"
  };
  if (!t.checks)
    return i;
  for (const o of t.checks)
    switch (o.kind) {
      case "min":
        n.target === "jsonSchema7" ? o.inclusive ? Pn(i, "minimum", o.value, o.message, n) : Pn(i, "exclusiveMinimum", o.value, o.message, n) : (o.inclusive || (i.exclusiveMinimum = !0), Pn(i, "minimum", o.value, o.message, n));
        break;
      case "max":
        n.target === "jsonSchema7" ? o.inclusive ? Pn(i, "maximum", o.value, o.message, n) : Pn(i, "exclusiveMaximum", o.value, o.message, n) : (o.inclusive || (i.exclusiveMaximum = !0), Pn(i, "maximum", o.value, o.message, n));
        break;
      case "multipleOf":
        Pn(i, "multipleOf", o.value, o.message, n);
        break;
    }
  return i;
}
function nF() {
  return {
    type: "boolean"
  };
}
function rF(t, n) {
  return xn(t.type._def, n);
}
const iF = (t, n) => xn(t.innerType._def, n);
function C3(t, n, i) {
  const o = i ?? n.dateStrategy;
  if (Array.isArray(o))
    return {
      anyOf: o.map((u, f) => C3(t, n, u))
    };
  switch (o) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return aF(t, n);
  }
}
const aF = (t, n) => {
  const i = {
    type: "integer",
    format: "unix-time"
  };
  if (n.target === "openApi3")
    return i;
  for (const o of t.checks)
    switch (o.kind) {
      case "min":
        Pn(
          i,
          "minimum",
          o.value,
          // This is in milliseconds
          o.message,
          n
        );
        break;
      case "max":
        Pn(
          i,
          "maximum",
          o.value,
          // This is in milliseconds
          o.message,
          n
        );
        break;
    }
  return i;
};
function oF(t, n) {
  return {
    ...xn(t.innerType._def, n),
    default: t.defaultValue()
  };
}
function lF(t, n) {
  return n.effectStrategy === "input" ? xn(t.schema._def, n) : {};
}
function sF(t) {
  return {
    type: "string",
    enum: t.values
  };
}
const uF = (t) => "type" in t && t.type === "string" ? !1 : "allOf" in t;
function cF(t, n) {
  const i = [
    xn(t.left._def, {
      ...n,
      currentPath: [...n.currentPath, "allOf", "0"]
    }),
    xn(t.right._def, {
      ...n,
      currentPath: [...n.currentPath, "allOf", "1"]
    })
  ].filter((f) => !!f);
  let o = n.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const u = [];
  return i.forEach((f) => {
    if (uF(f))
      u.push(...f.allOf), f.unevaluatedProperties === void 0 && (o = void 0);
    else {
      let p = f;
      if ("additionalProperties" in f && f.additionalProperties === !1) {
        const { additionalProperties: v, ...b } = f;
        p = b;
      } else
        o = void 0;
      u.push(p);
    }
  }), u.length ? {
    allOf: u,
    ...o
  } : void 0;
}
function fF(t, n) {
  const i = typeof t.value;
  return i !== "bigint" && i !== "number" && i !== "boolean" && i !== "string" ? {
    type: Array.isArray(t.value) ? "array" : "object"
  } : n.target === "openApi3" ? {
    type: i === "bigint" ? "integer" : i,
    enum: [t.value]
  } : {
    type: i === "bigint" ? "integer" : i,
    const: t.value
  };
}
const Dv = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function k3(t, n) {
  const i = {
    type: "string"
  };
  function o(u) {
    return n.patternStrategy === "escape" ? dF(u) : u;
  }
  if (t.checks)
    for (const u of t.checks)
      switch (u.kind) {
        case "min":
          Pn(i, "minLength", typeof i.minLength == "number" ? Math.max(i.minLength, u.value) : u.value, u.message, n);
          break;
        case "max":
          Pn(i, "maxLength", typeof i.maxLength == "number" ? Math.min(i.maxLength, u.value) : u.value, u.message, n);
          break;
        case "email":
          switch (n.emailStrategy) {
            case "format:email":
              If(i, "email", u.message, n);
              break;
            case "format:idn-email":
              If(i, "idn-email", u.message, n);
              break;
            case "pattern:zod":
              ou(i, Dv.email, u.message, n);
              break;
          }
          break;
        case "url":
          If(i, "uri", u.message, n);
          break;
        case "uuid":
          If(i, "uuid", u.message, n);
          break;
        case "regex":
          ou(i, u.regex.source, u.message, n);
          break;
        case "cuid":
          ou(i, Dv.cuid, u.message, n);
          break;
        case "cuid2":
          ou(i, Dv.cuid2, u.message, n);
          break;
        case "startsWith":
          ou(i, "^" + o(u.value), u.message, n);
          break;
        case "endsWith":
          ou(i, o(u.value) + "$", u.message, n);
          break;
        case "datetime":
          If(i, "date-time", u.message, n);
          break;
        case "length":
          Pn(i, "minLength", typeof i.minLength == "number" ? Math.max(i.minLength, u.value) : u.value, u.message, n), Pn(i, "maxLength", typeof i.maxLength == "number" ? Math.min(i.maxLength, u.value) : u.value, u.message, n);
          break;
        case "includes": {
          ou(i, o(u.value), u.message, n);
          break;
        }
        case "ip": {
          u.version !== "v6" && If(i, "ipv4", u.message, n), u.version !== "v4" && If(i, "ipv6", u.message, n);
          break;
        }
        case "emoji":
          ou(i, Dv.emoji, u.message, n);
          break;
        case "ulid": {
          ou(i, Dv.ulid, u.message, n);
          break;
        }
      }
  return i;
}
const dF = (t) => Array.from(t).map((n) => /[a-zA-Z0-9]/.test(n) ? n : `\\${n}`).join(""), If = (t, n, i, o) => {
  var u;
  t.format || (u = t.anyOf) != null && u.some((f) => f.format) ? (t.anyOf || (t.anyOf = []), t.format && (t.anyOf.push({
    format: t.format,
    ...t.errorMessage && o.errorMessages && {
      errorMessage: { format: t.errorMessage.format }
    }
  }), delete t.format, t.errorMessage && (delete t.errorMessage.format, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.anyOf.push({
    format: n,
    ...i && o.errorMessages && { errorMessage: { format: i } }
  })) : Pn(t, "format", n, i, o);
}, ou = (t, n, i, o) => {
  var u;
  t.pattern || (u = t.allOf) != null && u.some((f) => f.pattern) ? (t.allOf || (t.allOf = []), t.pattern && (t.allOf.push({
    pattern: t.pattern,
    ...t.errorMessage && o.errorMessages && {
      errorMessage: { pattern: t.errorMessage.pattern }
    }
  }), delete t.pattern, t.errorMessage && (delete t.errorMessage.pattern, Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)), t.allOf.push({
    pattern: n,
    ...i && o.errorMessages && { errorMessage: { pattern: i } }
  })) : Pn(t, "pattern", n, i, o);
};
function T3(t, n) {
  var o, u, f, p;
  if (n.target === "openApi3" && ((o = t.keyType) == null ? void 0 : o._def.typeName) === Me.ZodEnum)
    return {
      type: "object",
      required: t.keyType._def.values,
      properties: t.keyType._def.values.reduce((v, b) => ({
        ...v,
        [b]: xn(t.valueType._def, {
          ...n,
          currentPath: [...n.currentPath, "properties", b]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const i = {
    type: "object",
    additionalProperties: xn(t.valueType._def, {
      ...n,
      currentPath: [...n.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (n.target === "openApi3")
    return i;
  if (((u = t.keyType) == null ? void 0 : u._def.typeName) === Me.ZodString && ((f = t.keyType._def.checks) != null && f.length)) {
    const v = Object.entries(k3(t.keyType._def, n)).reduce((b, [S, E]) => S === "type" ? b : { ...b, [S]: E }, {});
    return {
      ...i,
      propertyNames: v
    };
  } else if (((p = t.keyType) == null ? void 0 : p._def.typeName) === Me.ZodEnum)
    return {
      ...i,
      propertyNames: {
        enum: t.keyType._def.values
      }
    };
  return i;
}
function pF(t, n) {
  if (n.mapStrategy === "record")
    return T3(t, n);
  const i = xn(t.keyType._def, {
    ...n,
    currentPath: [...n.currentPath, "items", "items", "0"]
  }) || {}, o = xn(t.valueType._def, {
    ...n,
    currentPath: [...n.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [i, o],
      minItems: 2,
      maxItems: 2
    }
  };
}
function hF(t) {
  const n = t.values, o = Object.keys(t.values).filter((f) => typeof n[n[f]] != "number").map((f) => n[f]), u = Array.from(new Set(o.map((f) => typeof f)));
  return {
    type: u.length === 1 ? u[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: o
  };
}
function mF() {
  return {
    not: {}
  };
}
function vF(t) {
  return t.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const kS = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function yF(t, n) {
  if (n.target === "openApi3")
    return zO(t, n);
  const i = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
  if (i.every((o) => o._def.typeName in kS && (!o._def.checks || !o._def.checks.length))) {
    const o = i.reduce((u, f) => {
      const p = kS[f._def.typeName];
      return p && !u.includes(p) ? [...u, p] : u;
    }, []);
    return {
      type: o.length > 1 ? o : o[0]
    };
  } else if (i.every((o) => o._def.typeName === "ZodLiteral" && !o.description)) {
    const o = i.reduce((u, f) => {
      const p = typeof f._def.value;
      switch (p) {
        case "string":
        case "number":
        case "boolean":
          return [...u, p];
        case "bigint":
          return [...u, "integer"];
        case "object":
          if (f._def.value === null)
            return [...u, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return u;
      }
    }, []);
    if (o.length === i.length) {
      const u = o.filter((f, p, v) => v.indexOf(f) === p);
      return {
        type: u.length > 1 ? u : u[0],
        enum: i.reduce((f, p) => f.includes(p._def.value) ? f : [...f, p._def.value], [])
      };
    }
  } else if (i.every((o) => o._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: i.reduce((o, u) => [
        ...o,
        ...u._def.values.filter((f) => !o.includes(f))
      ], [])
    };
  return zO(t, n);
}
const zO = (t, n) => {
  const i = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map((o, u) => xn(o._def, {
    ...n,
    currentPath: [...n.currentPath, "anyOf", `${u}`]
  })).filter((o) => !!o && (!n.strictUnions || typeof o == "object" && Object.keys(o).length > 0));
  return i.length ? { anyOf: i } : void 0;
};
function gF(t, n) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
    return n.target === "openApi3" ? {
      type: kS[t.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        kS[t.innerType._def.typeName],
        "null"
      ]
    };
  if (n.target === "openApi3") {
    const o = xn(t.innerType._def, {
      ...n,
      currentPath: [...n.currentPath]
    });
    return o && "$ref" in o ? { allOf: [o], nullable: !0 } : o && { ...o, nullable: !0 };
  }
  const i = xn(t.innerType._def, {
    ...n,
    currentPath: [...n.currentPath, "anyOf", "0"]
  });
  return i && { anyOf: [i, { type: "null" }] };
}
function bF(t, n) {
  const i = {
    type: "number"
  };
  if (!t.checks)
    return i;
  for (const o of t.checks)
    switch (o.kind) {
      case "int":
        i.type = "integer", E3(i, "type", o.message, n);
        break;
      case "min":
        n.target === "jsonSchema7" ? o.inclusive ? Pn(i, "minimum", o.value, o.message, n) : Pn(i, "exclusiveMinimum", o.value, o.message, n) : (o.inclusive || (i.exclusiveMinimum = !0), Pn(i, "minimum", o.value, o.message, n));
        break;
      case "max":
        n.target === "jsonSchema7" ? o.inclusive ? Pn(i, "maximum", o.value, o.message, n) : Pn(i, "exclusiveMaximum", o.value, o.message, n) : (o.inclusive || (i.exclusiveMaximum = !0), Pn(i, "maximum", o.value, o.message, n));
        break;
      case "multipleOf":
        Pn(i, "multipleOf", o.value, o.message, n);
        break;
    }
  return i;
}
function SF(t, n) {
  return n.removeAdditionalStrategy === "strict" ? t.catchall._def.typeName === "ZodNever" ? t.unknownKeys !== "strict" : xn(t.catchall._def, {
    ...n,
    currentPath: [...n.currentPath, "additionalProperties"]
  }) ?? !0 : t.catchall._def.typeName === "ZodNever" ? t.unknownKeys === "passthrough" : xn(t.catchall._def, {
    ...n,
    currentPath: [...n.currentPath, "additionalProperties"]
  }) ?? !0;
}
function xF(t, n) {
  const i = {
    type: "object",
    ...Object.entries(t.shape()).reduce((o, [u, f]) => {
      if (f === void 0 || f._def === void 0)
        return o;
      const p = xn(f._def, {
        ...n,
        currentPath: [...n.currentPath, "properties", u],
        propertyPath: [...n.currentPath, "properties", u]
      });
      return p === void 0 ? o : {
        properties: { ...o.properties, [u]: p },
        required: f.isOptional() ? o.required : [...o.required, u]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: SF(t, n)
  };
  return i.required.length || delete i.required, i;
}
const wF = (t, n) => {
  var o;
  if (n.currentPath.toString() === ((o = n.propertyPath) == null ? void 0 : o.toString()))
    return xn(t.innerType._def, n);
  const i = xn(t.innerType._def, {
    ...n,
    currentPath: [...n.currentPath, "anyOf", "1"]
  });
  return i ? {
    anyOf: [
      {
        not: {}
      },
      i
    ]
  } : {};
}, _F = (t, n) => {
  if (n.pipeStrategy === "input")
    return xn(t.in._def, n);
  if (n.pipeStrategy === "output")
    return xn(t.out._def, n);
  const i = xn(t.in._def, {
    ...n,
    currentPath: [...n.currentPath, "allOf", "0"]
  }), o = xn(t.out._def, {
    ...n,
    currentPath: [...n.currentPath, "allOf", i ? "1" : "0"]
  });
  return {
    allOf: [i, o].filter((u) => u !== void 0)
  };
};
function EF(t, n) {
  return xn(t.type._def, n);
}
function CF(t, n) {
  const o = {
    type: "array",
    uniqueItems: !0,
    items: xn(t.valueType._def, {
      ...n,
      currentPath: [...n.currentPath, "items"]
    })
  };
  return t.minSize && Pn(o, "minItems", t.minSize.value, t.minSize.message, n), t.maxSize && Pn(o, "maxItems", t.maxSize.value, t.maxSize.message, n), o;
}
function kF(t, n) {
  return t.rest ? {
    type: "array",
    minItems: t.items.length,
    items: t.items.map((i, o) => xn(i._def, {
      ...n,
      currentPath: [...n.currentPath, "items", `${o}`]
    })).reduce((i, o) => o === void 0 ? i : [...i, o], []),
    additionalItems: xn(t.rest._def, {
      ...n,
      currentPath: [...n.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: t.items.length,
    maxItems: t.items.length,
    items: t.items.map((i, o) => xn(i._def, {
      ...n,
      currentPath: [...n.currentPath, "items", `${o}`]
    })).reduce((i, o) => o === void 0 ? i : [...i, o], [])
  };
}
function TF() {
  return {
    not: {}
  };
}
function RF() {
  return {};
}
const OF = (t, n) => xn(t.innerType._def, n);
function xn(t, n, i = !1) {
  var p;
  const o = n.seen.get(t);
  if (n.override) {
    const v = (p = n.override) == null ? void 0 : p.call(n, t, n, o, i);
    if (v !== QI)
      return v;
  }
  if (o && !i) {
    const v = AF(o, n);
    if (v !== void 0)
      return v;
  }
  const u = { def: t, path: n.currentPath, jsonSchema: void 0 };
  n.seen.set(t, u);
  const f = MF(t, t.typeName, n);
  return f && NF(t, n, f), u.jsonSchema = f, f;
}
const AF = (t, n) => {
  switch (n.$refStrategy) {
    case "root":
      return { $ref: t.path.join("/") };
    case "relative":
      return { $ref: DF(n.currentPath, t.path) };
    case "none":
    case "seen":
      return t.path.length < n.currentPath.length && t.path.every((i, o) => n.currentPath[o] === i) ? (console.warn(`Recursive reference detected at ${n.currentPath.join("/")}! Defaulting to any`), {}) : n.$refStrategy === "seen" ? {} : void 0;
  }
}, DF = (t, n) => {
  let i = 0;
  for (; i < t.length && i < n.length && t[i] === n[i]; i++)
    ;
  return [(t.length - i).toString(), ...n.slice(i)].join("/");
}, MF = (t, n, i) => {
  switch (n) {
    case Me.ZodString:
      return k3(t, i);
    case Me.ZodNumber:
      return bF(t, i);
    case Me.ZodObject:
      return xF(t, i);
    case Me.ZodBigInt:
      return tF(t, i);
    case Me.ZodBoolean:
      return nF();
    case Me.ZodDate:
      return C3(t, i);
    case Me.ZodUndefined:
      return TF();
    case Me.ZodNull:
      return vF(i);
    case Me.ZodArray:
      return eF(t, i);
    case Me.ZodUnion:
    case Me.ZodDiscriminatedUnion:
      return yF(t, i);
    case Me.ZodIntersection:
      return cF(t, i);
    case Me.ZodTuple:
      return kF(t, i);
    case Me.ZodRecord:
      return T3(t, i);
    case Me.ZodLiteral:
      return fF(t, i);
    case Me.ZodEnum:
      return sF(t);
    case Me.ZodNativeEnum:
      return hF(t);
    case Me.ZodNullable:
      return gF(t, i);
    case Me.ZodOptional:
      return wF(t, i);
    case Me.ZodMap:
      return pF(t, i);
    case Me.ZodSet:
      return CF(t, i);
    case Me.ZodLazy:
      return xn(t.getter()._def, i);
    case Me.ZodPromise:
      return EF(t, i);
    case Me.ZodNaN:
    case Me.ZodNever:
      return mF();
    case Me.ZodEffects:
      return lF(t, i);
    case Me.ZodAny:
      return JI();
    case Me.ZodUnknown:
      return RF();
    case Me.ZodDefault:
      return oF(t, i);
    case Me.ZodBranded:
      return rF(t, i);
    case Me.ZodReadonly:
      return OF(t, i);
    case Me.ZodCatch:
      return iF(t, i);
    case Me.ZodPipeline:
      return _F(t, i);
    case Me.ZodFunction:
    case Me.ZodVoid:
    case Me.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((o) => {
      })();
  }
}, NF = (t, n, i) => (t.description && (i.description = t.description, n.markdownDescription && (i.markdownDescription = t.description)), i), LF = (t) => {
  const n = KI(t), i = n.name !== void 0 ? [...n.basePath, n.definitionPath, n.name] : n.basePath;
  return {
    ...n,
    currentPath: i,
    propertyPath: void 0,
    seen: new Map(Object.entries(n.definitions).map(([o, u]) => [
      u._def,
      {
        def: u._def,
        path: [...n.basePath, n.definitionPath, o],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
}, PF = (t, n) => {
  const i = LF(n), o = typeof n == "object" && n.definitions ? Object.entries(n.definitions).reduce((v, [b, S]) => ({
    ...v,
    [b]: xn(S._def, {
      ...i,
      currentPath: [...i.basePath, i.definitionPath, b]
    }, !0) ?? {}
  }), {}) : void 0, u = typeof n == "string" ? n : n == null ? void 0 : n.name, f = xn(t._def, u === void 0 ? i : {
    ...i,
    currentPath: [...i.basePath, i.definitionPath, u]
  }, !1) ?? {}, p = u === void 0 ? o ? {
    ...f,
    [i.definitionPath]: o
  } : f : {
    $ref: [
      ...i.$refStrategy === "relative" ? [] : i.basePath,
      i.definitionPath,
      u
    ].join("/"),
    [i.definitionPath]: {
      ...o,
      [u]: f
    }
  };
  return i.target === "jsonSchema7" ? p.$schema = "http://json-schema.org/draft-07/schema#" : i.target === "jsonSchema2019-09" && (p.$schema = "https://json-schema.org/draft/2019-09/schema#"), p;
};
function Mv(...t) {
  const n = PF(...t);
  return delete n.$schema, n;
}
function zF(t) {
  const n = {
    type: "function",
    function: {
      name: t.name,
      description: t.description,
      parameters: t.fields.reduce(
        (u, f) => {
          var p;
          return u.properties[f.name] = Mv(f.schema), f.required && ((p = u.required) == null || p.push(f.name)), u;
        },
        {
          type: "object",
          properties: {},
          required: [],
          additionalProperties: !1
        }
      )
    }
  }, i = t.fields.reduce((u, f) => {
    var b, S, E;
    if (!((b = f.renderer) != null && b.ui) && !((S = f.renderer) != null && S.headless))
      return u;
    const { description: p } = Mv(f.schema), v = Mv(((E = f.renderer) == null ? void 0 : E.props) || ki.object({}));
    return u.concat({
      type: "function",
      function: {
        name: `get_${f.name}`,
        description: p ? `Get: ${p}` : void 0,
        parameters: v
      }
    });
  }, []), o = (t.tools || []).reduce((u, f) => {
    var b;
    const { description: p } = Mv(f.schema), v = Mv(((b = f.renderer) == null ? void 0 : b.props) || ki.object({}));
    return u.concat({
      type: "function",
      function: {
        name: f.name,
        description: p,
        parameters: v
      }
    });
  }, []);
  return [...i, ...o, n];
}
function $F(t, n) {
  var v, b;
  const {
    id: i,
    function: { name: o, arguments: u }
  } = n, f = ((v = t.tools) == null ? void 0 : v.find((S) => S.name === o)) || t.fields.find((S) => `get_${S.name}` === o);
  return f ? {
    ui: (b = f.renderer) == null ? void 0 : b.ui,
    // TODO: validate
    props: {
      ...JSON.parse(u),
      __field__: f.name
    },
    id: i,
    functionName: o,
    functionArguments: u
  } : null;
}
function $O(t, n) {
  var p;
  const {
    id: i,
    function: { name: o, arguments: u }
  } = n;
  return {
    field: ((p = t.tools) == null ? void 0 : p.find((v) => v.name === o)) || t.fields.find((v) => `get_${v.name}` === o),
    // TODO: validate
    props: {
      ...JSON.parse(u)
    },
    id: i,
    functionName: o,
    functionArguments: u
  };
}
function jF(t) {
  const n = [];
  for (const i in t) {
    const o = t[i];
    n.push(
      {
        role: "assistant",
        tool_calls: [
          {
            id: i,
            type: "function",
            function: {
              name: o.functionName,
              arguments: o.functionArguments
            }
          }
        ]
      },
      {
        role: "tool",
        tool_call_id: i,
        content: JSON.stringify(o.value)
      }
    );
  }
  return n;
}
async function IF(t, n, i) {
  return await ZA(
    [
      {
        role: "system",
        content: `- Always ask users to input information if required argument is not provided
- Do not call functions if required information is not provided
- response in Chinese`
      }
    ].concat(t),
    n,
    "gpt-4-turbo-preview",
    i
  );
}
const FF = {
  userMessages: [],
  fieldMessages: [],
  headlessFieldMessages: [],
  choices: [],
  form: null
}, jO = (t, n) => Y7({
  actors: {
    submitForm: OO(
      ({
        input: i
      }) => {
        const o = i.userMessages.map((u) => ({
          role: "user",
          content: u
        }));
        return IF(
          o.concat(i.fieldMessages).concat(i.headlessFieldMessages),
          i.tools,
          n
        );
      }
    ),
    executeHeadlessTools: OO(
      ({
        input: i
      }) => {
        var u, f, p, v, b;
        const o = [];
        for (const S of i.choices)
          for (const E of S.message.tool_calls || []) {
            const w = $O(i.form, E);
            (f = (u = w.field) == null ? void 0 : u.renderer) != null && f.headless && o.push(
              (b = (v = (p = w.field) == null ? void 0 : p.renderer) == null ? void 0 : v.headless) == null ? void 0 : b.call(v, { props: w.props }).then((R) => [
                {
                  role: "assistant",
                  tool_calls: [
                    {
                      id: w.id,
                      type: "function",
                      function: {
                        name: w.functionName,
                        arguments: w.functionArguments
                      }
                    }
                  ]
                },
                {
                  role: "tool",
                  tool_call_id: w.id,
                  content: JSON.stringify(R)
                }
              ])
            );
          }
        return Promise.all(o).then((S) => S.reduce((E, w) => E.concat(w), []));
      }
    )
  }
}).createMachine({
  context: { ...FF, form: t },
  id: "AI-form",
  initial: "wait_user_input",
  states: {
    wait_user_input: {
      on: {
        add_user_message: {
          target: "call_AI",
          actions: Ib({
            userMessages: ({ context: i, event: o }) => i.userMessages.concat(o.userMessages),
            fieldMessages: ({ event: i }) => i.fieldMessages
          })
        }
      }
    },
    call_AI: {
      on: {
        fetch: {
          target: "loading"
        }
      },
      entry: jb({ type: "fetch" })
    },
    loading: {
      invoke: {
        src: "submitForm",
        input: ({ context: i }) => ({
          userMessages: i.userMessages,
          fieldMessages: i.fieldMessages,
          headlessFieldMessages: i.headlessFieldMessages,
          tools: zF(i.form)
        }),
        onError: "error",
        onDone: {
          target: "check_tool",
          actions: Ib({
            choices: ({ event: i }) => i.output
          })
        }
      }
    },
    error: {},
    check_tool: {
      entry: jb(({ context: i }) => {
        const { form: o, choices: u } = i;
        return u.some((f) => (f.message.tool_calls || []).map(
          (v) => $O(o, v)
        ).some((v) => {
          var b, S;
          return (S = (b = v.field) == null ? void 0 : b.renderer) == null ? void 0 : S.headless;
        })) ? {
          type: "is_headless_tool"
        } : {
          type: "is_ui_tool"
        };
      }),
      on: {
        is_ui_tool: {
          target: "wait_user_input"
        },
        is_headless_tool: {
          target: "call_headless_field"
        }
      }
    },
    call_headless_field: {
      on: {
        execute: {
          target: "headless_field_loading"
        }
      },
      entry: jb({ type: "execute" })
    },
    headless_field_loading: {
      invoke: {
        src: "executeHeadlessTools",
        input: ({ context: i }) => ({
          form: i.form,
          choices: i.choices
        }),
        onError: "headless_field_error",
        onDone: {
          target: "call_AI",
          actions: Ib({
            headlessFieldMessages: ({ event: i }) => i.output
          })
        }
      }
    },
    headless_field_error: {}
  }
}), US = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  "div",
  {
    ref: i,
    className: Kr(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      t
    ),
    ...n
  }
));
US.displayName = "Card";
const UF = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  "div",
  {
    ref: i,
    className: Kr("flex flex-col space-y-1.5 p-6", t),
    ...n
  }
));
UF.displayName = "CardHeader";
const BF = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  "h3",
  {
    ref: i,
    className: Kr(
      "text-2xl font-semibold leading-none tracking-tight",
      t
    ),
    ...n
  }
));
BF.displayName = "CardTitle";
const HF = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  "p",
  {
    ref: i,
    className: Kr("text-sm text-muted-foreground", t),
    ...n
  }
));
HF.displayName = "CardDescription";
const BS = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx("div", { ref: i, className: Kr("p-6 pt-0", t), ...n }));
BS.displayName = "CardContent";
const VF = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  "div",
  {
    ref: i,
    className: Kr("flex items-center p-6 pt-0", t),
    ...n
  }
));
VF.displayName = "CardFooter";
function WF(t) {
  const n = L.useRef({
    value: t,
    previous: t
  });
  return L.useMemo(() => (n.current.value !== t && (n.current.previous = n.current.value, n.current.value = t), n.current.previous), [
    t
  ]);
}
function YF(t) {
  const [n, i] = L.useState(void 0);
  return Gv(() => {
    if (t) {
      i({
        width: t.offsetWidth,
        height: t.offsetHeight
      });
      const o = new ResizeObserver((u) => {
        if (!Array.isArray(u) || !u.length)
          return;
        const f = u[0];
        let p, v;
        if ("borderBoxSize" in f) {
          const b = f.borderBoxSize, S = Array.isArray(b) ? b[0] : b;
          p = S.inlineSize, v = S.blockSize;
        } else
          p = t.offsetWidth, v = t.offsetHeight;
        i({
          width: p,
          height: v
        });
      });
      return o.observe(t, {
        box: "border-box"
      }), () => o.unobserve(t);
    } else
      i(void 0);
  }, [
    t
  ]), n;
}
const R3 = "Switch", [ZF, vV] = FE(R3), [qF, GF] = ZF(R3), XF = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeSwitch: i, name: o, checked: u, defaultChecked: f, required: p, disabled: v, value: b = "on", onCheckedChange: S, ...E } = t, [w, R] = L.useState(null), k = no(
    n,
    (q) => R(q)
  ), N = L.useRef(!1), z = w ? !!w.closest("form") : !0, [I = !1, H] = M4({
    prop: u,
    defaultProp: f,
    onChange: S
  });
  return /* @__PURE__ */ L.createElement(qF, {
    scope: i,
    checked: I,
    disabled: v
  }, /* @__PURE__ */ L.createElement(qi.button, Wt({
    type: "button",
    role: "switch",
    "aria-checked": I,
    "aria-required": p,
    "data-state": O3(I),
    "data-disabled": v ? "" : void 0,
    disabled: v,
    value: b
  }, E, {
    ref: k,
    onClick: Yi(t.onClick, (q) => {
      H(
        (G) => !G
      ), z && (N.current = q.isPropagationStopped(), N.current || q.stopPropagation());
    })
  })), z && /* @__PURE__ */ L.createElement(JF, {
    control: w,
    bubbles: !N.current,
    name: o,
    value: b,
    checked: I,
    required: p,
    disabled: v,
    style: {
      transform: "translateX(-100%)"
    }
  }));
}), QF = "SwitchThumb", KF = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeSwitch: i, ...o } = t, u = GF(QF, i);
  return /* @__PURE__ */ L.createElement(qi.span, Wt({
    "data-state": O3(u.checked),
    "data-disabled": u.disabled ? "" : void 0
  }, o, {
    ref: n
  }));
}), JF = (t) => {
  const { control: n, checked: i, bubbles: o = !0, ...u } = t, f = L.useRef(null), p = WF(i), v = YF(n);
  return L.useEffect(() => {
    const b = f.current, S = window.HTMLInputElement.prototype, w = Object.getOwnPropertyDescriptor(S, "checked").set;
    if (p !== i && w) {
      const R = new Event("click", {
        bubbles: o
      });
      w.call(b, i), b.dispatchEvent(R);
    }
  }, [
    p,
    i,
    o
  ]), /* @__PURE__ */ L.createElement("input", Wt({
    type: "checkbox",
    "aria-hidden": !0,
    defaultChecked: i
  }, u, {
    tabIndex: -1,
    ref: f,
    style: {
      ...t.style,
      ...v,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    }
  }));
};
function O3(t) {
  return t ? "checked" : "unchecked";
}
const A3 = XF, eU = KF, D3 = L.forwardRef(({ className: t, ...n }, i) => /* @__PURE__ */ oe.jsx(
  A3,
  {
    className: Kr(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      t
    ),
    ...n,
    ref: i,
    children: /* @__PURE__ */ oe.jsx(
      eU,
      {
        className: Kr(
          "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
        )
      }
    )
  }
));
D3.displayName = A3.displayName;
const tU = (t) => IO[t] ? {
  name: `edit_${t}_props`,
  description: `编辑 ${t} 组件属性`,
  fields: [...nU, ...IO[t]],
  ui: cU[t]
} : DE, M3 = {
  style: ki.string().describe("组件 inline CSS 样式，输入合法的 CSS 字符串")
}, nU = [
  {
    name: "style",
    schema: M3.style,
    required: !0
  }
];
function mC(t) {
  return ki.object({
    ...M3,
    ...t
  });
}
function vC(t) {
  return Object.keys(t).map(
    (n) => ({
      name: n,
      schema: t[n],
      required: !0
    })
  );
}
const eo = ({
  children: t,
  label: n
}) => /* @__PURE__ */ oe.jsxs("div", { children: [
  /* @__PURE__ */ oe.jsx(qv, { children: n }),
  /* @__PURE__ */ oe.jsx("div", { className: "mt-2", children: t })
] }), yC = ({ value: t, onChange: n }) => /* @__PURE__ */ oe.jsx(
  hy,
  {
    value: t,
    onChange: (i) => {
      n(i.currentTarget.value);
    }
  }
), rU = ({ value: t, onChange: n }) => /* @__PURE__ */ oe.jsx(
  hy,
  {
    value: typeof t == "string" ? t : JSON.stringify(t, null, 2),
    onChange: (i) => {
      const o = i.currentTarget.value;
      try {
        n(JSON.parse(o));
      } catch {
        n(o);
      }
    }
  }
), N3 = ({
  value: t,
  onChange: n
}) => /* @__PURE__ */ oe.jsx(
  ah,
  {
    value: t,
    onChange: (i) => {
      n(i.currentTarget.value);
    }
  }
), B_ = ({
  value: t,
  onChange: n
}) => /* @__PURE__ */ oe.jsx(
  ah,
  {
    type: "number",
    value: t,
    onChange: (i) => {
      const o = parseInt(i.currentTarget.value, 10);
      Number.isNaN(o) || n(o);
    }
  }
), mb = ({
  value: t,
  onChange: n
}) => /* @__PURE__ */ oe.jsx(D3, { checked: t, onCheckedChange: n }), L3 = {
  currentPage: ki.number().int().describe("当前页数"),
  pageSize: ki.number().int().describe("每页显示条目个数"),
  total: ki.number().int().describe("总条数")
}, iU = vC(L3);
mC(L3);
const aU = ({ value: t, onChange: n }) => /* @__PURE__ */ oe.jsx(US, { children: /* @__PURE__ */ oe.jsxs(BS, { className: "pt-2", children: [
  /* @__PURE__ */ oe.jsx(eo, { label: "样式", children: /* @__PURE__ */ oe.jsx(
    yC,
    {
      value: t.style,
      onChange: (i) => {
        n({
          ...t,
          style: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "当前页", children: /* @__PURE__ */ oe.jsx(
    B_,
    {
      value: t.currentPage,
      onChange: (i) => {
        n({
          ...t,
          currentPage: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "总条数", children: /* @__PURE__ */ oe.jsx(
    B_,
    {
      value: t.total,
      onChange: (i) => {
        n({
          ...t,
          total: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "每页条数", children: /* @__PURE__ */ oe.jsx(
    B_,
    {
      value: t.pageSize,
      onChange: (i) => {
        n({
          ...t,
          pageSize: i
        });
      }
    }
  ) })
] }) }), P3 = {
  placeholder: ki.string().describe("输入框占位文本"),
  clearable: ki.boolean().describe("是否显示清除按钮"),
  searchable: ki.boolean().describe("下拉面板是否可搜索"),
  disabled: ki.boolean().describe("是否禁用"),
  multiple: ki.boolean().describe("是否允许输入框输入或选择多个项"),
  options: ki.array(
    ki.object({
      value: ki.string().describe("下拉项数值"),
      label: ki.string().describe("下拉项展示文本")
    })
  ).describe("配置 Select 下拉数据项")
}, oU = vC(P3);
mC(P3);
const lU = ({ value: t, onChange: n }) => /* @__PURE__ */ oe.jsx(US, { children: /* @__PURE__ */ oe.jsxs(BS, { className: "pt-2", children: [
  /* @__PURE__ */ oe.jsx(eo, { label: "样式", children: /* @__PURE__ */ oe.jsx(
    yC,
    {
      value: t.style,
      onChange: (i) => {
        n({
          ...t,
          style: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "占位文本 ", children: /* @__PURE__ */ oe.jsx(
    N3,
    {
      value: t.placeholder,
      onChange: (i) => {
        n({
          ...t,
          placeholder: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "清除按钮", children: /* @__PURE__ */ oe.jsx(
    mb,
    {
      value: t.clearable,
      onChange: (i) => {
        n({
          ...t,
          clearable: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "下拉面板可搜索", children: /* @__PURE__ */ oe.jsx(
    mb,
    {
      value: t.searchable,
      onChange: (i) => {
        n({
          ...t,
          searchable: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "禁用", children: /* @__PURE__ */ oe.jsx(
    mb,
    {
      value: t.disabled,
      onChange: (i) => {
        n({
          ...t,
          disabled: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "多选", children: /* @__PURE__ */ oe.jsx(
    mb,
    {
      value: t.multiple,
      onChange: (i) => {
        n({
          ...t,
          multiple: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "下拉数据", children: /* @__PURE__ */ oe.jsx(
    rU,
    {
      value: t.options,
      onChange: (i) => {
        n({
          ...t,
          options: i
        });
      }
    }
  ) })
] }) }), z3 = {
  children: ki.string().describe("文案内容")
}, sU = vC(z3);
mC(z3);
const uU = ({ value: t, onChange: n }) => /* @__PURE__ */ oe.jsx(US, { children: /* @__PURE__ */ oe.jsxs(BS, { className: "pt-2", children: [
  /* @__PURE__ */ oe.jsx(eo, { label: "样式", children: /* @__PURE__ */ oe.jsx(
    yC,
    {
      value: t.style,
      onChange: (i) => {
        n({
          ...t,
          style: i
        });
      }
    }
  ) }),
  /* @__PURE__ */ oe.jsx(eo, { label: "文本内容", children: /* @__PURE__ */ oe.jsx(
    N3,
    {
      value: t.children,
      onChange: (i) => {
        n({
          ...t,
          children: i
        });
      }
    }
  ) })
] }) }), IO = {
  TinyPager: iU,
  TinySelect: oU,
  p: sU
}, cU = {
  TinyPager: aU,
  TinySelect: lU,
  p: uU
}, DE = {
  name: "dummy",
  description: "",
  fields: []
};
function $3(t, n) {
  if (typeof t.children != "string")
    for (const i of t.children || []) {
      if (i.id === n)
        return i;
      const o = $3(i, n);
      if (o)
        return o;
    }
}
function fU(t) {
  return t && (t.children && !t.props && (t.props = {}), Object.assign(t.props, { children: t.children }), t);
}
function dU(t) {
  var n;
  return t && ((n = t.props) != null && n.children && (t.children = t.props.children, delete t.props.children, Object.keys(t.props).length === 0 && delete t.props), t);
}
const pU = /* @__PURE__ */ L.createContext(void 0);
function hU(t) {
  const n = L.useContext(pU);
  return t || n || "ltr";
}
function mU(t, [n, i]) {
  return Math.min(i, Math.max(n, t));
}
function vU(t, n) {
  return L.useReducer((i, o) => {
    const u = n[i][o];
    return u ?? i;
  }, t);
}
const j3 = "ScrollArea", [I3, yV] = FE(j3), [yU, To] = I3(j3), gU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeScrollArea: i, type: o = "hover", dir: u, scrollHideDelay: f = 600, ...p } = t, [v, b] = L.useState(null), [S, E] = L.useState(null), [w, R] = L.useState(null), [k, N] = L.useState(null), [z, I] = L.useState(null), [H, q] = L.useState(0), [G, te] = L.useState(0), [ee, V] = L.useState(!1), [ue, we] = L.useState(!1), me = no(
    n,
    (xe) => b(xe)
  ), Le = hU(u);
  return /* @__PURE__ */ L.createElement(yU, {
    scope: i,
    type: o,
    dir: Le,
    scrollHideDelay: f,
    scrollArea: v,
    viewport: S,
    onViewportChange: E,
    content: w,
    onContentChange: R,
    scrollbarX: k,
    onScrollbarXChange: N,
    scrollbarXEnabled: ee,
    onScrollbarXEnabledChange: V,
    scrollbarY: z,
    onScrollbarYChange: I,
    scrollbarYEnabled: ue,
    onScrollbarYEnabledChange: we,
    onCornerWidthChange: q,
    onCornerHeightChange: te
  }, /* @__PURE__ */ L.createElement(qi.div, Wt({
    dir: Le
  }, p, {
    ref: me,
    style: {
      position: "relative",
      // Pass corner sizes as CSS vars to reduce re-renders of context consumers
      "--radix-scroll-area-corner-width": H + "px",
      "--radix-scroll-area-corner-height": G + "px",
      ...t.style
    }
  })));
}), bU = "ScrollAreaViewport", SU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeScrollArea: i, children: o, ...u } = t, f = To(bU, i), p = L.useRef(null), v = no(n, p, f.onViewportChange);
  return /* @__PURE__ */ L.createElement(L.Fragment, null, /* @__PURE__ */ L.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
    }
  }), /* @__PURE__ */ L.createElement(qi.div, Wt({
    "data-radix-scroll-area-viewport": ""
  }, u, {
    ref: v,
    style: {
      /**
      * We don't support `visible` because the intention is to have at least one scrollbar
      * if this component is used and `visible` will behave like `auto` in that case
      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
      *
      * We don't handle `auto` because the intention is for the native implementation
      * to be hidden if using this component. We just want to ensure the node is scrollable
      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
      * the browser from having to work out whether to render native scrollbars or not,
      * we tell it to with the intention of hiding them in CSS.
      */
      overflowX: f.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: f.scrollbarYEnabled ? "scroll" : "hidden",
      ...t.style
    }
  }), /* @__PURE__ */ L.createElement("div", {
    ref: f.onContentChange,
    style: {
      minWidth: "100%",
      display: "table"
    }
  }, o)));
}), hu = "ScrollAreaScrollbar", F3 = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { forceMount: i, ...o } = t, u = To(hu, t.__scopeScrollArea), { onScrollbarXEnabledChange: f, onScrollbarYEnabledChange: p } = u, v = t.orientation === "horizontal";
  return L.useEffect(() => (v ? f(!0) : p(!0), () => {
    v ? f(!1) : p(!1);
  }), [
    v,
    f,
    p
  ]), u.type === "hover" ? /* @__PURE__ */ L.createElement(xU, Wt({}, o, {
    ref: n,
    forceMount: i
  })) : u.type === "scroll" ? /* @__PURE__ */ L.createElement(wU, Wt({}, o, {
    ref: n,
    forceMount: i
  })) : u.type === "auto" ? /* @__PURE__ */ L.createElement(U3, Wt({}, o, {
    ref: n,
    forceMount: i
  })) : u.type === "always" ? /* @__PURE__ */ L.createElement(gC, Wt({}, o, {
    ref: n
  })) : null;
}), xU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { forceMount: i, ...o } = t, u = To(hu, t.__scopeScrollArea), [f, p] = L.useState(!1);
  return L.useEffect(() => {
    const v = u.scrollArea;
    let b = 0;
    if (v) {
      const S = () => {
        window.clearTimeout(b), p(!0);
      }, E = () => {
        b = window.setTimeout(
          () => p(!1),
          u.scrollHideDelay
        );
      };
      return v.addEventListener("pointerenter", S), v.addEventListener("pointerleave", E), () => {
        window.clearTimeout(b), v.removeEventListener("pointerenter", S), v.removeEventListener("pointerleave", E);
      };
    }
  }, [
    u.scrollArea,
    u.scrollHideDelay
  ]), /* @__PURE__ */ L.createElement(Mc, {
    present: i || f
  }, /* @__PURE__ */ L.createElement(U3, Wt({
    "data-state": f ? "visible" : "hidden"
  }, o, {
    ref: n
  })));
}), wU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { forceMount: i, ...o } = t, u = To(hu, t.__scopeScrollArea), f = t.orientation === "horizontal", p = VS(
    () => b("SCROLL_END"),
    100
  ), [v, b] = vU("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return L.useEffect(() => {
    if (v === "idle") {
      const S = window.setTimeout(
        () => b("HIDE"),
        u.scrollHideDelay
      );
      return () => window.clearTimeout(S);
    }
  }, [
    v,
    u.scrollHideDelay,
    b
  ]), L.useEffect(() => {
    const S = u.viewport, E = f ? "scrollLeft" : "scrollTop";
    if (S) {
      let w = S[E];
      const R = () => {
        const k = S[E];
        w !== k && (b("SCROLL"), p()), w = k;
      };
      return S.addEventListener("scroll", R), () => S.removeEventListener("scroll", R);
    }
  }, [
    u.viewport,
    f,
    b,
    p
  ]), /* @__PURE__ */ L.createElement(Mc, {
    present: i || v !== "hidden"
  }, /* @__PURE__ */ L.createElement(gC, Wt({
    "data-state": v === "hidden" ? "hidden" : "visible"
  }, o, {
    ref: n,
    onPointerEnter: Yi(
      t.onPointerEnter,
      () => b("POINTER_ENTER")
    ),
    onPointerLeave: Yi(
      t.onPointerLeave,
      () => b("POINTER_LEAVE")
    )
  })));
}), U3 = /* @__PURE__ */ L.forwardRef((t, n) => {
  const i = To(hu, t.__scopeScrollArea), { forceMount: o, ...u } = t, [f, p] = L.useState(!1), v = t.orientation === "horizontal", b = VS(() => {
    if (i.viewport) {
      const S = i.viewport.offsetWidth < i.viewport.scrollWidth, E = i.viewport.offsetHeight < i.viewport.scrollHeight;
      p(v ? S : E);
    }
  }, 10);
  return dh(i.viewport, b), dh(i.content, b), /* @__PURE__ */ L.createElement(Mc, {
    present: o || f
  }, /* @__PURE__ */ L.createElement(gC, Wt({
    "data-state": f ? "visible" : "hidden"
  }, u, {
    ref: n
  })));
}), gC = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { orientation: i = "vertical", ...o } = t, u = To(hu, t.__scopeScrollArea), f = L.useRef(null), p = L.useRef(0), [v, b] = L.useState({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  }), S = W3(v.viewport, v.content), E = {
    ...o,
    sizes: v,
    onSizesChange: b,
    hasThumb: S > 0 && S < 1,
    onThumbChange: (R) => f.current = R,
    onThumbPointerUp: () => p.current = 0,
    onThumbPointerDown: (R) => p.current = R
  };
  function w(R, k) {
    return AU(R, p.current, v, k);
  }
  return i === "horizontal" ? /* @__PURE__ */ L.createElement(_U, Wt({}, E, {
    ref: n,
    onThumbPositionChange: () => {
      if (u.viewport && f.current) {
        const R = u.viewport.scrollLeft, k = FO(R, v, u.dir);
        f.current.style.transform = `translate3d(${k}px, 0, 0)`;
      }
    },
    onWheelScroll: (R) => {
      u.viewport && (u.viewport.scrollLeft = R);
    },
    onDragScroll: (R) => {
      u.viewport && (u.viewport.scrollLeft = w(R, u.dir));
    }
  })) : i === "vertical" ? /* @__PURE__ */ L.createElement(EU, Wt({}, E, {
    ref: n,
    onThumbPositionChange: () => {
      if (u.viewport && f.current) {
        const R = u.viewport.scrollTop, k = FO(R, v);
        f.current.style.transform = `translate3d(0, ${k}px, 0)`;
      }
    },
    onWheelScroll: (R) => {
      u.viewport && (u.viewport.scrollTop = R);
    },
    onDragScroll: (R) => {
      u.viewport && (u.viewport.scrollTop = w(R));
    }
  })) : null;
}), _U = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { sizes: i, onSizesChange: o, ...u } = t, f = To(hu, t.__scopeScrollArea), [p, v] = L.useState(), b = L.useRef(null), S = no(n, b, f.onScrollbarXChange);
  return L.useEffect(() => {
    b.current && v(getComputedStyle(b.current));
  }, [
    b
  ]), /* @__PURE__ */ L.createElement(H3, Wt({
    "data-orientation": "horizontal"
  }, u, {
    ref: S,
    sizes: i,
    style: {
      bottom: 0,
      left: f.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: f.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      "--radix-scroll-area-thumb-width": HS(i) + "px",
      ...t.style
    },
    onThumbPointerDown: (E) => t.onThumbPointerDown(E.x),
    onDragScroll: (E) => t.onDragScroll(E.x),
    onWheelScroll: (E, w) => {
      if (f.viewport) {
        const R = f.viewport.scrollLeft + E.deltaX;
        t.onWheelScroll(R), Z3(R, w) && E.preventDefault();
      }
    },
    onResize: () => {
      b.current && f.viewport && p && o({
        content: f.viewport.scrollWidth,
        viewport: f.viewport.offsetWidth,
        scrollbar: {
          size: b.current.clientWidth,
          paddingStart: TS(p.paddingLeft),
          paddingEnd: TS(p.paddingRight)
        }
      });
    }
  }));
}), EU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { sizes: i, onSizesChange: o, ...u } = t, f = To(hu, t.__scopeScrollArea), [p, v] = L.useState(), b = L.useRef(null), S = no(n, b, f.onScrollbarYChange);
  return L.useEffect(() => {
    b.current && v(getComputedStyle(b.current));
  }, [
    b
  ]), /* @__PURE__ */ L.createElement(H3, Wt({
    "data-orientation": "vertical"
  }, u, {
    ref: S,
    sizes: i,
    style: {
      top: 0,
      right: f.dir === "ltr" ? 0 : void 0,
      left: f.dir === "rtl" ? 0 : void 0,
      bottom: "var(--radix-scroll-area-corner-height)",
      "--radix-scroll-area-thumb-height": HS(i) + "px",
      ...t.style
    },
    onThumbPointerDown: (E) => t.onThumbPointerDown(E.y),
    onDragScroll: (E) => t.onDragScroll(E.y),
    onWheelScroll: (E, w) => {
      if (f.viewport) {
        const R = f.viewport.scrollTop + E.deltaY;
        t.onWheelScroll(R), Z3(R, w) && E.preventDefault();
      }
    },
    onResize: () => {
      b.current && f.viewport && p && o({
        content: f.viewport.scrollHeight,
        viewport: f.viewport.offsetHeight,
        scrollbar: {
          size: b.current.clientHeight,
          paddingStart: TS(p.paddingTop),
          paddingEnd: TS(p.paddingBottom)
        }
      });
    }
  }));
}), [CU, B3] = I3(hu), H3 = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeScrollArea: i, sizes: o, hasThumb: u, onThumbChange: f, onThumbPointerUp: p, onThumbPointerDown: v, onThumbPositionChange: b, onDragScroll: S, onWheelScroll: E, onResize: w, ...R } = t, k = To(hu, i), [N, z] = L.useState(null), I = no(
    n,
    (me) => z(me)
  ), H = L.useRef(null), q = L.useRef(""), G = k.viewport, te = o.content - o.viewport, ee = za(E), V = za(b), ue = VS(w, 10);
  function we(me) {
    if (H.current) {
      const Le = me.clientX - H.current.left, xe = me.clientY - H.current.top;
      S({
        x: Le,
        y: xe
      });
    }
  }
  return L.useEffect(() => {
    const me = (Le) => {
      const xe = Le.target;
      (N == null ? void 0 : N.contains(xe)) && ee(Le, te);
    };
    return document.addEventListener("wheel", me, {
      passive: !1
    }), () => document.removeEventListener("wheel", me, {
      passive: !1
    });
  }, [
    G,
    N,
    te,
    ee
  ]), L.useEffect(V, [
    o,
    V
  ]), dh(N, ue), dh(k.content, ue), /* @__PURE__ */ L.createElement(CU, {
    scope: i,
    scrollbar: N,
    hasThumb: u,
    onThumbChange: za(f),
    onThumbPointerUp: za(p),
    onThumbPositionChange: V,
    onThumbPointerDown: za(v)
  }, /* @__PURE__ */ L.createElement(qi.div, Wt({}, R, {
    ref: I,
    style: {
      position: "absolute",
      ...R.style
    },
    onPointerDown: Yi(t.onPointerDown, (me) => {
      me.button === 0 && (me.target.setPointerCapture(me.pointerId), H.current = N.getBoundingClientRect(), q.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", k.viewport && (k.viewport.style.scrollBehavior = "auto"), we(me));
    }),
    onPointerMove: Yi(t.onPointerMove, we),
    onPointerUp: Yi(t.onPointerUp, (me) => {
      const Le = me.target;
      Le.hasPointerCapture(me.pointerId) && Le.releasePointerCapture(me.pointerId), document.body.style.webkitUserSelect = q.current, k.viewport && (k.viewport.style.scrollBehavior = ""), H.current = null;
    })
  })));
}), ME = "ScrollAreaThumb", kU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { forceMount: i, ...o } = t, u = B3(ME, t.__scopeScrollArea);
  return /* @__PURE__ */ L.createElement(Mc, {
    present: i || u.hasThumb
  }, /* @__PURE__ */ L.createElement(TU, Wt({
    ref: n
  }, o)));
}), TU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeScrollArea: i, style: o, ...u } = t, f = To(ME, i), p = B3(ME, i), { onThumbPositionChange: v } = p, b = no(
    n,
    (w) => p.onThumbChange(w)
  ), S = L.useRef(), E = VS(() => {
    S.current && (S.current(), S.current = void 0);
  }, 100);
  return L.useEffect(() => {
    const w = f.viewport;
    if (w) {
      const R = () => {
        if (E(), !S.current) {
          const k = DU(w, v);
          S.current = k, v();
        }
      };
      return v(), w.addEventListener("scroll", R), () => w.removeEventListener("scroll", R);
    }
  }, [
    f.viewport,
    E,
    v
  ]), /* @__PURE__ */ L.createElement(qi.div, Wt({
    "data-state": p.hasThumb ? "visible" : "hidden"
  }, u, {
    ref: b,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...o
    },
    onPointerDownCapture: Yi(t.onPointerDownCapture, (w) => {
      const k = w.target.getBoundingClientRect(), N = w.clientX - k.left, z = w.clientY - k.top;
      p.onThumbPointerDown({
        x: N,
        y: z
      });
    }),
    onPointerUp: Yi(t.onPointerUp, p.onThumbPointerUp)
  }));
}), V3 = "ScrollAreaCorner", RU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const i = To(V3, t.__scopeScrollArea), o = !!(i.scrollbarX && i.scrollbarY);
  return i.type !== "scroll" && o ? /* @__PURE__ */ L.createElement(OU, Wt({}, t, {
    ref: n
  })) : null;
}), OU = /* @__PURE__ */ L.forwardRef((t, n) => {
  const { __scopeScrollArea: i, ...o } = t, u = To(V3, i), [f, p] = L.useState(0), [v, b] = L.useState(0), S = !!(f && v);
  return dh(u.scrollbarX, () => {
    var E;
    const w = ((E = u.scrollbarX) === null || E === void 0 ? void 0 : E.offsetHeight) || 0;
    u.onCornerHeightChange(w), b(w);
  }), dh(u.scrollbarY, () => {
    var E;
    const w = ((E = u.scrollbarY) === null || E === void 0 ? void 0 : E.offsetWidth) || 0;
    u.onCornerWidthChange(w), p(w);
  }), S ? /* @__PURE__ */ L.createElement(qi.div, Wt({}, o, {
    ref: n,
    style: {
      width: f,
      height: v,
      position: "absolute",
      right: u.dir === "ltr" ? 0 : void 0,
      left: u.dir === "rtl" ? 0 : void 0,
      bottom: 0,
      ...t.style
    }
  })) : null;
});
function TS(t) {
  return t ? parseInt(t, 10) : 0;
}
function W3(t, n) {
  const i = t / n;
  return isNaN(i) ? 0 : i;
}
function HS(t) {
  const n = W3(t.viewport, t.content), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = (t.scrollbar.size - i) * n;
  return Math.max(o, 18);
}
function AU(t, n, i, o = "ltr") {
  const u = HS(i), f = u / 2, p = n || f, v = u - p, b = i.scrollbar.paddingStart + p, S = i.scrollbar.size - i.scrollbar.paddingEnd - v, E = i.content - i.viewport, w = o === "ltr" ? [
    0,
    E
  ] : [
    E * -1,
    0
  ];
  return Y3([
    b,
    S
  ], w)(t);
}
function FO(t, n, i = "ltr") {
  const o = HS(n), u = n.scrollbar.paddingStart + n.scrollbar.paddingEnd, f = n.scrollbar.size - u, p = n.content - n.viewport, v = f - o, b = i === "ltr" ? [
    0,
    p
  ] : [
    p * -1,
    0
  ], S = mU(t, b);
  return Y3([
    0,
    p
  ], [
    0,
    v
  ])(S);
}
function Y3(t, n) {
  return (i) => {
    if (t[0] === t[1] || n[0] === n[1])
      return n[0];
    const o = (n[1] - n[0]) / (t[1] - t[0]);
    return n[0] + o * (i - t[0]);
  };
}
function Z3(t, n) {
  return t > 0 && t < n;
}
const DU = (t, n = () => {
}) => {
  let i = {
    left: t.scrollLeft,
    top: t.scrollTop
  }, o = 0;
  return function u() {
    const f = {
      left: t.scrollLeft,
      top: t.scrollTop
    }, p = i.left !== f.left, v = i.top !== f.top;
    (p || v) && n(), i = f, o = window.requestAnimationFrame(u);
  }(), () => window.cancelAnimationFrame(o);
};
function VS(t, n) {
  const i = za(t), o = L.useRef(0);
  return L.useEffect(
    () => () => window.clearTimeout(o.current),
    []
  ), L.useCallback(() => {
    window.clearTimeout(o.current), o.current = window.setTimeout(i, n);
  }, [
    i,
    n
  ]);
}
function dh(t, n) {
  const i = za(n);
  Gv(() => {
    let o = 0;
    if (t) {
      const u = new ResizeObserver(() => {
        cancelAnimationFrame(o), o = window.requestAnimationFrame(i);
      });
      return u.observe(t), () => {
        window.cancelAnimationFrame(o), u.unobserve(t);
      };
    }
  }, [
    t,
    i
  ]);
}
const q3 = gU, MU = SU, NU = RU, G3 = L.forwardRef(({ className: t, children: n, ...i }, o) => /* @__PURE__ */ oe.jsxs(
  q3,
  {
    ref: o,
    className: Kr("relative overflow-hidden", t),
    ...i,
    children: [
      /* @__PURE__ */ oe.jsx(MU, { className: "h-full w-full rounded-[inherit]", children: n }),
      /* @__PURE__ */ oe.jsx(X3, {}),
      /* @__PURE__ */ oe.jsx(NU, {})
    ]
  }
));
G3.displayName = q3.displayName;
const X3 = L.forwardRef(({ className: t, orientation: n = "vertical", ...i }, o) => /* @__PURE__ */ oe.jsx(
  F3,
  {
    ref: o,
    orientation: n,
    className: Kr(
      "flex touch-none select-none transition-colors",
      n === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      n === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      t
    ),
    ...i,
    children: /* @__PURE__ */ oe.jsx(kU, { className: "relative flex-1 rounded-full bg-border" })
  }
));
X3.displayName = F3.displayName;
function LU(t, n) {
  const i = n || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (i.padRight ? " " : "") + "," + (i.padLeft === !1 ? "" : " ")
  ).trim();
}
const PU = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, zU = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, $U = {};
function UO(t, n) {
  return ((n || $U).jsx ? zU : PU).test(t);
}
const jU = /[ \t\n\f\r]/g;
function IU(t) {
  return typeof t == "object" ? t.type === "text" ? BO(t.value) : !1 : BO(t);
}
function BO(t) {
  return t.replace(jU, "") === "";
}
class yy {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(n, i, o) {
    this.property = n, this.normal = i, o && (this.space = o);
  }
}
yy.prototype.property = {};
yy.prototype.normal = {};
yy.prototype.space = null;
function Q3(t, n) {
  const i = {}, o = {};
  let u = -1;
  for (; ++u < t.length; )
    Object.assign(i, t[u].property), Object.assign(o, t[u].normal);
  return new yy(i, o, n);
}
function NE(t) {
  return t.toLowerCase();
}
class Ro {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(n, i) {
    this.property = n, this.attribute = i;
  }
}
Ro.prototype.space = null;
Ro.prototype.boolean = !1;
Ro.prototype.booleanish = !1;
Ro.prototype.overloadedBoolean = !1;
Ro.prototype.number = !1;
Ro.prototype.commaSeparated = !1;
Ro.prototype.spaceSeparated = !1;
Ro.prototype.commaOrSpaceSeparated = !1;
Ro.prototype.mustUseProperty = !1;
Ro.prototype.defined = !1;
let FU = 0;
const Vt = Kf(), $r = Kf(), K3 = Kf(), Ae = Kf(), Wn = Kf(), ih = Kf(), Ka = Kf();
function Kf() {
  return 2 ** ++FU;
}
const LE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Vt,
  booleanish: $r,
  commaOrSpaceSeparated: Ka,
  commaSeparated: ih,
  number: Ae,
  overloadedBoolean: K3,
  spaceSeparated: Wn
}, Symbol.toStringTag, { value: "Module" })), H_ = Object.keys(LE);
class bC extends Ro {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(n, i, o, u) {
    let f = -1;
    if (super(n, i), HO(this, "space", u), typeof o == "number")
      for (; ++f < H_.length; ) {
        const p = H_[f];
        HO(this, H_[f], (o & LE[p]) === LE[p]);
      }
  }
}
bC.prototype.defined = !0;
function HO(t, n, i) {
  i && (t[n] = i);
}
const UU = {}.hasOwnProperty;
function mh(t) {
  const n = {}, i = {};
  let o;
  for (o in t.properties)
    if (UU.call(t.properties, o)) {
      const u = t.properties[o], f = new bC(
        o,
        t.transform(t.attributes || {}, o),
        u,
        t.space
      );
      t.mustUseProperty && t.mustUseProperty.includes(o) && (f.mustUseProperty = !0), n[o] = f, i[NE(o)] = o, i[NE(f.attribute)] = o;
    }
  return new yy(n, i, t.space);
}
const J3 = mh({
  space: "xlink",
  transform(t, n) {
    return "xlink:" + n.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), eD = mh({
  space: "xml",
  transform(t, n) {
    return "xml:" + n.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function tD(t, n) {
  return n in t ? t[n] : n;
}
function nD(t, n) {
  return tD(t, n.toLowerCase());
}
const rD = mh({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: nD,
  properties: { xmlns: null, xmlnsXLink: null }
}), iD = mh({
  transform(t, n) {
    return n === "role" ? n : "aria-" + n.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: $r,
    ariaAutoComplete: null,
    ariaBusy: $r,
    ariaChecked: $r,
    ariaColCount: Ae,
    ariaColIndex: Ae,
    ariaColSpan: Ae,
    ariaControls: Wn,
    ariaCurrent: null,
    ariaDescribedBy: Wn,
    ariaDetails: null,
    ariaDisabled: $r,
    ariaDropEffect: Wn,
    ariaErrorMessage: null,
    ariaExpanded: $r,
    ariaFlowTo: Wn,
    ariaGrabbed: $r,
    ariaHasPopup: null,
    ariaHidden: $r,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Wn,
    ariaLevel: Ae,
    ariaLive: null,
    ariaModal: $r,
    ariaMultiLine: $r,
    ariaMultiSelectable: $r,
    ariaOrientation: null,
    ariaOwns: Wn,
    ariaPlaceholder: null,
    ariaPosInSet: Ae,
    ariaPressed: $r,
    ariaReadOnly: $r,
    ariaRelevant: null,
    ariaRequired: $r,
    ariaRoleDescription: Wn,
    ariaRowCount: Ae,
    ariaRowIndex: Ae,
    ariaRowSpan: Ae,
    ariaSelected: $r,
    ariaSetSize: Ae,
    ariaSort: null,
    ariaValueMax: Ae,
    ariaValueMin: Ae,
    ariaValueNow: Ae,
    ariaValueText: null,
    role: null
  }
}), BU = mh({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: nD,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ih,
    acceptCharset: Wn,
    accessKey: Wn,
    action: null,
    allow: null,
    allowFullScreen: Vt,
    allowPaymentRequest: Vt,
    allowUserMedia: Vt,
    alt: null,
    as: null,
    async: Vt,
    autoCapitalize: null,
    autoComplete: Wn,
    autoFocus: Vt,
    autoPlay: Vt,
    blocking: Wn,
    capture: null,
    charSet: null,
    checked: Vt,
    cite: null,
    className: Wn,
    cols: Ae,
    colSpan: null,
    content: null,
    contentEditable: $r,
    controls: Vt,
    controlsList: Wn,
    coords: Ae | ih,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Vt,
    defer: Vt,
    dir: null,
    dirName: null,
    disabled: Vt,
    download: K3,
    draggable: $r,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Vt,
    formTarget: null,
    headers: Wn,
    height: Ae,
    hidden: Vt,
    high: Ae,
    href: null,
    hrefLang: null,
    htmlFor: Wn,
    httpEquiv: Wn,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Vt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Vt,
    itemId: null,
    itemProp: Wn,
    itemRef: Wn,
    itemScope: Vt,
    itemType: Wn,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Vt,
    low: Ae,
    manifest: null,
    max: null,
    maxLength: Ae,
    media: null,
    method: null,
    min: null,
    minLength: Ae,
    multiple: Vt,
    muted: Vt,
    name: null,
    nonce: null,
    noModule: Vt,
    noValidate: Vt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Vt,
    optimum: Ae,
    pattern: null,
    ping: Wn,
    placeholder: null,
    playsInline: Vt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Vt,
    referrerPolicy: null,
    rel: Wn,
    required: Vt,
    reversed: Vt,
    rows: Ae,
    rowSpan: Ae,
    sandbox: Wn,
    scope: null,
    scoped: Vt,
    seamless: Vt,
    selected: Vt,
    shadowRootDelegatesFocus: Vt,
    shadowRootMode: null,
    shape: null,
    size: Ae,
    sizes: null,
    slot: null,
    span: Ae,
    spellCheck: $r,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Ae,
    step: null,
    style: null,
    tabIndex: Ae,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Vt,
    useMap: null,
    value: $r,
    width: Ae,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Wn,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Ae,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Ae,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Vt,
    // Lists. Use CSS to reduce space between items instead
    declare: Vt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Ae,
    // `<img>` and `<object>`
    leftMargin: Ae,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Ae,
    // `<body>`
    marginWidth: Ae,
    // `<body>`
    noResize: Vt,
    // `<frame>`
    noHref: Vt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Vt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Vt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Ae,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: $r,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Ae,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Ae,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Vt,
    disableRemotePlayback: Vt,
    prefix: null,
    property: null,
    results: Ae,
    security: null,
    unselectable: null
  }
}), HU = mh({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: tD,
  properties: {
    about: Ka,
    accentHeight: Ae,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Ae,
    amplitude: Ae,
    arabicForm: null,
    ascent: Ae,
    attributeName: null,
    attributeType: null,
    azimuth: Ae,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Ae,
    by: null,
    calcMode: null,
    capHeight: Ae,
    className: Wn,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Ae,
    diffuseConstant: Ae,
    direction: null,
    display: null,
    dur: null,
    divisor: Ae,
    dominantBaseline: null,
    download: Vt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Ae,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Ae,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Ae,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ih,
    g2: ih,
    glyphName: ih,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Ae,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Ae,
    horizOriginX: Ae,
    horizOriginY: Ae,
    id: null,
    ideographic: Ae,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Ae,
    k: Ae,
    k1: Ae,
    k2: Ae,
    k3: Ae,
    k4: Ae,
    kernelMatrix: Ka,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Ae,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Ae,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Ae,
    overlineThickness: Ae,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Ae,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Wn,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Ae,
    pointsAtY: Ae,
    pointsAtZ: Ae,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ka,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ka,
    rev: Ka,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ka,
    requiredFeatures: Ka,
    requiredFonts: Ka,
    requiredFormats: Ka,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Ae,
    specularExponent: Ae,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Ae,
    strikethroughThickness: Ae,
    string: null,
    stroke: null,
    strokeDashArray: Ka,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Ae,
    strokeOpacity: Ae,
    strokeWidth: null,
    style: null,
    surfaceScale: Ae,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ka,
    tabIndex: Ae,
    tableValues: null,
    target: null,
    targetX: Ae,
    targetY: Ae,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ka,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Ae,
    underlineThickness: Ae,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Ae,
    values: null,
    vAlphabetic: Ae,
    vMathematical: Ae,
    vectorEffect: null,
    vHanging: Ae,
    vIdeographic: Ae,
    version: null,
    vertAdvY: Ae,
    vertOriginX: Ae,
    vertOriginY: Ae,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Ae,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), VU = /^data[-\w.:]+$/i, VO = /-[a-z]/g, WU = /[A-Z]/g;
function YU(t, n) {
  const i = NE(n);
  let o = n, u = Ro;
  if (i in t.normal)
    return t.property[t.normal[i]];
  if (i.length > 4 && i.slice(0, 4) === "data" && VU.test(n)) {
    if (n.charAt(4) === "-") {
      const f = n.slice(5).replace(VO, qU);
      o = "data" + f.charAt(0).toUpperCase() + f.slice(1);
    } else {
      const f = n.slice(4);
      if (!VO.test(f)) {
        let p = f.replace(WU, ZU);
        p.charAt(0) !== "-" && (p = "-" + p), n = "data" + p;
      }
    }
    u = bC;
  }
  return new u(o, n);
}
function ZU(t) {
  return "-" + t.toLowerCase();
}
function qU(t) {
  return t.charAt(1).toUpperCase();
}
const GU = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, XU = Q3([eD, J3, rD, iD, BU], "html"), SC = Q3([eD, J3, rD, iD, HU], "svg");
function QU(t) {
  return t.join(" ").trim();
}
var aD = {}, WO = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, KU = /\n/g, JU = /^\s*/, eB = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, tB = /^:\s*/, nB = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, rB = /^[;\s]*/, iB = /^\s+|\s+$/g, aB = `
`, YO = "/", ZO = "*", Bf = "", oB = "comment", lB = "declaration", sB = function(t, n) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t)
    return [];
  n = n || {};
  var i = 1, o = 1;
  function u(N) {
    var z = N.match(KU);
    z && (i += z.length);
    var I = N.lastIndexOf(aB);
    o = ~I ? N.length - I : o + N.length;
  }
  function f() {
    var N = { line: i, column: o };
    return function(z) {
      return z.position = new p(N), S(), z;
    };
  }
  function p(N) {
    this.start = N, this.end = { line: i, column: o }, this.source = n.source;
  }
  p.prototype.content = t;
  function v(N) {
    var z = new Error(
      n.source + ":" + i + ":" + o + ": " + N
    );
    if (z.reason = N, z.filename = n.source, z.line = i, z.column = o, z.source = t, !n.silent)
      throw z;
  }
  function b(N) {
    var z = N.exec(t);
    if (z) {
      var I = z[0];
      return u(I), t = t.slice(I.length), z;
    }
  }
  function S() {
    b(JU);
  }
  function E(N) {
    var z;
    for (N = N || []; z = w(); )
      z !== !1 && N.push(z);
    return N;
  }
  function w() {
    var N = f();
    if (!(YO != t.charAt(0) || ZO != t.charAt(1))) {
      for (var z = 2; Bf != t.charAt(z) && (ZO != t.charAt(z) || YO != t.charAt(z + 1)); )
        ++z;
      if (z += 2, Bf === t.charAt(z - 1))
        return v("End of comment missing");
      var I = t.slice(2, z - 2);
      return o += 2, u(I), t = t.slice(z), o += 2, N({
        type: oB,
        comment: I
      });
    }
  }
  function R() {
    var N = f(), z = b(eB);
    if (z) {
      if (w(), !b(tB))
        return v("property missing ':'");
      var I = b(nB), H = N({
        type: lB,
        property: qO(z[0].replace(WO, Bf)),
        value: I ? qO(I[0].replace(WO, Bf)) : Bf
      });
      return b(rB), H;
    }
  }
  function k() {
    var N = [];
    E(N);
    for (var z; z = R(); )
      z !== !1 && (N.push(z), E(N));
    return N;
  }
  return S(), k();
};
function qO(t) {
  return t ? t.replace(iB, Bf) : Bf;
}
var uB = fR && fR.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(aD, "__esModule", { value: !0 });
var cB = uB(sB);
function fB(t, n) {
  var i = null;
  if (!t || typeof t != "string")
    return i;
  var o = (0, cB.default)(t), u = typeof n == "function";
  return o.forEach(function(f) {
    if (f.type === "declaration") {
      var p = f.property, v = f.value;
      u ? n(p, v, f) : v && (i = i || {}, i[p] = v);
    }
  }), i;
}
var GO = aD.default = fB;
const dB = GO.default || GO, oD = lD("end"), xC = lD("start");
function lD(t) {
  return n;
  function n(i) {
    const o = i && i.position && i.position[t] || {};
    if (typeof o.line == "number" && o.line > 0 && typeof o.column == "number" && o.column > 0)
      return {
        line: o.line,
        column: o.column,
        offset: typeof o.offset == "number" && o.offset > -1 ? o.offset : void 0
      };
  }
}
function pB(t) {
  const n = xC(t), i = oD(t);
  if (n && i)
    return { start: n, end: i };
}
class Gi extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(n, i, o) {
    super(), typeof i == "string" && (o = i, i = void 0);
    let u = "", f = {}, p = !1;
    if (i && ("line" in i && "column" in i ? f = { place: i } : "start" in i && "end" in i ? f = { place: i } : "type" in i ? f = {
      ancestors: [i],
      place: i.position
    } : f = { ...i }), typeof n == "string" ? u = n : !f.cause && n && (p = !0, u = n.message, f.cause = n), !f.ruleId && !f.source && typeof o == "string") {
      const b = o.indexOf(":");
      b === -1 ? f.ruleId = o : (f.source = o.slice(0, b), f.ruleId = o.slice(b + 1));
    }
    if (!f.place && f.ancestors && f.ancestors) {
      const b = f.ancestors[f.ancestors.length - 1];
      b && (f.place = b.position);
    }
    const v = f.place && "start" in f.place ? f.place.start : f.place;
    this.ancestors = f.ancestors || void 0, this.cause = f.cause || void 0, this.column = v ? v.column : void 0, this.fatal = void 0, this.file, this.message = u, this.line = v ? v.line : void 0, this.name = Wv(f.place) || "1:1", this.place = f.place || void 0, this.reason = this.message, this.ruleId = f.ruleId || void 0, this.source = f.source || void 0, this.stack = p && f.cause && typeof f.cause.stack == "string" ? f.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Gi.prototype.file = "";
Gi.prototype.name = "";
Gi.prototype.reason = "";
Gi.prototype.message = "";
Gi.prototype.stack = "";
Gi.prototype.column = void 0;
Gi.prototype.line = void 0;
Gi.prototype.ancestors = void 0;
Gi.prototype.cause = void 0;
Gi.prototype.fatal = void 0;
Gi.prototype.place = void 0;
Gi.prototype.ruleId = void 0;
Gi.prototype.source = void 0;
const wC = {}.hasOwnProperty, hB = /* @__PURE__ */ new Map(), mB = /[A-Z]/g, vB = /-([a-z])/g, yB = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), gB = /* @__PURE__ */ new Set(["td", "th"]), sD = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function bB(t, n) {
  if (!n || n.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const i = n.filePath || void 0;
  let o;
  if (n.development) {
    if (typeof n.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    o = TB(i, n.jsxDEV);
  } else {
    if (typeof n.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof n.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    o = kB(i, n.jsx, n.jsxs);
  }
  const u = {
    Fragment: n.Fragment,
    ancestors: [],
    components: n.components || {},
    create: o,
    elementAttributeNameCase: n.elementAttributeNameCase || "react",
    evaluater: n.createEvaluater ? n.createEvaluater() : void 0,
    filePath: i,
    ignoreInvalidStyle: n.ignoreInvalidStyle || !1,
    passKeys: n.passKeys !== !1,
    passNode: n.passNode || !1,
    schema: n.space === "svg" ? SC : XU,
    stylePropertyNameCase: n.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: n.tableCellAlignToStyle !== !1
  }, f = uD(u, t, void 0);
  return f && typeof f != "string" ? f : u.create(
    t,
    u.Fragment,
    { children: f || void 0 },
    void 0
  );
}
function uD(t, n, i) {
  if (n.type === "element")
    return SB(t, n, i);
  if (n.type === "mdxFlowExpression" || n.type === "mdxTextExpression")
    return xB(t, n);
  if (n.type === "mdxJsxFlowElement" || n.type === "mdxJsxTextElement")
    return _B(t, n, i);
  if (n.type === "mdxjsEsm")
    return wB(t, n);
  if (n.type === "root")
    return EB(t, n, i);
  if (n.type === "text")
    return CB(t, n);
}
function SB(t, n, i) {
  const o = t.schema;
  let u = o;
  n.tagName.toLowerCase() === "svg" && o.space === "html" && (u = SC, t.schema = u), t.ancestors.push(n);
  const f = fD(t, n.tagName, !1), p = RB(t, n);
  let v = EC(t, n);
  return yB.has(n.tagName) && (v = v.filter(function(b) {
    return typeof b == "string" ? !IU(b) : !0;
  })), cD(t, p, f, n), _C(p, v), t.ancestors.pop(), t.schema = o, t.create(n, f, p, i);
}
function xB(t, n) {
  if (n.data && n.data.estree && t.evaluater) {
    const o = n.data.estree.body[0];
    return o.type, /** @type {Child | undefined} */
    t.evaluater.evaluateExpression(o.expression);
  }
  py(t, n.position);
}
function wB(t, n) {
  if (n.data && n.data.estree && t.evaluater)
    return (
      /** @type {Child | undefined} */
      t.evaluater.evaluateProgram(n.data.estree)
    );
  py(t, n.position);
}
function _B(t, n, i) {
  const o = t.schema;
  let u = o;
  n.name === "svg" && o.space === "html" && (u = SC, t.schema = u), t.ancestors.push(n);
  const f = n.name === null ? t.Fragment : fD(t, n.name, !0), p = OB(t, n), v = EC(t, n);
  return cD(t, p, f, n), _C(p, v), t.ancestors.pop(), t.schema = o, t.create(n, f, p, i);
}
function EB(t, n, i) {
  const o = {};
  return _C(o, EC(t, n)), t.create(n, t.Fragment, o, i);
}
function CB(t, n) {
  return n.value;
}
function cD(t, n, i, o) {
  typeof i != "string" && i !== t.Fragment && t.passNode && (n.node = o);
}
function _C(t, n) {
  if (n.length > 0) {
    const i = n.length > 1 ? n : n[0];
    i && (t.children = i);
  }
}
function kB(t, n, i) {
  return o;
  function o(u, f, p, v) {
    const S = Array.isArray(p.children) ? i : n;
    return v ? S(f, p, v) : S(f, p);
  }
}
function TB(t, n) {
  return i;
  function i(o, u, f, p) {
    const v = Array.isArray(f.children), b = xC(o);
    return n(
      u,
      f,
      p,
      v,
      {
        columnNumber: b ? b.column - 1 : void 0,
        fileName: t,
        lineNumber: b ? b.line : void 0
      },
      void 0
    );
  }
}
function RB(t, n) {
  const i = {};
  let o, u;
  for (u in n.properties)
    if (u !== "children" && wC.call(n.properties, u)) {
      const f = AB(t, u, n.properties[u]);
      if (f) {
        const [p, v] = f;
        t.tableCellAlignToStyle && p === "align" && typeof v == "string" && gB.has(n.tagName) ? o = v : i[p] = v;
      }
    }
  if (o) {
    const f = (
      /** @type {Style} */
      i.style || (i.style = {})
    );
    f[t.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = o;
  }
  return i;
}
function OB(t, n) {
  const i = {};
  for (const o of n.attributes)
    if (o.type === "mdxJsxExpressionAttribute")
      if (o.data && o.data.estree && t.evaluater) {
        const f = o.data.estree.body[0];
        f.type;
        const p = f.expression;
        p.type;
        const v = p.properties[0];
        v.type, Object.assign(
          i,
          t.evaluater.evaluateExpression(v.argument)
        );
      } else
        py(t, n.position);
    else {
      const u = o.name;
      let f;
      if (o.value && typeof o.value == "object")
        if (o.value.data && o.value.data.estree && t.evaluater) {
          const v = o.value.data.estree.body[0];
          v.type, f = t.evaluater.evaluateExpression(v.expression);
        } else
          py(t, n.position);
      else
        f = o.value === null ? !0 : o.value;
      i[u] = /** @type {Props[keyof Props]} */
      f;
    }
  return i;
}
function EC(t, n) {
  const i = [];
  let o = -1;
  const u = t.passKeys ? /* @__PURE__ */ new Map() : hB;
  for (; ++o < n.children.length; ) {
    const f = n.children[o];
    let p;
    if (t.passKeys) {
      const b = f.type === "element" ? f.tagName : f.type === "mdxJsxFlowElement" || f.type === "mdxJsxTextElement" ? f.name : void 0;
      if (b) {
        const S = u.get(b) || 0;
        p = b + "-" + S, u.set(b, S + 1);
      }
    }
    const v = uD(t, f, p);
    v !== void 0 && i.push(v);
  }
  return i;
}
function AB(t, n, i) {
  const o = YU(t.schema, n);
  if (!(i == null || typeof i == "number" && Number.isNaN(i))) {
    if (Array.isArray(i) && (i = o.commaSeparated ? LU(i) : QU(i)), o.property === "style") {
      let u = typeof i == "object" ? i : DB(t, String(i));
      return t.stylePropertyNameCase === "css" && (u = MB(u)), ["style", u];
    }
    return [
      t.elementAttributeNameCase === "react" && o.space ? GU[o.property] || o.property : o.attribute,
      i
    ];
  }
}
function DB(t, n) {
  const i = {};
  try {
    dB(n, o);
  } catch (u) {
    if (!t.ignoreInvalidStyle) {
      const f = (
        /** @type {Error} */
        u
      ), p = new Gi("Cannot parse `style` attribute", {
        ancestors: t.ancestors,
        cause: f,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw p.file = t.filePath || void 0, p.url = sD + "#cannot-parse-style-attribute", p;
    }
  }
  return i;
  function o(u, f) {
    let p = u;
    p.slice(0, 2) !== "--" && (p.slice(0, 4) === "-ms-" && (p = "ms-" + p.slice(4)), p = p.replace(vB, LB)), i[p] = f;
  }
}
function fD(t, n, i) {
  let o;
  if (!i)
    o = { type: "Literal", value: n };
  else if (n.includes(".")) {
    const u = n.split(".");
    let f = -1, p;
    for (; ++f < u.length; ) {
      const v = UO(u[f]) ? { type: "Identifier", name: u[f] } : { type: "Literal", value: u[f] };
      p = p ? {
        type: "MemberExpression",
        object: p,
        property: v,
        computed: !!(f && v.type === "Literal"),
        optional: !1
      } : v;
    }
    o = p;
  } else
    o = UO(n) && !/^[a-z]/.test(n) ? { type: "Identifier", name: n } : { type: "Literal", value: n };
  if (o.type === "Literal") {
    const u = (
      /** @type {keyof JSX.IntrinsicElements} */
      o.value
    );
    return wC.call(t.components, u) ? t.components[u] : u;
  }
  if (t.evaluater)
    return t.evaluater.evaluateExpression(o);
  py(t);
}
function py(t, n) {
  const i = new Gi(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: t.ancestors,
      place: n,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw i.file = t.filePath || void 0, i.url = sD + "#cannot-handle-mdx-estrees-without-createevaluater", i;
}
function MB(t) {
  const n = {};
  let i;
  for (i in t)
    wC.call(t, i) && (n[NB(i)] = t[i]);
  return n;
}
function NB(t) {
  let n = t.replace(mB, PB);
  return n.slice(0, 3) === "ms-" && (n = "-" + n), n;
}
function LB(t, n) {
  return n.toUpperCase();
}
function PB(t) {
  return "-" + t.toLowerCase();
}
const V_ = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
function zB(t) {
  const n = this;
  n.parser = i;
  function i(o) {
    return pA(o, {
      ...n.data("settings"),
      ...t,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: n.data("micromarkExtensions") || [],
      mdastExtensions: n.data("fromMarkdownExtensions") || []
    });
  }
}
function $B(t, n) {
  const i = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(n), !0)
  };
  return t.patch(n, i), t.applyData(n, i);
}
function jB(t, n) {
  const i = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(n, i), [t.applyData(n, i), { type: "text", value: `
` }];
}
function IB(t, n) {
  const i = n.value ? n.value + `
` : "", o = {};
  n.lang && (o.className = ["language-" + n.lang]);
  let u = {
    type: "element",
    tagName: "code",
    properties: o,
    children: [{ type: "text", value: i }]
  };
  return n.meta && (u.data = { meta: n.meta }), t.patch(n, u), u = t.applyData(n, u), u = { type: "element", tagName: "pre", properties: {}, children: [u] }, t.patch(n, u), u;
}
function FB(t, n) {
  const i = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, i), t.applyData(n, i);
}
function UB(t, n) {
  const i = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, i), t.applyData(n, i);
}
function BB(t, n) {
  const i = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", o = String(n.identifier).toUpperCase(), u = hh(o.toLowerCase()), f = t.footnoteOrder.indexOf(o);
  let p, v = t.footnoteCounts.get(o);
  v === void 0 ? (v = 0, t.footnoteOrder.push(o), p = t.footnoteOrder.length) : p = f + 1, v += 1, t.footnoteCounts.set(o, v);
  const b = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + i + "fn-" + u,
      id: i + "fnref-" + u + (v > 1 ? "-" + v : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(p) }]
  };
  t.patch(n, b);
  const S = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [b]
  };
  return t.patch(n, S), t.applyData(n, S);
}
function HB(t, n) {
  const i = {
    type: "element",
    tagName: "h" + n.depth,
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, i), t.applyData(n, i);
}
function VB(t, n) {
  if (t.options.allowDangerousHtml) {
    const i = { type: "raw", value: n.value };
    return t.patch(n, i), t.applyData(n, i);
  }
}
function dD(t, n) {
  const i = n.referenceType;
  let o = "]";
  if (i === "collapsed" ? o += "[]" : i === "full" && (o += "[" + (n.label || n.identifier) + "]"), n.type === "imageReference")
    return [{ type: "text", value: "![" + n.alt + o }];
  const u = t.all(n), f = u[0];
  f && f.type === "text" ? f.value = "[" + f.value : u.unshift({ type: "text", value: "[" });
  const p = u[u.length - 1];
  return p && p.type === "text" ? p.value += o : u.push({ type: "text", value: o }), u;
}
function WB(t, n) {
  const i = String(n.identifier).toUpperCase(), o = t.definitionById.get(i);
  if (!o)
    return dD(t, n);
  const u = { src: hh(o.url || ""), alt: n.alt };
  o.title !== null && o.title !== void 0 && (u.title = o.title);
  const f = { type: "element", tagName: "img", properties: u, children: [] };
  return t.patch(n, f), t.applyData(n, f);
}
function YB(t, n) {
  const i = { src: hh(n.url) };
  n.alt !== null && n.alt !== void 0 && (i.alt = n.alt), n.title !== null && n.title !== void 0 && (i.title = n.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return t.patch(n, o), t.applyData(n, o);
}
function ZB(t, n) {
  const i = { type: "text", value: n.value.replace(/\r?\n|\r/g, " ") };
  t.patch(n, i);
  const o = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [i]
  };
  return t.patch(n, o), t.applyData(n, o);
}
function qB(t, n) {
  const i = String(n.identifier).toUpperCase(), o = t.definitionById.get(i);
  if (!o)
    return dD(t, n);
  const u = { href: hh(o.url || "") };
  o.title !== null && o.title !== void 0 && (u.title = o.title);
  const f = {
    type: "element",
    tagName: "a",
    properties: u,
    children: t.all(n)
  };
  return t.patch(n, f), t.applyData(n, f);
}
function GB(t, n) {
  const i = { href: hh(n.url) };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: t.all(n)
  };
  return t.patch(n, o), t.applyData(n, o);
}
function XB(t, n, i) {
  const o = t.all(n), u = i ? QB(i) : pD(n), f = {}, p = [];
  if (typeof n.checked == "boolean") {
    const E = o[0];
    let w;
    E && E.type === "element" && E.tagName === "p" ? w = E : (w = { type: "element", tagName: "p", properties: {}, children: [] }, o.unshift(w)), w.children.length > 0 && w.children.unshift({ type: "text", value: " " }), w.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: n.checked, disabled: !0 },
      children: []
    }), f.className = ["task-list-item"];
  }
  let v = -1;
  for (; ++v < o.length; ) {
    const E = o[v];
    (u || v !== 0 || E.type !== "element" || E.tagName !== "p") && p.push({ type: "text", value: `
` }), E.type === "element" && E.tagName === "p" && !u ? p.push(...E.children) : p.push(E);
  }
  const b = o[o.length - 1];
  b && (u || b.type !== "element" || b.tagName !== "p") && p.push({ type: "text", value: `
` });
  const S = { type: "element", tagName: "li", properties: f, children: p };
  return t.patch(n, S), t.applyData(n, S);
}
function QB(t) {
  let n = !1;
  if (t.type === "list") {
    n = t.spread || !1;
    const i = t.children;
    let o = -1;
    for (; !n && ++o < i.length; )
      n = pD(i[o]);
  }
  return n;
}
function pD(t) {
  const n = t.spread;
  return n ?? t.children.length > 1;
}
function KB(t, n) {
  const i = {}, o = t.all(n);
  let u = -1;
  for (typeof n.start == "number" && n.start !== 1 && (i.start = n.start); ++u < o.length; ) {
    const p = o[u];
    if (p.type === "element" && p.tagName === "li" && p.properties && Array.isArray(p.properties.className) && p.properties.className.includes("task-list-item")) {
      i.className = ["contains-task-list"];
      break;
    }
  }
  const f = {
    type: "element",
    tagName: n.ordered ? "ol" : "ul",
    properties: i,
    children: t.wrap(o, !0)
  };
  return t.patch(n, f), t.applyData(n, f);
}
function JB(t, n) {
  const i = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, i), t.applyData(n, i);
}
function eH(t, n) {
  const i = { type: "root", children: t.wrap(t.all(n)) };
  return t.patch(n, i), t.applyData(n, i);
}
function tH(t, n) {
  const i = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, i), t.applyData(n, i);
}
function nH(t, n) {
  const i = t.all(n), o = i.shift(), u = [];
  if (o) {
    const p = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([o], !0)
    };
    t.patch(n.children[0], p), u.push(p);
  }
  if (i.length > 0) {
    const p = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(i, !0)
    }, v = xC(n.children[1]), b = oD(n.children[n.children.length - 1]);
    v && b && (p.position = { start: v, end: b }), u.push(p);
  }
  const f = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(u, !0)
  };
  return t.patch(n, f), t.applyData(n, f);
}
function rH(t, n, i) {
  const o = i ? i.children : void 0, f = (o ? o.indexOf(n) : 1) === 0 ? "th" : "td", p = i && i.type === "table" ? i.align : void 0, v = p ? p.length : n.children.length;
  let b = -1;
  const S = [];
  for (; ++b < v; ) {
    const w = n.children[b], R = {}, k = p ? p[b] : void 0;
    k && (R.align = k);
    let N = { type: "element", tagName: f, properties: R, children: [] };
    w && (N.children = t.all(w), t.patch(w, N), N = t.applyData(w, N)), S.push(N);
  }
  const E = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(S, !0)
  };
  return t.patch(n, E), t.applyData(n, E);
}
function iH(t, n) {
  const i = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, i), t.applyData(n, i);
}
const XO = 9, QO = 32;
function aH(t) {
  const n = String(t), i = /\r?\n|\r/g;
  let o = i.exec(n), u = 0;
  const f = [];
  for (; o; )
    f.push(
      KO(n.slice(u, o.index), u > 0, !0),
      o[0]
    ), u = o.index + o[0].length, o = i.exec(n);
  return f.push(KO(n.slice(u), u > 0, !1)), f.join("");
}
function KO(t, n, i) {
  let o = 0, u = t.length;
  if (n) {
    let f = t.codePointAt(o);
    for (; f === XO || f === QO; )
      o++, f = t.codePointAt(o);
  }
  if (i) {
    let f = t.codePointAt(u - 1);
    for (; f === XO || f === QO; )
      u--, f = t.codePointAt(u - 1);
  }
  return u > o ? t.slice(o, u) : "";
}
function oH(t, n) {
  const i = { type: "text", value: aH(String(n.value)) };
  return t.patch(n, i), t.applyData(n, i);
}
function lH(t, n) {
  const i = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(n, i), t.applyData(n, i);
}
const sH = {
  blockquote: $B,
  break: jB,
  code: IB,
  delete: FB,
  emphasis: UB,
  footnoteReference: BB,
  heading: HB,
  html: VB,
  imageReference: WB,
  image: YB,
  inlineCode: ZB,
  linkReference: qB,
  link: GB,
  listItem: XB,
  list: KB,
  paragraph: JB,
  // @ts-expect-error: root is different, but hard to type.
  root: eH,
  strong: tH,
  table: nH,
  tableCell: iH,
  tableRow: rH,
  text: oH,
  thematicBreak: lH,
  toml: vb,
  yaml: vb,
  definition: vb,
  footnoteDefinition: vb
};
function vb() {
}
const hD = -1, WS = 0, RS = 1, OS = 2, CC = 3, kC = 4, TC = 5, RC = 6, mD = 7, vD = 8, JO = typeof self == "object" ? self : globalThis, uH = (t, n) => {
  const i = (u, f) => (t.set(f, u), u), o = (u) => {
    if (t.has(u))
      return t.get(u);
    const [f, p] = n[u];
    switch (f) {
      case WS:
      case hD:
        return i(p, u);
      case RS: {
        const v = i([], u);
        for (const b of p)
          v.push(o(b));
        return v;
      }
      case OS: {
        const v = i({}, u);
        for (const [b, S] of p)
          v[o(b)] = o(S);
        return v;
      }
      case CC:
        return i(new Date(p), u);
      case kC: {
        const { source: v, flags: b } = p;
        return i(new RegExp(v, b), u);
      }
      case TC: {
        const v = i(/* @__PURE__ */ new Map(), u);
        for (const [b, S] of p)
          v.set(o(b), o(S));
        return v;
      }
      case RC: {
        const v = i(/* @__PURE__ */ new Set(), u);
        for (const b of p)
          v.add(o(b));
        return v;
      }
      case mD: {
        const { name: v, message: b } = p;
        return i(new JO[v](b), u);
      }
      case vD:
        return i(BigInt(p), u);
      case "BigInt":
        return i(Object(BigInt(p)), u);
    }
    return i(new JO[f](p), u);
  };
  return o;
}, e4 = (t) => uH(/* @__PURE__ */ new Map(), t)(0), Hp = "", { toString: cH } = {}, { keys: fH } = Object, Nv = (t) => {
  const n = typeof t;
  if (n !== "object" || !t)
    return [WS, n];
  const i = cH.call(t).slice(8, -1);
  switch (i) {
    case "Array":
      return [RS, Hp];
    case "Object":
      return [OS, Hp];
    case "Date":
      return [CC, Hp];
    case "RegExp":
      return [kC, Hp];
    case "Map":
      return [TC, Hp];
    case "Set":
      return [RC, Hp];
  }
  return i.includes("Array") ? [RS, i] : i.includes("Error") ? [mD, i] : [OS, i];
}, yb = ([t, n]) => t === WS && (n === "function" || n === "symbol"), dH = (t, n, i, o) => {
  const u = (p, v) => {
    const b = o.push(p) - 1;
    return i.set(v, b), b;
  }, f = (p) => {
    if (i.has(p))
      return i.get(p);
    let [v, b] = Nv(p);
    switch (v) {
      case WS: {
        let E = p;
        switch (b) {
          case "bigint":
            v = vD, E = p.toString();
            break;
          case "function":
          case "symbol":
            if (t)
              throw new TypeError("unable to serialize " + b);
            E = null;
            break;
          case "undefined":
            return u([hD], p);
        }
        return u([v, E], p);
      }
      case RS: {
        if (b)
          return u([b, [...p]], p);
        const E = [], w = u([v, E], p);
        for (const R of p)
          E.push(f(R));
        return w;
      }
      case OS: {
        if (b)
          switch (b) {
            case "BigInt":
              return u([b, p.toString()], p);
            case "Boolean":
            case "Number":
            case "String":
              return u([b, p.valueOf()], p);
          }
        if (n && "toJSON" in p)
          return f(p.toJSON());
        const E = [], w = u([v, E], p);
        for (const R of fH(p))
          (t || !yb(Nv(p[R]))) && E.push([f(R), f(p[R])]);
        return w;
      }
      case CC:
        return u([v, p.toISOString()], p);
      case kC: {
        const { source: E, flags: w } = p;
        return u([v, { source: E, flags: w }], p);
      }
      case TC: {
        const E = [], w = u([v, E], p);
        for (const [R, k] of p)
          (t || !(yb(Nv(R)) || yb(Nv(k)))) && E.push([f(R), f(k)]);
        return w;
      }
      case RC: {
        const E = [], w = u([v, E], p);
        for (const R of p)
          (t || !yb(Nv(R))) && E.push(f(R));
        return w;
      }
    }
    const { message: S } = p;
    return u([v, { name: b, message: S }], p);
  };
  return f;
}, t4 = (t, { json: n, lossy: i } = {}) => {
  const o = [];
  return dH(!(n || i), !!n, /* @__PURE__ */ new Map(), o)(t), o;
}, AS = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (t, n) => n && ("json" in n || "lossy" in n) ? e4(t4(t, n)) : structuredClone(t)
) : (t, n) => e4(t4(t, n));
function pH(t, n) {
  const i = [{ type: "text", value: "↩" }];
  return n > 1 && i.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(n) }]
  }), i;
}
function hH(t, n) {
  return "Back to reference " + (t + 1) + (n > 1 ? "-" + n : "");
}
function mH(t) {
  const n = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", i = t.options.footnoteBackContent || pH, o = t.options.footnoteBackLabel || hH, u = t.options.footnoteLabel || "Footnotes", f = t.options.footnoteLabelTagName || "h2", p = t.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, v = [];
  let b = -1;
  for (; ++b < t.footnoteOrder.length; ) {
    const S = t.footnoteById.get(t.footnoteOrder[b]);
    if (!S)
      continue;
    const E = t.all(S), w = String(S.identifier).toUpperCase(), R = hh(w.toLowerCase());
    let k = 0;
    const N = [], z = t.footnoteCounts.get(w);
    for (; z !== void 0 && ++k <= z; ) {
      N.length > 0 && N.push({ type: "text", value: " " });
      let q = typeof i == "string" ? i : i(b, k);
      typeof q == "string" && (q = { type: "text", value: q }), N.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + n + "fnref-" + R + (k > 1 ? "-" + k : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof o == "string" ? o : o(b, k),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(q) ? q : [q]
      });
    }
    const I = E[E.length - 1];
    if (I && I.type === "element" && I.tagName === "p") {
      const q = I.children[I.children.length - 1];
      q && q.type === "text" ? q.value += " " : I.children.push({ type: "text", value: " " }), I.children.push(...N);
    } else
      E.push(...N);
    const H = {
      type: "element",
      tagName: "li",
      properties: { id: n + "fn-" + R },
      children: t.wrap(E, !0)
    };
    t.patch(S, H), v.push(H);
  }
  if (v.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: f,
          properties: {
            ...AS(p),
            id: "footnote-label"
          },
          children: [{ type: "text", value: u }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: t.wrap(v, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function yD(t, n, i, o) {
  let u, f, p;
  typeof n == "function" && typeof i != "function" ? (f = void 0, p = n, u = i) : (f = n, p = i, u = o), YA(t, f, v, u);
  function v(b, S) {
    const E = S[S.length - 1], w = E ? E.children.indexOf(b) : void 0;
    return p(b, w, E);
  }
}
const PE = {}.hasOwnProperty, vH = {};
function yH(t, n) {
  const i = n || vH, o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), p = { ...sH, ...i.handlers }, v = {
    all: S,
    applyData: bH,
    definitionById: o,
    footnoteById: u,
    footnoteCounts: f,
    footnoteOrder: [],
    handlers: p,
    one: b,
    options: i,
    patch: gH,
    wrap: xH
  };
  return yD(t, function(E) {
    if (E.type === "definition" || E.type === "footnoteDefinition") {
      const w = E.type === "definition" ? o : u, R = String(E.identifier).toUpperCase();
      w.has(R) || w.set(R, E);
    }
  }), v;
  function b(E, w) {
    const R = E.type, k = v.handlers[R];
    if (PE.call(v.handlers, R) && k)
      return k(v, E, w);
    if (v.options.passThrough && v.options.passThrough.includes(R)) {
      if ("children" in E) {
        const { children: z, ...I } = E, H = AS(I);
        return H.children = v.all(E), H;
      }
      return AS(E);
    }
    return (v.options.unknownHandler || SH)(v, E, w);
  }
  function S(E) {
    const w = [];
    if ("children" in E) {
      const R = E.children;
      let k = -1;
      for (; ++k < R.length; ) {
        const N = v.one(R[k], E);
        if (N) {
          if (k && R[k - 1].type === "break" && (!Array.isArray(N) && N.type === "text" && (N.value = n4(N.value)), !Array.isArray(N) && N.type === "element")) {
            const z = N.children[0];
            z && z.type === "text" && (z.value = n4(z.value));
          }
          Array.isArray(N) ? w.push(...N) : w.push(N);
        }
      }
    }
    return w;
  }
}
function gH(t, n) {
  t.position && (n.position = pB(t));
}
function bH(t, n) {
  let i = n;
  if (t && t.data) {
    const o = t.data.hName, u = t.data.hChildren, f = t.data.hProperties;
    if (typeof o == "string")
      if (i.type === "element")
        i.tagName = o;
      else {
        const p = "children" in i ? i.children : [i];
        i = { type: "element", tagName: o, properties: {}, children: p };
      }
    i.type === "element" && f && Object.assign(i.properties, AS(f)), "children" in i && i.children && u !== null && u !== void 0 && (i.children = u);
  }
  return i;
}
function SH(t, n) {
  const i = n.data || {}, o = "value" in n && !(PE.call(i, "hProperties") || PE.call(i, "hChildren")) ? { type: "text", value: n.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: t.all(n)
  };
  return t.patch(n, o), t.applyData(n, o);
}
function xH(t, n) {
  const i = [];
  let o = -1;
  for (n && i.push({ type: "text", value: `
` }); ++o < t.length; )
    o && i.push({ type: "text", value: `
` }), i.push(t[o]);
  return n && t.length > 0 && i.push({ type: "text", value: `
` }), i;
}
function n4(t) {
  let n = 0, i = t.charCodeAt(n);
  for (; i === 9 || i === 32; )
    n++, i = t.charCodeAt(n);
  return t.slice(n);
}
function r4(t, n) {
  const i = yH(t, n), o = i.one(t, void 0), u = mH(i), f = Array.isArray(o) ? { type: "root", children: o } : o || { type: "root", children: [] };
  return u && f.children.push({ type: "text", value: `
` }, u), f;
}
function wH(t, n) {
  return t && "run" in t ? async function(i, o) {
    const u = (
      /** @type {HastRoot} */
      r4(i, { file: o, ...n })
    );
    await t.run(u, o);
  } : function(i, o) {
    return (
      /** @type {HastRoot} */
      r4(i, { file: o, ...n || t })
    );
  };
}
function i4(t) {
  if (t)
    throw t;
}
var Ub = Object.prototype.hasOwnProperty, gD = Object.prototype.toString, a4 = Object.defineProperty, o4 = Object.getOwnPropertyDescriptor, l4 = function(n) {
  return typeof Array.isArray == "function" ? Array.isArray(n) : gD.call(n) === "[object Array]";
}, s4 = function(n) {
  if (!n || gD.call(n) !== "[object Object]")
    return !1;
  var i = Ub.call(n, "constructor"), o = n.constructor && n.constructor.prototype && Ub.call(n.constructor.prototype, "isPrototypeOf");
  if (n.constructor && !i && !o)
    return !1;
  var u;
  for (u in n)
    ;
  return typeof u > "u" || Ub.call(n, u);
}, u4 = function(n, i) {
  a4 && i.name === "__proto__" ? a4(n, i.name, {
    enumerable: !0,
    configurable: !0,
    value: i.newValue,
    writable: !0
  }) : n[i.name] = i.newValue;
}, c4 = function(n, i) {
  if (i === "__proto__")
    if (Ub.call(n, i)) {
      if (o4)
        return o4(n, i).value;
    } else
      return;
  return n[i];
}, _H = function t() {
  var n, i, o, u, f, p, v = arguments[0], b = 1, S = arguments.length, E = !1;
  for (typeof v == "boolean" && (E = v, v = arguments[1] || {}, b = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); b < S; ++b)
    if (n = arguments[b], n != null)
      for (i in n)
        o = c4(v, i), u = c4(n, i), v !== u && (E && u && (s4(u) || (f = l4(u))) ? (f ? (f = !1, p = o && l4(o) ? o : []) : p = o && s4(o) ? o : {}, u4(v, { name: i, newValue: t(E, p, u) })) : typeof u < "u" && u4(v, { name: i, newValue: u }));
  return v;
};
const W_ = /* @__PURE__ */ jE(_H);
function zE(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const n = Object.getPrototypeOf(t);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function EH() {
  const t = [], n = { run: i, use: o };
  return n;
  function i(...u) {
    let f = -1;
    const p = u.pop();
    if (typeof p != "function")
      throw new TypeError("Expected function as last argument, not " + p);
    v(null, ...u);
    function v(b, ...S) {
      const E = t[++f];
      let w = -1;
      if (b) {
        p(b);
        return;
      }
      for (; ++w < u.length; )
        (S[w] === null || S[w] === void 0) && (S[w] = u[w]);
      u = S, E ? CH(E, v)(...S) : p(null, ...S);
    }
  }
  function o(u) {
    if (typeof u != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + u
      );
    return t.push(u), n;
  }
}
function CH(t, n) {
  let i;
  return o;
  function o(...p) {
    const v = t.length > p.length;
    let b;
    v && p.push(u);
    try {
      b = t.apply(this, p);
    } catch (S) {
      const E = (
        /** @type {Error} */
        S
      );
      if (v && i)
        throw E;
      return u(E);
    }
    v || (b && b.then && typeof b.then == "function" ? b.then(f, u) : b instanceof Error ? u(b) : f(b));
  }
  function u(p, ...v) {
    i || (i = !0, n(p, ...v));
  }
  function f(p) {
    u(null, p);
  }
}
const as = { basename: kH, dirname: TH, extname: RH, join: OH, sep: "/" };
function kH(t, n) {
  if (n !== void 0 && typeof n != "string")
    throw new TypeError('"ext" argument must be a string');
  gy(t);
  let i = 0, o = -1, u = t.length, f;
  if (n === void 0 || n.length === 0 || n.length > t.length) {
    for (; u--; )
      if (t.codePointAt(u) === 47) {
        if (f) {
          i = u + 1;
          break;
        }
      } else
        o < 0 && (f = !0, o = u + 1);
    return o < 0 ? "" : t.slice(i, o);
  }
  if (n === t)
    return "";
  let p = -1, v = n.length - 1;
  for (; u--; )
    if (t.codePointAt(u) === 47) {
      if (f) {
        i = u + 1;
        break;
      }
    } else
      p < 0 && (f = !0, p = u + 1), v > -1 && (t.codePointAt(u) === n.codePointAt(v--) ? v < 0 && (o = u) : (v = -1, o = p));
  return i === o ? o = p : o < 0 && (o = t.length), t.slice(i, o);
}
function TH(t) {
  if (gy(t), t.length === 0)
    return ".";
  let n = -1, i = t.length, o;
  for (; --i; )
    if (t.codePointAt(i) === 47) {
      if (o) {
        n = i;
        break;
      }
    } else
      o || (o = !0);
  return n < 0 ? t.codePointAt(0) === 47 ? "/" : "." : n === 1 && t.codePointAt(0) === 47 ? "//" : t.slice(0, n);
}
function RH(t) {
  gy(t);
  let n = t.length, i = -1, o = 0, u = -1, f = 0, p;
  for (; n--; ) {
    const v = t.codePointAt(n);
    if (v === 47) {
      if (p) {
        o = n + 1;
        break;
      }
      continue;
    }
    i < 0 && (p = !0, i = n + 1), v === 46 ? u < 0 ? u = n : f !== 1 && (f = 1) : u > -1 && (f = -1);
  }
  return u < 0 || i < 0 || // We saw a non-dot character immediately before the dot.
  f === 0 || // The (right-most) trimmed path component is exactly `..`.
  f === 1 && u === i - 1 && u === o + 1 ? "" : t.slice(u, i);
}
function OH(...t) {
  let n = -1, i;
  for (; ++n < t.length; )
    gy(t[n]), t[n] && (i = i === void 0 ? t[n] : i + "/" + t[n]);
  return i === void 0 ? "." : AH(i);
}
function AH(t) {
  gy(t);
  const n = t.codePointAt(0) === 47;
  let i = DH(t, !n);
  return i.length === 0 && !n && (i = "."), i.length > 0 && t.codePointAt(t.length - 1) === 47 && (i += "/"), n ? "/" + i : i;
}
function DH(t, n) {
  let i = "", o = 0, u = -1, f = 0, p = -1, v, b;
  for (; ++p <= t.length; ) {
    if (p < t.length)
      v = t.codePointAt(p);
    else {
      if (v === 47)
        break;
      v = 47;
    }
    if (v === 47) {
      if (!(u === p - 1 || f === 1))
        if (u !== p - 1 && f === 2) {
          if (i.length < 2 || o !== 2 || i.codePointAt(i.length - 1) !== 46 || i.codePointAt(i.length - 2) !== 46) {
            if (i.length > 2) {
              if (b = i.lastIndexOf("/"), b !== i.length - 1) {
                b < 0 ? (i = "", o = 0) : (i = i.slice(0, b), o = i.length - 1 - i.lastIndexOf("/")), u = p, f = 0;
                continue;
              }
            } else if (i.length > 0) {
              i = "", o = 0, u = p, f = 0;
              continue;
            }
          }
          n && (i = i.length > 0 ? i + "/.." : "..", o = 2);
        } else
          i.length > 0 ? i += "/" + t.slice(u + 1, p) : i = t.slice(u + 1, p), o = p - u - 1;
      u = p, f = 0;
    } else
      v === 46 && f > -1 ? f++ : f = -1;
  }
  return i;
}
function gy(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const MH = { cwd: NH };
function NH() {
  return "/";
}
function $E(t) {
  return !!(t !== null && typeof t == "object" && "href" in t && t.href && "protocol" in t && t.protocol && // @ts-expect-error: indexing is fine.
  t.auth === void 0);
}
function LH(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!$E(t)) {
    const n = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw n.code = "ERR_INVALID_ARG_TYPE", n;
  }
  if (t.protocol !== "file:") {
    const n = new TypeError("The URL must be of scheme file");
    throw n.code = "ERR_INVALID_URL_SCHEME", n;
  }
  return PH(t);
}
function PH(t) {
  if (t.hostname !== "") {
    const o = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw o.code = "ERR_INVALID_FILE_URL_HOST", o;
  }
  const n = t.pathname;
  let i = -1;
  for (; ++i < n.length; )
    if (n.codePointAt(i) === 37 && n.codePointAt(i + 1) === 50) {
      const o = n.codePointAt(i + 2);
      if (o === 70 || o === 102) {
        const u = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw u.code = "ERR_INVALID_FILE_URL_PATH", u;
      }
    }
  return decodeURIComponent(n);
}
const Y_ = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class bD {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(n) {
    let i;
    n ? $E(n) ? i = { path: n } : typeof n == "string" || zH(n) ? i = { value: n } : i = n : i = {}, this.cwd = MH.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let o = -1;
    for (; ++o < Y_.length; ) {
      const f = Y_[o];
      f in i && i[f] !== void 0 && i[f] !== null && (this[f] = f === "history" ? [...i[f]] : i[f]);
    }
    let u;
    for (u in i)
      Y_.includes(u) || (this[u] = i[u]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? as.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(n) {
    q_(n, "basename"), Z_(n, "basename"), this.path = as.join(this.dirname || "", n);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? as.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(n) {
    f4(this.basename, "dirname"), this.path = as.join(n || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? as.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(n) {
    if (Z_(n, "extname"), f4(this.dirname, "extname"), n) {
      if (n.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (n.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = as.join(this.dirname, this.stem + (n || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(n) {
    $E(n) && (n = LH(n)), q_(n, "path"), this.path !== n && this.history.push(n);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? as.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(n) {
    q_(n, "stem"), Z_(n, "stem"), this.path = as.join(this.dirname || "", n + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(n, i, o) {
    const u = this.message(n, i, o);
    throw u.fatal = !0, u;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(n, i, o) {
    const u = this.message(n, i, o);
    return u.fatal = void 0, u;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(n, i, o) {
    const u = new Gi(
      // @ts-expect-error: the overloads are fine.
      n,
      i,
      o
    );
    return this.path && (u.name = this.path + ":" + u.name, u.file = this.path), u.fatal = !1, this.messages.push(u), u;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(n) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(n || void 0).decode(this.value);
  }
}
function Z_(t, n) {
  if (t && t.includes(as.sep))
    throw new Error(
      "`" + n + "` cannot be a path: did not expect `" + as.sep + "`"
    );
}
function q_(t, n) {
  if (!t)
    throw new Error("`" + n + "` cannot be empty");
}
function f4(t, n) {
  if (!t)
    throw new Error("Setting `" + n + "` requires `path` to be set too");
}
function zH(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const $H = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(t) {
    const o = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), u = o[t], f = function() {
      return u.apply(f, arguments);
    };
    Object.setPrototypeOf(f, o);
    const p = Object.getOwnPropertyNames(u);
    for (const v of p) {
      const b = Object.getOwnPropertyDescriptor(u, v);
      b && Object.defineProperty(f, v, b);
    }
    return f;
  }
), jH = {}.hasOwnProperty;
class OC extends $H {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = EH();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const n = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new OC()
    );
    let i = -1;
    for (; ++i < this.attachers.length; ) {
      const o = this.attachers[i];
      n.use(...o);
    }
    return n.data(W_(!0, {}, this.namespace)), n;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > 👉 **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > 👉 **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(n, i) {
    return typeof n == "string" ? arguments.length === 2 ? (Q_("data", this.frozen), this.namespace[n] = i, this) : jH.call(this.namespace, n) && this.namespace[n] || void 0 : n ? (Q_("data", this.frozen), this.namespace = n, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const n = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [i, ...o] = this.attachers[this.freezeIndex];
      if (o[0] === !1)
        continue;
      o[0] === !0 && (o[0] = void 0);
      const u = i.call(n, ...o);
      typeof u == "function" && this.transformers.use(u);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > 👉 **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(n) {
    this.freeze();
    const i = gb(n), o = this.parser || this.Parser;
    return G_("parse", o), o(String(i), i);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > 👉 **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(n, i) {
    const o = this;
    return this.freeze(), G_("process", this.parser || this.Parser), X_("process", this.compiler || this.Compiler), i ? u(void 0, i) : new Promise(u);
    function u(f, p) {
      const v = gb(n), b = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        o.parse(v)
      );
      o.run(b, v, function(E, w, R) {
        if (E || !w || !R)
          return S(E);
        const k = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          w
        ), N = o.stringify(k, R);
        UH(N) ? R.value = N : R.result = N, S(
          E,
          /** @type {VFileWithOutput<CompileResult>} */
          R
        );
      });
      function S(E, w) {
        E || !w ? p(E) : f ? f(w) : i(void 0, w);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(n) {
    let i = !1, o;
    return this.freeze(), G_("processSync", this.parser || this.Parser), X_("processSync", this.compiler || this.Compiler), this.process(n, u), p4("processSync", "process", i), o;
    function u(f, p) {
      i = !0, i4(f), o = p;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > 👉 **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(n, i, o) {
    d4(n), this.freeze();
    const u = this.transformers;
    return !o && typeof i == "function" && (o = i, i = void 0), o ? f(void 0, o) : new Promise(f);
    function f(p, v) {
      const b = gb(i);
      u.run(n, b, S);
      function S(E, w, R) {
        const k = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          w || n
        );
        E ? v(E) : p ? p(k) : o(void 0, k, R);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(n, i) {
    let o = !1, u;
    return this.run(n, i, f), p4("runSync", "run", o), u;
    function f(p, v) {
      i4(p), u = v, o = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > 👉 **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(n, i) {
    this.freeze();
    const o = gb(i), u = this.compiler || this.Compiler;
    return X_("stringify", u), d4(n), u(n, o);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > 👉 **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(n, ...i) {
    const o = this.attachers, u = this.namespace;
    if (Q_("use", this.frozen), n != null)
      if (typeof n == "function")
        b(n, i);
      else if (typeof n == "object")
        Array.isArray(n) ? v(n) : p(n);
      else
        throw new TypeError("Expected usable value, not `" + n + "`");
    return this;
    function f(S) {
      if (typeof S == "function")
        b(S, []);
      else if (typeof S == "object")
        if (Array.isArray(S)) {
          const [E, ...w] = (
            /** @type {PluginTuple<Array<unknown>>} */
            S
          );
          b(E, w);
        } else
          p(S);
      else
        throw new TypeError("Expected usable value, not `" + S + "`");
    }
    function p(S) {
      if (!("plugins" in S) && !("settings" in S))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      v(S.plugins), S.settings && (u.settings = W_(!0, u.settings, S.settings));
    }
    function v(S) {
      let E = -1;
      if (S != null)
        if (Array.isArray(S))
          for (; ++E < S.length; ) {
            const w = S[E];
            f(w);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + S + "`");
    }
    function b(S, E) {
      let w = -1, R = -1;
      for (; ++w < o.length; )
        if (o[w][0] === S) {
          R = w;
          break;
        }
      if (R === -1)
        o.push([S, ...E]);
      else if (E.length > 0) {
        let [k, ...N] = E;
        const z = o[R][1];
        zE(z) && zE(k) && (k = W_(!0, z, k)), o[R] = [S, k, ...N];
      }
    }
  }
}
const IH = new OC().freeze();
function G_(t, n) {
  if (typeof n != "function")
    throw new TypeError("Cannot `" + t + "` without `parser`");
}
function X_(t, n) {
  if (typeof n != "function")
    throw new TypeError("Cannot `" + t + "` without `compiler`");
}
function Q_(t, n) {
  if (n)
    throw new Error(
      "Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function d4(t) {
  if (!zE(t) || typeof t.type != "string")
    throw new TypeError("Expected node, got `" + t + "`");
}
function p4(t, n, i) {
  if (!i)
    throw new Error(
      "`" + t + "` finished async. Use `" + n + "` instead"
    );
}
function gb(t) {
  return FH(t) ? t : new bD(t);
}
function FH(t) {
  return !!(t && typeof t == "object" && "message" in t && "messages" in t);
}
function UH(t) {
  return typeof t == "string" || BH(t);
}
function BH(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const HH = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", h4 = [], m4 = { allowDangerousHtml: !0 }, VH = /^(https?|ircs?|mailto|xmpp)$/i, WH = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function YH(t) {
  const n = t.allowedElements, i = t.allowElement, o = t.children || "", u = t.className, f = t.components, p = t.disallowedElements, v = t.rehypePlugins || h4, b = t.remarkPlugins || h4, S = t.remarkRehypeOptions ? { ...t.remarkRehypeOptions, ...m4 } : m4, E = t.skipHtml, w = t.unwrapDisallowed, R = t.urlTransform || ZH, k = IH().use(zB).use(b).use(wH, S).use(v), N = new bD();
  typeof o == "string" && (N.value = o);
  for (const q of WH)
    Object.hasOwn(t, q.from) && ("" + q.from + (q.to ? "use `" + q.to + "` instead" : "remove it") + HH + q.id, void 0);
  const z = k.parse(N);
  let I = k.runSync(z, N);
  return u && (I = {
    type: "element",
    tagName: "div",
    properties: { className: u },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      I.type === "root" ? I.children : [I]
    )
  }), yD(I, H), bB(I, {
    Fragment: oe.Fragment,
    components: f,
    ignoreInvalidStyle: !0,
    jsx: oe.jsx,
    jsxs: oe.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function H(q, G, te) {
    if (q.type === "raw" && te && typeof G == "number")
      return E ? te.children.splice(G, 1) : te.children[G] = { type: "text", value: q.value }, G;
    if (q.type === "element") {
      let ee;
      for (ee in V_)
        if (Object.hasOwn(V_, ee) && Object.hasOwn(q.properties, ee)) {
          const V = q.properties[ee], ue = V_[ee];
          (ue === null || ue.includes(q.tagName)) && (q.properties[ee] = R(String(V || ""), ee, q));
        }
    }
    if (q.type === "element") {
      let ee = n ? !n.includes(q.tagName) : p ? p.includes(q.tagName) : !1;
      if (!ee && i && typeof G == "number" && (ee = !i(q, G, te)), ee && te && typeof G == "number")
        return w && q.children ? te.children.splice(G, 1, ...q.children) : te.children.splice(G, 1), G;
    }
  }
}
function ZH(t) {
  const n = t.indexOf(":"), i = t.indexOf("?"), o = t.indexOf("#"), u = t.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    n < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    u > -1 && n > u || i > -1 && n > i || o > -1 && n > o || // It is a protocol, it should be allowed.
    VH.test(t.slice(0, n)) ? t : ""
  );
}
const qH = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20viewBox='0%200%20512.001%20512.001'%20xml:space='preserve'%3e%3cpath%20style='fill:%23FF3C63;'%20d='M479.728,114.762H32.273c-13.326,0-24.13,10.803-24.13,24.13v269.083%20c0,13.326,10.803,24.13,24.13,24.13h447.456c13.326,0,24.13-10.803,24.13-24.13V138.892%20C503.858,125.566,493.055,114.762,479.728,114.762z'/%3e%3cpath%20style='fill:%23EEE5DD;'%20d='M360.983,79.894C303.003,79.894,256,90.43,256,103.427c0-12.996-47.003-23.532-104.983-23.532%20S46.033,90.43,46.033,103.427v325.836c0-12.996,47.003-23.532,104.983-23.532S256,416.266,256,429.262%20c0-12.996,47.003-23.532,104.983-23.532s104.983,10.536,104.983,23.532V103.428C465.967,90.43,418.964,79.894,360.983,79.894z'/%3e%3cpath%20style='opacity:0.3;fill:%2320272E;enable-background:new%20;'%20d='M479.728,114.762h-13.762v-11.334%20c0-12.996-47.003-23.532-104.983-23.532S256,90.431,256,103.428v328.678h223.728c13.326,0,24.13-10.803,24.13-24.13V138.892%20C503.858,125.565,493.055,114.762,479.728,114.762z'/%3e%3crect%20x='78.307'%20y='134.869'%20style='fill:%23A6998E;'%20width='145.421'%20height='171.303'/%3e%3ccircle%20style='fill:%23EEE5DD;'%20cx='151.012'%20cy='220.515'%20r='72.711'/%3e%3cpolygon%20style='fill:%23A6998E;'%20points='151.017,282.946%20136.06,236.914%2087.66,236.914%20126.817,208.465%20111.86,162.434%20151.017,190.882%20190.173,162.434%20175.217,208.465%20214.373,236.914%20165.972,236.914%20'/%3e%3cg%3e%3cpath%20style='fill:%2320272E;'%20d='M223.726,126.725H78.306c-4.498,0-8.142,3.646-8.142,8.142v171.301c0,4.497,3.644,8.142,8.142,8.142%20h145.42c4.498,0,8.142-3.646,8.142-8.142V134.868C231.868,130.371,228.224,126.725,223.726,126.725z%20M86.448,143.01h41.594%20c-16.779,4.982-31.297,15.262-41.594,28.907V143.01z%20M151.017,155.951c9.409,0,18.346,2.04,26.417,5.675l-26.417,19.193%20L124.6,161.625C132.669,157.991,141.606,155.951,151.017,155.951z%20M106.88,173.455l10.365,31.9l-30.418,22.101%20c-0.245-2.28-0.378-4.593-0.378-6.937C86.448,201.974,94.318,185.242,106.88,173.455z%20M86.448,298.026v-28.907%20c10.297,13.646,24.816,23.925,41.594,28.907H86.448z%20M91.305,245.057h38.839l12.839,39.512%20C119.565,281.647,100.006,266.15,91.305,245.057z%20M151.017,256.597l-7.213-22.198c-1.09-3.355-4.217-5.627-7.744-5.627h-23.341%20l18.884-13.72c2.854-2.074,4.048-5.748,2.958-9.103l-7.213-22.199l18.884,13.719c2.854,2.074,6.718,2.074,9.571,0l18.884-13.719%20l-7.213,22.198c-1.09,3.355,0.104,7.031,2.958,9.104l18.884,13.719h-23.34c-3.527,0-6.654,2.271-7.744,5.626L151.017,256.597z%20M171.889,245.057h38.838c-8.7,21.093-28.259,36.59-51.677,39.512L171.889,245.057z%20M215.584,298.026H173.99%20c16.779-4.982,31.297-15.262,41.594-28.907V298.026z%20M215.206,227.455l-30.419-22.1l10.366-31.899%20c12.561,11.788,20.431,28.519,20.431,47.063C215.584,222.862,215.451,225.175,215.206,227.455z%20M215.584,171.918%20c-10.297-13.646-24.816-23.925-41.594-28.907h41.594V171.918z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M223.726,346.427H78.306c-4.498,0-8.142-3.646-8.142-8.142s3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142S228.224,346.427,223.726,346.427z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M433.693,147.152h-145.42c-4.498,0-8.142-3.646-8.142-8.142c0-4.497,3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142C441.835,143.506,438.191,147.152,433.693,147.152z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M433.693,182.095h-145.42c-4.498,0-8.142-3.646-8.142-8.142c0-4.497,3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142C441.835,178.45,438.191,182.095,433.693,182.095z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M433.693,217.038h-145.42c-4.498,0-8.142-3.646-8.142-8.142c0-4.497,3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142C441.835,213.392,438.191,217.038,433.693,217.038z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M433.693,251.981h-145.42c-4.498,0-8.142-3.646-8.142-8.142c0-4.497,3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142C441.835,248.335,438.191,251.981,433.693,251.981z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M433.693,286.924h-145.42c-4.498,0-8.142-3.646-8.142-8.142c0-4.497,3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142C441.835,283.279,438.191,286.924,433.693,286.924z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M433.693,321.868h-145.42c-4.498,0-8.142-3.646-8.142-8.142c0-4.497,3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142C441.835,318.222,438.191,321.868,433.693,321.868z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M223.726,375.472H78.306c-4.498,0-8.142-3.646-8.142-8.142s3.644-8.142,8.142-8.142h145.42%20c4.498,0,8.142,3.646,8.142,8.142S228.224,375.472,223.726,375.472z'/%3e%3cpath%20style='fill:%2320272E;'%20d='M479.728,106.619h-5.619v-3.192c0-10.946-12.14-18.988-37.11-24.585%20c-20.396-4.572-47.392-7.089-76.016-7.089s-55.619,2.518-76.016,7.089c-13.218,2.963-22.837,6.61-28.968,11.012%20c-6.13-4.401-15.75-8.049-28.968-11.012c-20.396-4.572-47.392-7.089-76.016-7.089s-55.619,2.518-76.016,7.089%20c-24.971,5.598-37.11,13.639-37.11,24.585v3.192h-5.618C14.477,106.619,0,121.097,0,138.892v269.083%20c0,17.795,14.477,32.273,32.273,32.273h447.456c17.796,0,32.273-14.477,32.273-32.273V138.892%20C512,121.097,497.523,106.619,479.728,106.619z%20M37.89,423.963h-5.618c-8.815,0-15.988-7.172-15.988-15.988V138.892%20c0-8.815,7.172-15.988,15.988-15.988h5.618V423.963z%20M66.159,423.963c0.056-0.02,0.112-0.038,0.169-0.058%20c0.468-0.156,0.948-0.314,1.447-0.472c0.029-0.01,0.06-0.018,0.09-0.028c0.49-0.154,0.999-0.309,1.52-0.465%20c0.161-0.048,0.324-0.096,0.487-0.143c0.441-0.129,0.893-0.259,1.356-0.389c0.131-0.037,0.258-0.074,0.391-0.111%20c0.573-0.159,1.166-0.317,1.773-0.477c0.173-0.046,0.35-0.09,0.524-0.136c0.487-0.125,0.986-0.251,1.495-0.376%20c0.181-0.044,0.362-0.089,0.545-0.134c0.66-0.16,1.336-0.319,2.032-0.478c0.145-0.034,0.297-0.066,0.445-0.1%20c0.586-0.131,1.184-0.264,1.797-0.394c0.213-0.046,0.426-0.091,0.642-0.137c0.763-0.161,1.538-0.32,2.341-0.479%20c18.661-3.687,42.742-5.717,67.802-5.717s49.141,2.03,67.802,5.717c0.802,0.159,1.577,0.318,2.341,0.479%20c0.216,0.046,0.429,0.091,0.642,0.137c0.611,0.131,1.21,0.263,1.797,0.394c0.148,0.034,0.299,0.066,0.445,0.1%20c0.696,0.159,1.372,0.318,2.032,0.478c0.185,0.044,0.364,0.089,0.545,0.134c0.509,0.125,1.007,0.251,1.495,0.376%20c0.175,0.046,0.353,0.09,0.524,0.136c0.608,0.159,1.2,0.317,1.774,0.477c0.132,0.037,0.258,0.073,0.389,0.11%20c0.464,0.13,0.917,0.261,1.359,0.39c0.163,0.048,0.326,0.096,0.485,0.143c0.52,0.155,1.03,0.311,1.52,0.465%20c0.029,0.01,0.06,0.018,0.09,0.028c0.5,0.159,0.979,0.316,1.447,0.472c0.058,0.02,0.113,0.038,0.169,0.058L66.159,423.963%20L66.159,423.963z%20M247.858,114.762v296.392c-5.515-2.445-12.448-4.598-20.826-6.476c-20.396-4.572-47.392-7.089-76.016-7.089%20s-55.619,2.518-76.016,7.089c-8.378,1.878-15.311,4.031-20.826,6.476V114.762v-10.607c1.558-1.813,8.984-6.44,29.039-10.402%20c18.661-3.687,42.742-5.717,67.802-5.717s49.141,2.03,67.802,5.717c20.055,3.961,27.481,8.588,29.039,10.402v10.607H247.858z%20M276.127,423.963c0.056-0.02,0.112-0.038,0.169-0.058c0.468-0.156,0.948-0.314,1.447-0.472c0.029-0.01,0.06-0.018,0.09-0.028%20c0.49-0.154,0.999-0.309,1.52-0.465c0.161-0.048,0.324-0.096,0.487-0.143c0.441-0.129,0.893-0.259,1.356-0.389%20c0.131-0.037,0.258-0.074,0.391-0.111c0.573-0.159,1.166-0.317,1.773-0.477c0.173-0.046,0.35-0.09,0.524-0.136%20c0.487-0.125,0.986-0.251,1.495-0.376c0.181-0.044,0.362-0.089,0.545-0.134c0.66-0.16,1.336-0.319,2.032-0.478%20c0.145-0.034,0.297-0.066,0.445-0.1c0.586-0.131,1.184-0.264,1.797-0.394c0.213-0.046,0.426-0.091,0.642-0.137%20c0.763-0.161,1.538-0.32,2.341-0.479c18.661-3.687,42.742-5.717,67.802-5.717s49.141,2.03,67.802,5.717%20c0.802,0.159,1.577,0.318,2.341,0.479c0.216,0.046,0.429,0.091,0.642,0.137c0.611,0.131,1.21,0.263,1.797,0.394%20c0.148,0.034,0.299,0.066,0.445,0.1c0.696,0.159,1.372,0.318,2.032,0.478c0.185,0.044,0.364,0.089,0.545,0.134%20c0.509,0.125,1.008,0.251,1.495,0.376c0.175,0.046,0.353,0.09,0.524,0.136c0.608,0.159,1.2,0.317,1.774,0.477%20c0.132,0.037,0.258,0.073,0.389,0.11c0.464,0.13,0.917,0.261,1.359,0.39c0.163,0.048,0.326,0.096,0.485,0.143%20c0.52,0.155,1.03,0.311,1.52,0.465c0.029,0.01,0.06,0.018,0.09,0.028c0.5,0.159,0.979,0.316,1.447,0.472%20c0.058,0.02,0.113,0.038,0.169,0.058L276.127,423.963L276.127,423.963z%20M457.824,114.762v296.392%20c-5.515-2.445-12.448-4.598-20.826-6.476c-20.396-4.572-47.392-7.089-76.016-7.089s-55.619,2.518-76.016,7.089%20c-8.378,1.878-15.311,4.031-20.826,6.476V114.762v-10.607c1.558-1.813,8.984-6.44,29.039-10.402%20c18.661-3.687,42.742-5.717,67.802-5.717c25.061,0,49.141,2.03,67.802,5.717c20.055,3.961,27.481,8.588,29.039,10.402v10.607%20H457.824z%20M495.715,407.975c0,8.815-7.172,15.988-15.988,15.988h-5.619V122.904h5.619c8.815,0,15.988,7.172,15.988,15.988V407.975z%20'/%3e%3c/g%3e%3c/svg%3e";
function GH({
  apiConfig: t,
  onClose: n
}) {
  var z;
  const [i, o] = L.useState(""), [u, f] = L.useState({}), { defaultValue: p, schema: v, machine: b } = L.useMemo(() => {
    const I = ss.getPageSchema(), H = ss.getCurrentSchema(), q = $3(I, (H == null ? void 0 : H.id) || "");
    if (!(q != null && q.componentName))
      return {
        defaultValue: q,
        machine: jO(DE, t)
      };
    const G = tU(q.componentName), te = jO(G, t);
    return { defaultValue: q, machine: te, schema: I };
  }, [t]), [S, E] = L.useState((z = fU(p)) == null ? void 0 : z.props), [w, R] = K7(b), k = L.useCallback(() => {
    R({
      type: "add_user_message",
      userMessages: i ? [i] : [],
      fieldMessages: jF(u).concat({
        role: "user",
        content: `当前组件属性为

\`\`\`json
${JSON.stringify(S)}
\`\`\``
      })
    }), o("");
  }, [S, i, R, u]), { form: N } = w.context;
  return L.useEffect(() => {
    var I;
    for (const H of w.context.choices.slice(0, 1))
      for (const q of H.message.tool_calls || [])
        ((I = H.message.tool_calls) == null ? void 0 : I.length) === 1 && q.function.name === N.name && E(JSON.parse(q.function.arguments));
  }, [w.context, N.name]), N.name === DE.name ? /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
    /* @__PURE__ */ oe.jsx(Qv, { children: /* @__PURE__ */ oe.jsx(oE, { children: "当前组件未支持 AI 编辑" }) }),
    /* @__PURE__ */ oe.jsx(
      Qp,
      {
        variant: "default",
        onClick: () => {
          n();
        },
        children: "关闭"
      }
    )
  ] }) : /* @__PURE__ */ oe.jsxs(oe.Fragment, { children: [
    /* @__PURE__ */ oe.jsx(Qv, { children: /* @__PURE__ */ oe.jsx(oE, { children: "修改组件属性" }) }),
    /* @__PURE__ */ oe.jsxs("div", { className: "flex flex-col px-1", children: [
      w.matches("wait_user_input") && w.context.choices.length > 0 && /* @__PURE__ */ oe.jsx(G3, { className: "flex-1 rounded-md mt-2", children: w.context.choices.slice(0, 1).map((I) => /* @__PURE__ */ oe.jsxs("div", { children: [
        !!I.message.content && /* @__PURE__ */ oe.jsx(YH, { className: "my-2", children: I.message.content }),
        (I.message.tool_calls || []).map((H) => {
          var G, te;
          if (((G = I.message.tool_calls) == null ? void 0 : G.length) === 1 && H.function.name === N.name && N.ui)
            return /* @__PURE__ */ oe.jsx(
              N.ui,
              {
                value: S,
                onChange: E
              },
              H.id
            );
          const q = $F(N, H);
          return q != null && q.ui ? /* @__PURE__ */ oe.jsx("div", { children: /* @__PURE__ */ oe.jsx(
            q.ui,
            {
              ...q.props,
              value: ((te = u[q.id]) == null ? void 0 : te.value) ?? q.props.value,
              onChange: (ee) => {
                f({
                  ...u,
                  [q.id]: {
                    value: ee,
                    functionName: q.functionName,
                    functionArguments: q.functionArguments
                  }
                });
              },
              onSubmit: k
            }
          ) }, q.id) : null;
        })
      ] }, I.index)) }),
      w.matches("wait_user_input") && w.context.choices.length === 0 && N.ui && S && /* @__PURE__ */ oe.jsx(N.ui, { value: S, onChange: E }),
      w.matches("loading") && /* @__PURE__ */ oe.jsx("div", { className: "text-slate-400 animate-blink flex-1 flex border items-center justify-center", children: "loading..." }),
      w.matches("headless_field_loading") && /* @__PURE__ */ oe.jsx("div", { className: "text-slate-400 animate-blink flex-1 flex border items-center justify-center", children: "calling headless function..." }),
      /* @__PURE__ */ oe.jsxs("div", { className: "mt-2 mb-4 flex justify-end items-end", children: [
        /* @__PURE__ */ oe.jsx(
          hy,
          {
            className: "w-full mt-4",
            rows: 2,
            value: i,
            onChange: (I) => {
              o(I.currentTarget.value);
            },
            placeholder: "输入指令，智能修改组件..."
          }
        ),
        /* @__PURE__ */ oe.jsx(
          Qp,
          {
            variant: "outline",
            onClick: k,
            disabled: !w.matches("wait_user_input"),
            className: "w-[100px] ml-4",
            children: /* @__PURE__ */ oe.jsxs(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "black",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ oe.jsx("path", { d: "m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" }),
                  /* @__PURE__ */ oe.jsx("path", { d: "M5 3v4" }),
                  /* @__PURE__ */ oe.jsx("path", { d: "M19 17v4" }),
                  /* @__PURE__ */ oe.jsx("path", { d: "M3 5h4" }),
                  /* @__PURE__ */ oe.jsx("path", { d: "M17 19h4" })
                ]
              }
            )
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ oe.jsx(
      Qp,
      {
        variant: "default",
        onClick: () => {
          p && (p.props = S, dU(p), ss.saveSchema(v)), n();
        },
        children: "保存"
      }
    )
  ] });
}
const XH = L.forwardRef((t, n) => /* @__PURE__ */ oe.jsx("img", { src: qH, ref: n, ...t, width: 24, height: 24 }));
customElements.define("ai-plugin-component-editor", qA(GH, XH));
const QH = {};
function KH(t, n, i, o, u, f) {
  const p = v4("ai-plugin-component-editor");
  return y4(), g4("div", null, [
    b4(p)
  ]);
}
const JH = /* @__PURE__ */ GA(QH, [["render", KH]]), gV = (t) => (ss.di = t, {
  PageCreator: {
    id: "PageCreator",
    title: "AI page creator",
    icon: F9,
    align: "bottom"
  },
  ComponentEditor: {
    id: "ComponentEditor",
    title: "AI component editor",
    icon: JH,
    align: "bottom"
  }
});
export {
  gV as getPlugins
};
